{
  "01_Arrays_and_Hashing": {
    "01_Contains_Duplicate": {
      "difficulty": "Easy",
      "high_freq": false,
      "follow_ups": ["如果陣列已排序怎麼辦？", "如果只能用 O(1) 空間怎麼辦？"],
      "red_flags": ["忘記處理空陣列", "使用 O(n²) 暴力解但未說明可優化"],
      "bonus_points": ["主動提到 Hash collision 最壞情況", "討論 Set vs Map 的選擇"]
    },
    "02_Valid_Anagram": {
      "difficulty": "Easy",
      "high_freq": false,
      "follow_ups": ["如果輸入包含 Unicode 字元？", "如果字串非常長，有更快的方法嗎？"],
      "red_flags": ["忘記考慮大小寫敏感", "沒有處理空字串"],
      "bonus_points": ["提到排序解法的 trade-off", "討論固定大小陣列 vs Hash Map"]
    },
    "03_Two_Sum": {
      "difficulty": "Easy",
      "high_freq": true,
      "follow_ups": ["如果有多組解怎麼辦？", "如果陣列已排序呢？（延伸到 Two Sum II）"],
      "red_flags": ["返回錯誤的 index 類型", "沒有考慮同一元素使用兩次"],
      "bonus_points": ["一次遍歷內完成", "主動討論 Hash Map vs 暴力解的 trade-off"]
    },
    "04_Group_Anagrams": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如何處理 Unicode？", "有比排序更快的 Hash Key 嗎？"],
      "red_flags": ["Key 設計不當導致碰撞", "忘記初始化結果容器"],
      "bonus_points": ["討論排序 vs 計數陣列作為 Key", "時間複雜度分析完整"]
    },
    "05_Top_K_Frequent_Elements": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如果 K 非常大怎麼辦？", "能否做到 O(n) 時間？"],
      "red_flags": ["沒有處理 K > unique elements 的情況", "使用全排序導致效率低"],
      "bonus_points": ["知道 Bucket Sort 解法", "討論 Heap vs QuickSelect"]
    },
    "06_Product_of_Array_Except_Self": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如果有 0 怎麼辦？", "能否處理整數溢位？"],
      "red_flags": ["使用除法（題目禁止）", "沒有處理多個 0 的情況"],
      "bonus_points": ["一趟遍歷完成", "討論前綴積與後綴積的概念"]
    },
    "07_Valid_Sudoku": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如何擴展到解數獨？", "有沒有更高效的位運算解法？"],
      "red_flags": ["3x3 Box 的索引計算錯誤", "沒有跳過空格 '.'"],
      "bonus_points": ["用 bitmask 優化空間", "正確計算 box index: (r/3)*3 + c/3"]
    },
    "08_Encode_and_Decode_Strings": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如果字串包含特殊字元怎麼辦？", "如何做到流式處理？"],
      "red_flags": ["分隔符可能出現在字串內容中", "整數解析錯誤"],
      "bonus_points": ["設計 Length-Prefix 編碼", "主動討論各種編碼方案的優缺點"]
    },
    "09_Longest_Consecutive_Sequence": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如果允許重複數字呢？", "能否處理極大的數值範圍？"],
      "red_flags": ["從每個數字都開始搜尋導致 O(n²)", "沒有檢查是否為序列起點"],
      "bonus_points": ["只從序列起點開始搜尋的優化", "Union-Find 替代解法"]
    }
  },
  "02_Two_Pointers": {
    "01_Valid_Palindrome": {
      "difficulty": "Easy",
      "high_freq": false,
      "follow_ups": ["如何處理 Unicode 和多語言？", "如果允許刪除一個字元呢？"],
      "red_flags": ["沒有忽略非字母數字字元", "大小寫處理錯誤"],
      "bonus_points": ["一次遍歷完成", "主動討論雙指標的優勢"]
    },
    "02_Two_Sum_II": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如果有多組解怎麼辦？", "如何擴展到 3Sum？"],
      "red_flags": ["沒有利用已排序的特性", "返回 0-indexed 而非 1-indexed"],
      "bonus_points": ["解釋為何雙指標保證正確性", "討論與 Hash Map 解法的比較"]
    },
    "03_3Sum": {
      "difficulty": "Medium",
      "high_freq": true,
      "follow_ups": ["3Sum Closest? 4Sum?", "如何處理重複解？"],
      "red_flags": ["沒有去重導致重複解", "排序後忘記解的 indices 已改變"],
      "bonus_points": ["清晰的去重邏輯", "時間複雜度分析：O(n²)"]
    },
    "04_Container_With_Most_Water": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如果允許傾斜容器呢？", "Trapping Rain Water 的差異？"],
      "red_flags": ["移動錯誤的指標", "不理解為何可以安全移動較短的那邊"],
      "bonus_points": ["清晰解釋貪心策略的正確性", "與暴力解的對比"]
    },
    "05_Trapping_Rain_Water": {
      "difficulty": "Hard",
      "high_freq": true,
      "follow_ups": ["2D 版本怎麼做？", "如何優化空間到 O(1)？"],
      "red_flags": ["雙指標移動邏輯錯誤", "沒有維護左右最大高度"],
      "bonus_points": ["三種解法：DP、雙指標、Monotonic Stack", "解釋每格水量計算公式"]
    }
  },
  "03_Sliding_Window": {
    "01_Best_Time_to_Buy_and_Sell_Stock": {
      "difficulty": "Easy",
      "high_freq": false,
      "follow_ups": ["如果可以多次買賣？", "如果有交易手續費？"],
      "red_flags": ["嘗試 O(n²) 暴力解", "沒有維護最小價格"],
      "bonus_points": ["一趟遍歷 O(n)", "解釋 Kadane 變形的概念"]
    },
    "02_Longest_Substring_Without_Repeating": {
      "difficulty": "Medium",
      "high_freq": true,
      "follow_ups": ["如果只算字母呢？", "如何處理 Unicode？"],
      "red_flags": ["滑動窗口邊界更新錯誤", "map 沒有正確更新字元位置"],
      "bonus_points": ["使用固定大小陣列優化", "清晰的窗口收縮條件"]
    },
    "03_Longest_Repeating_Character_Replacement": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如果有多種字元可替換？", "如何處理大小寫？"],
      "red_flags": ["沒有維護窗口內最多字元計數", "替換次數計算錯誤"],
      "bonus_points": ["理解 maxCount 不需要遞減的巧妙設計", "公式: window_size - maxCount <= k"]
    },
    "04_Permutation_in_String": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["Find All Anagrams in a String?", "如何處理 Unicode？"],
      "red_flags": ["窗口大小不固定", "比較兩個頻率表方式低效"],
      "bonus_points": ["使用 matches 計數器優化", "固定大小滑動窗口"]
    },
    "05_Minimum_Window_Substring": {
      "difficulty": "Hard",
      "high_freq": true,
      "follow_ups": ["如果需要返回所有最小視窗？", "如何處理重複字元？"],
      "red_flags": ["沒有正確計算 required/formed", "窗口收縮條件錯誤"],
      "bonus_points": ["O(n) 時間複雜度", "清晰的擴展/收縮邏輯"]
    },
    "06_Sliding_Window_Maximum": {
      "difficulty": "Hard",
      "high_freq": false,
      "follow_ups": ["如果需要滑動視窗最小值？", "兩者如何組合？"],
      "red_flags": ["Deque 維護邏輯錯誤", "沒有移除過期元素"],
      "bonus_points": ["Monotonic Deque", "解釋單調遞減的必要性"]
    }
  },
  "04_Stack": {
    "01_Valid_Parentheses": {
      "difficulty": "Easy",
      "high_freq": false,
      "follow_ups": ["如果只需檢查是否可以補全呢？", "如何處理更多種括號？"],
      "red_flags": ["pop 空 stack 時沒有檢查", "括號對應關係錯誤"],
      "bonus_points": ["邊界情況完整處理", "只用一個 stack 完成"]
    },
    "02_Min_Stack": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如何優化空間？", "如果需要 Max Stack？"],
      "red_flags": ["min stack 同步更新錯誤", "pop 時沒有維護 min"],
      "bonus_points": ["討論空間優化方案", "解釋雙 stack 設計原理"]
    },
    "03_Evaluate_Reverse_Polish_Notation": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如何從中綴轉後綴？", "如何處理更多運算符？"],
      "red_flags": ["除法順序錯誤 (a/b vs b/a)", "整數除法截斷方向"],
      "bonus_points": ["解釋 RPN 的優勢", "完整的運算符處理"]
    },
    "04_Generate_Parentheses": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如何枚舉所有 BST 結構？", "Catalan Number?"],
      "red_flags": ["剪枝條件錯誤", "沒有維護 open/close 計數"],
      "bonus_points": ["清晰的遞迴終止條件", "解釋 Catalan Number"]
    },
    "05_Daily_Temperatures": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["Next Greater Element II (circular)?", "如何處理相等的溫度？"],
      "red_flags": ["Stack 儲存錯誤的資訊", "單調性維護錯誤"],
      "bonus_points": ["Monotonic Decreasing Stack", "解釋為何從右到左也可行"]
    },
    "06_Car_Fleet": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["Car Fleet II (計算碰撞時間)?", "多車道？"],
      "red_flags": ["排序方向錯誤", "時間計算公式錯誤"],
      "bonus_points": ["清晰的模擬思路", "解釋為何從終點往起點考慮"]
    },
    "07_Largest_Rectangle_in_Histogram": {
      "difficulty": "Hard",
      "high_freq": true,
      "follow_ups": ["Maximal Rectangle in Matrix?", "2D 擴展？"],
      "red_flags": ["邊界處理錯誤", "Stack 沒有加入 sentinel"],
      "bonus_points": ["Monotonic Stack 完整解釋", "面積計算公式清晰"]
    }
  },
  "05_Binary_Search": {
    "01_Binary_Search": {
      "difficulty": "Easy",
      "high_freq": false,
      "follow_ups": ["如何找 lower/upper bound？", "浮點數二分？"],
      "red_flags": ["mid 計算溢位", "邊界條件 l <= r vs l < r"],
      "bonus_points": ["討論各種 Binary Search 模板", "避免溢位的 mid 計算方式"]
    },
    "02_Search_a_2D_Matrix": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["Search a 2D Matrix II?", "複雜度差異？"],
      "red_flags": ["2D 到 1D 轉換公式錯誤", "邊界處理錯誤"],
      "bonus_points": ["清晰的座標轉換", "討論兩種 2D 矩陣的差異"]
    },
    "03_Koko_Eating_Bananas": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如何找最大速度？", "如果有多堆必須按順序吃？"],
      "red_flags": ["Search space 邊界錯誤", "向上取整計算錯誤"],
      "bonus_points": ["Binary Search on Answer", "清晰的 feasibility check"]
    },
    "04_Find_Minimum_in_Rotated_Sorted_Array": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如果有重複元素？", "Find Maximum？"],
      "red_flags": ["比較對象選擇錯誤", "邊界更新錯誤"],
      "bonus_points": ["解釋與 nums[-1] 比較的原因", "處理已排序的情況"]
    },
    "05_Search_in_Rotated_Sorted_Array": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如果有重複？", "Find Min + Binary Search 兩步法？"],
      "red_flags": ["判斷哪半邊有序的邏輯錯誤", "邊界條件複雜容易出錯"],
      "bonus_points": ["一次 Binary Search 完成", "清晰的分類討論"]
    },
    "06_Time_Based_Key_Value_Store": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如果需要支援刪除？", "如何優化記憶體？"],
      "red_flags": ["Binary Search 找 upper_bound 錯誤", "資料結構設計不當"],
      "bonus_points": ["討論 std::map 的 upper_bound 應用", "設計決策的解釋"]
    },
    "07_Median_of_Two_Sorted_Arrays": {
      "difficulty": "Hard",
      "high_freq": true,
      "follow_ups": ["K-th Element?", "如果陣列可能為空？"],
      "red_flags": ["Partition 邊界計算錯誤", "沒有處理邊界 -∞/+∞"],
      "bonus_points": ["O(log(min(m,n)))", "清晰的 partition 概念解釋"]
    }
  },
  "06_Linked_List": {
    "01_Reverse_Linked_List": {
      "difficulty": "Easy",
      "high_freq": true,
      "follow_ups": ["遞迴版本？", "K 個一組反轉？"],
      "red_flags": ["沒有保存 next 指標", "忘記返回新頭節點"],
      "bonus_points": ["迭代和遞迴兩種解法", "清晰的指標操作解釋"]
    },
    "02_Merge_Two_Sorted_Lists": {
      "difficulty": "Easy",
      "high_freq": false,
      "follow_ups": ["Merge K Sorted Lists?", "原地合併？"],
      "red_flags": ["沒有處理空鏈表", "沒有處理剩餘節點"],
      "bonus_points": ["使用 dummy head 簡化", "解釋時間空間複雜度"]
    },
    "03_Reorder_List": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如果需要保持原順序？", "遞迴方式？"],
      "red_flags": ["找中點邏輯錯誤", "合併時斷鏈"],
      "bonus_points": ["三步驟：找中點、反轉後半、合併", "原地操作 O(1) 空間"]
    },
    "04_Remove_Nth_Node_From_End": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如何一趟遍歷完成？", "如果 n 無效？"],
      "red_flags": ["快慢指標間距錯誤", "刪除頭節點情況"],
      "bonus_points": ["雙指標一趟遍歷", "使用 dummy head 簡化"]
    },
    "05_Copy_List_with_Random_Pointer": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["O(1) 空間解法？", "Clone Graph?"],
      "red_flags": ["Hash Map 對應關係錯誤", "random 指標處理錯誤"],
      "bonus_points": ["Interleaving 解法 O(1) 空間", "兩種解法的 trade-off"]
    },
    "06_Add_Two_Numbers": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如果數字正序存儲？", "如何處理極大的數？"],
      "red_flags": ["進位處理錯誤", "沒有處理不同長度"],
      "bonus_points": ["完整的進位邏輯", "最後的 carry 處理"]
    },
    "07_Linked_List_Cycle": {
      "difficulty": "Easy",
      "high_freq": false,
      "follow_ups": ["找環起點？", "環的長度？"],
      "red_flags": ["快指標步進邏輯錯誤", "沒有處理空鏈表"],
      "bonus_points": ["Floyd's Cycle Detection", "數學證明理解"]
    },
    "08_Find_the_Duplicate_Number": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["不能修改陣列？", "O(1) 空間？"],
      "red_flags": ["連結方式錯誤 (nums[i] -> nums[nums[i]])", "環起點計算錯誤"],
      "bonus_points": ["Floyd's Cycle Detection 在陣列上的應用", "二分搜尋替代解法"]
    },
    "09_LRU_Cache": {
      "difficulty": "Medium",
      "high_freq": true,
      "follow_ups": ["LFU Cache?", "分佈式 LRU？"],
      "red_flags": ["雙向鏈表操作錯誤", "Hash Map 更新不同步"],
      "bonus_points": ["O(1) 時間複雜度", "清晰的資料結構設計"]
    },
    "10_Merge_k_Sorted_Lists": {
      "difficulty": "Hard",
      "high_freq": true,
      "follow_ups": ["外部排序？", "分布式排序？"],
      "red_flags": ["Priority Queue 比較器錯誤", "沒有處理空鏈表"],
      "bonus_points": ["Divide and Conquer vs Heap", "時間複雜度分析"]
    },
    "11_Reverse_Nodes_in_k_Group": {
      "difficulty": "Hard",
      "high_freq": false,
      "follow_ups": ["如果不足 K 個也反轉？", "遞迴版本？"],
      "red_flags": ["計數錯誤", "指標重連邏輯錯誤"],
      "bonus_points": ["清晰的指標操作", "原地操作 O(1) 空間"]
    }
  },
  "07_Trees": {
    "01_Invert_Binary_Tree": {
      "difficulty": "Easy",
      "high_freq": false,
      "follow_ups": ["迭代版本？", "N-ary Tree?"],
      "red_flags": ["只交換值而非子樹", "沒有遞迴處理子樹"],
      "bonus_points": ["遞迴和迭代都能寫", "時間空間複雜度分析"]
    },
    "02_Maximum_Depth_of_Binary_Tree": {
      "difficulty": "Easy",
      "high_freq": false,
      "follow_ups": ["Minimum Depth?", "N-ary Tree?"],
      "red_flags": ["沒有處理空節點", "深度計算差一"],
      "bonus_points": ["DFS 和 BFS 兩種解法", "尾遞迴優化討論"]
    },
    "03_Diameter_of_Binary_Tree": {
      "difficulty": "Easy",
      "high_freq": false,
      "follow_ups": ["路徑可以不經過 root 嗎？", "N-ary Tree?"],
      "red_flags": ["沒有理解直徑 = 左深度 + 右深度", "忘記更新全域最大值"],
      "bonus_points": ["Bottom-up DFS", "清晰的 DFS 返回值設計"]
    },
    "04_Balanced_Binary_Tree": {
      "difficulty": "Easy",
      "high_freq": false,
      "follow_ups": ["如何從不平衡樹轉為平衡？", "AVL Tree?"],
      "red_flags": ["每個節點重複計算高度", "沒有 early termination"],
      "bonus_points": ["O(n) 一趟遍歷", "返回 -1 表示不平衡的技巧"]
    },
    "05_Same_Tree": {
      "difficulty": "Easy",
      "high_freq": false,
      "follow_ups": ["Symmetric Tree?", "結構相同但值不同？"],
      "red_flags": ["沒有處理一邊為 null", "遞迴順序錯誤"],
      "bonus_points": ["簡潔的遞迴寫法", "BFS 迭代解法"]
    },
    "06_Subtree_of_Another_Tree": {
      "difficulty": "Easy",
      "high_freq": false,
      "follow_ups": ["如何優化時間複雜度？", "用序列化檢查？"],
      "red_flags": ["isSameTree 調用位置錯誤", "沒有從每個節點開始檢查"],
      "bonus_points": ["Merkle Hash 優化", "KMP 串匹配優化"]
    },
    "07_Lowest_Common_Ancestor_BST": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["普通二元樹的 LCA？", "有父指標的解法？"],
      "red_flags": ["沒有利用 BST 性質", "遞迴方向選擇錯誤"],
      "bonus_points": ["利用 BST 性質", "O(h) 迭代解法"]
    },
    "08_Binary_Tree_Level_Order_Traversal": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["Zigzag Level Order?", "Bottom-up Level Order?"],
      "red_flags": ["BFS 層次分離錯誤", "沒有先記錄層大小"],
      "bonus_points": ["DFS 也能實現", "時間空間複雜度分析"]
    },
    "09_Binary_Tree_Right_Side_View": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["Left Side View?", "多個方向？"],
      "red_flags": ["BFS 取錯節點", "DFS 順序錯誤"],
      "bonus_points": ["BFS 取每層最後一個", "DFS 先右後左"]
    },
    "10_Count_Good_Nodes": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如果是 N-ary Tree？", "返回所有 good nodes 的值？"],
      "red_flags": ["沒有正確傳遞路徑最大值", "初始 max 設置錯誤"],
      "bonus_points": ["清晰的 DFS 狀態傳遞", "Pre-order traversal 應用"]
    },
    "11_Validate_BST": {
      "difficulty": "Medium",
      "high_freq": true,
      "follow_ups": ["如何修復不合法的 BST？", "第 K 小元素？"],
      "red_flags": ["只比較父子關係", "沒有傳遞 min/max 範圍"],
      "bonus_points": ["傳遞範圍區間", "In-order traversal 解法"]
    },
    "12_Kth_Smallest_Element_BST": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["如果 BST 頻繁修改？", "第 K 大？"],
      "red_flags": ["In-order 順序錯誤", "沒有提前終止"],
      "bonus_points": ["迭代 In-order", "Augmented BST 概念"]
    },
    "13_Construct_Binary_Tree": {
      "difficulty": "Medium",
      "high_freq": false,
      "follow_ups": ["從 Postorder + Inorder?", "從 Preorder + Postorder?"],
      "red_flags": ["Index 計算錯誤", "沒有用 Hash Map 優化查找"],
      "bonus_points": ["使用 Hash Map 優化到 O(n)", "清晰的遞迴分割"]
    },
    "14_Binary_Tree_Maximum_Path_Sum": {
      "difficulty": "Hard",
      "high_freq": true,
      "follow_ups": ["路徑必須從 root 開始？", "返回具體路徑？"],
      "red_flags": ["混淆回傳值和全域更新", "沒有考慮負數節點"],
      "bonus_points": ["清晰區分 contribution vs path sum", "負數剪枝 max(0, ...)"]
    },
    "15_Serialize_Deserialize_Binary_Tree": {
      "difficulty": "Hard",
      "high_freq": false,
      "follow_ups": ["N-ary Tree?", "壓縮序列化？"],
      "red_flags": ["序列化格式不一致", "反序列化指標管理錯誤"],
      "bonus_points": ["BFS vs DFS 方案比較", "null 節點的處理"]
    }
  }
}
