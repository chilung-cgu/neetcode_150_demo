<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LRU Cache - D3 Á≤æÁ∑ªË¶ñË¶∫Âåñ</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 500px;
        }
        
        #viz-svg { width: 100%; height: 400px; }

        /* List Nodes */
        .node-rect { fill: #1e293b; stroke: #3b82f6; stroke-width: 2px; rx: 8; ry: 8; transition: fill 0.3s; }
        .node-rect.dummy { fill: #334155; stroke: #64748b; stroke-dasharray: 4; }
        .node-rect.new { stroke: #22c55e; fill: rgba(34, 197, 94, 0.1); }
        .node-rect.accessed { stroke: #fbbf24; fill: rgba(251, 191, 36, 0.1); }
        .node-rect.evicted { stroke: #ef4444; fill: rgba(239, 68, 68, 0.1); stroke-width: 1px; }

        .node-text { fill: white; font-family: monospace; font-size: 14px; text-anchor: middle; pointer-events: none; }
        .node-subtext { fill: #94a3b8; font-size: 10px; text-anchor: middle; }

        /* Links */
        .link { fill: none; stroke: #64748b; stroke-width: 2px; marker-end: url(#arrow); }
        .link.prev { stroke: #475569; stroke-width: 1px; stroke-dasharray: 2; marker-end: none; marker-start: url(#arrow-rev); }

        /* Map */
        .map-box { fill: rgba(30, 41, 59, 0.8); stroke: #a855f7; stroke-width: 1px; rx: 4; }
        .map-text { fill: #e2e8f0; font-size: 11px; font-family: monospace; }
        .map-link { fill: none; stroke: #a855f7; stroke-width: 1px; stroke-dasharray: 2; opacity: 0.5; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; }
        .input-row label { font-size: 0.85rem; color: #94a3b8; }
        .input-row input { padding: 6px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 60px; }
        .input-row button { padding: 6px 12px; border-radius: 6px; border: none; cursor: pointer; font-weight: bold; color: white; }
        .btn-put { background: #22c55e; }
        .btn-get { background: #fbbf24; color: #0f172a !important; }
        .btn-reset { background: #64748b; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; margin-top: 15px; width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">LRU Cache (Double Linked List + HashMap)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label>Capacity:</label>
                        <input type="number" id="capInput" value="3" min="1" max="5">
                        <button class="btn-reset" onclick="resetCache()">Reset</button>
                    </div>
                    <div class="input-row">
                        <label>Key:</label><input type="number" id="keyInput" value="1">
                        <label>Val:</label><input type="number" id="valInput" value="10">
                        <button class="btn-put" onclick="doPut()">Put</button>
                        <button class="btn-get" onclick="doGet()">Get</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <svg id="viz-svg">
                        <defs>
                            <marker id="arrow" markerWidth="8" markerHeight="8" refX="18" refY="4" orient="auto">
                                <path d="M0,0 L0,8 L8,4 z" fill="#64748b" />
                            </marker>
                            <marker id="arrow-rev" markerWidth="8" markerHeight="8" refX="0" refY="4" orient="auto">
                                <path d="M8,0 L8,8 L0,4 z" fill="#475569" />
                            </marker>
                        </defs>
                        <g id="map-group" transform="translate(30, 30)"></g>
                        <g id="list-group" transform="translate(50, 150)"></g>
                    </svg>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'class LRUCache {', id: 0 },
            { line: '    void put(key, val) {', id: 1 },
            { line: '        if (map.count(key)) remove(map[key]);', id: 2 },
            { line: '        map[key] = new Node(key, val);', id: 3 },
            { line: '        insertAtMRU(map[key]);', id: 4 },
            { line: '        if (map.size() > cap) {', id: 5 },
            { line: '            // Remove LRU', id: 6 },
            { line: '            lru = head->next;', id: 7 },
            { line: '            remove(lru); map.erase(lru->key);', id: 8 },
            { line: '        }', id: 9 },
            { line: '    }', id: 10 },
            { line: '    int get(key) {', id: 11 },
            { line: '        if (!map.count(key)) return -1;', id: 12 },
            { line: '        node = map[key];', id: 13 },
            { line: '        remove(node); insertAtMRU(node);', id: 14 },
            { line: '        return node->val;', id: 15 },
            { line: '    }', id: 16 }
        ];

        let viz;
        let cacheObj = {
            cap: 3,
            head: {id:'head', type:'dummy'},
            tail: {id:'tail', type:'dummy'},
            map: {}, // key -> node
            size: 0
        };
        // Setup links
        cacheObj.head.next = cacheObj.tail;
        cacheObj.tail.prev = cacheObj.head;

        function cloneState() {
            // Flatten list to array for easy serialization
            const nodes = [];
            let curr = cacheObj.head;
            while(curr) {
                // Circular ref fix? No, just linear traversal
                // Store key properties
                nodes.push({
                    id: curr.id,
                    key: curr.key,
                    val: curr.val,
                    type: curr.type,
                    state: curr.state // for visual effects
                });
                curr = curr.next;
            }
            return {
                cap: cacheObj.cap,
                nodes: nodes, // Ordered List state
                mapKeys: Object.keys(cacheObj.map).map(k=>parseInt(k)), // Just keys for map viz
                msg: "",
                highlightLines: []
            };
        }

        function createStep(msg, hl, explanation=null) {
            const state = cloneState();
            state.msg = msg;
            state.highlightLines = hl;
            state.explanation = explanation;
            return state;
        }

        // Algo Logic simulation that returns steps
        // BUT here we have interactive input.
        // We will run the logic on global `cacheObj` and record steps.
        // Then play steps.
        
        function runOp(op, key, val) {
            const steps = [];
            
            // Initial state snapshot
            steps.push(createStep(`${op.toUpperCase()} ${key}`, [], {
                title: `${op.toUpperCase()} Êìç‰Ωú`,
                text: `Ê∫ñÂÇôÂ∞ç Key ${key} Âü∑Ë°å ${op.toUpperCase()} Êìç‰Ωú„ÄÇ`,
                formula: `op = ${op}, key = ${key}`
            }));

            if (op === 'get') {
                if (key in cacheObj.map) {
                    const node = cacheObj.map[key];
                    node.state = 'accessed';
                    steps.push(createStep(`Key ${key} found! Move to MRU`, [12, 13], {
                        title: 'Âø´ÂèñÂëΩ‰∏≠ (Cache Hit)',
                        text: `Key ${key} Â≠òÂú®Êñº Map ‰∏≠„ÄÇÂèñÂæóÂ∞çÊáâÁöÑ Node„ÄÇ`,
                        formula: `map.count(${key}) == true`
                    }));
                    
                    // Remove
                    removeNode(node);
                    insertMRU(node);
                    
                    steps.push(createStep(`Moved ${key} to MRU. Return ${node.val}`, [14, 15], {
                        title: 'ÁßªÂãïÂà∞ MRU',
                        text: `ÁÇ∫‰∫ÜÊ®ôË®òÊúÄËøë‰ΩøÁî®ÔºåÂ∞á Node ÂæûÁï∂Ââç‰ΩçÁΩÆÁßªÈô§Ôºå‰∏¶ÊèíÂÖ•Âà∞ Tail ‰πãÂâç (MRU)„ÄÇ`,
                        formula: 'remove(node); insertAtMRU(node)'
                    }));
                    node.state = null; // Clear state
                } else {
                    steps.push(createStep(`Key ${key} not in cache. Return -1`, [12], {
                        title: 'Âø´ÂèñÊú™ÂëΩ‰∏≠ (Cache Miss)',
                        text: `Key ${key} ‰∏çÂú® Map ‰∏≠ÔºåËøîÂõû -1„ÄÇ`,
                        formula: `map.count(${key}) == false`
                    }));
                }
            } else if (op === 'put') {
                if (key in cacheObj.map) {
                    const node = cacheObj.map[key];
                    steps.push(createStep(`Key ${key} Â∑≤Â≠òÂú®. Êõ¥Êñ∞‰∏¶ÁßªÂãï`, [2], {
                        title: 'Êõ¥Êñ∞ÁèæÊúâ Key',
                        text: `Key ${key} Â∑≤Â≠òÂú®„ÄÇÈúÄË¶ÅÊõ¥Êñ∞ÂÄº‰∏¶Â∞áÂÖ∂Ê®ôË®òÁÇ∫ÊúÄËøë‰ΩøÁî®„ÄÇ`,
                        formula: `map.count(${key}) == true`
                    }));
                    removeNode(node);
                    node.val = val;
                    node.state = 'new';
                    insertMRU(node);
                    steps.push(createStep(`Updated ${key}:${val} at MRU`, [3, 4], {
                        title: 'ÁßªËá≥ MRU ‰∏¶Êõ¥Êñ∞',
                        text: `Â∞á Node ÁßªËá≥ Tail ÂâçÁ´ØÔºåÊõ¥Êñ∞ÂÄºÁÇ∫ ${val}„ÄÇ`,
                        formula: `node->val = ${val}; moveToMRU(node)`
                    }));
                    node.state = null;
                } else {
                    // New
                    const node = { id: 'node-'+key, key: key, val: val, type: 'node', state: 'new' };
                    cacheObj.map[key] = node;
                    cacheObj.size++;
                    insertMRU(node);
                    steps.push(createStep(`Inserted ${key}:${val} at MRU`, [3, 4], {
                        title: 'ÊèíÂÖ•Êñ∞ÁØÄÈªû',
                        text: `Âª∫Á´ãÊñ∞ÁØÄÈªû [${key}:${val}] ‰∏¶ÊèíÂÖ•Âà∞ MRU ‰ΩçÁΩÆ„ÄÇMap Á¥ÄÈåÑ key ÊåáÂêëÊ≠§ÁØÄÈªû„ÄÇ`,
                        formula: `map[${key}] = newNode; insertAtMRU(newNode)`
                    }));
                    node.state = null;

                    if (cacheObj.size > cacheObj.cap) {
                        const lru = cacheObj.head.next;
                        lru.state = 'evicted'; // visual
                        steps.push(createStep(`Capacity Full! Evicting LRU (Key ${lru.key})`, [5, 6, 7], {
                            title: 'ÂÆπÈáèÂ∑≤ÊªøÔºÅ',
                            text: `ÁõÆÂâçÂ§ßÂ∞è (${cacheObj.size}) Ë∂ÖÈÅéÂÆπÈáè (${cacheObj.cap})„ÄÇÈúÄË¶ÅÁßªÈô§ÊúÄ‰πÖÊú™‰ΩøÁî®ÁöÑÁØÄÈªû (LRU)„ÄÇ<br>LRU ‰ΩçÊñº Head->next„ÄÇ`,
                            formula: `size > cap`
                        }));
                        
                        removeNode(lru);
                        delete cacheObj.map[lru.key];
                        cacheObj.size--;
                        
                        steps.push(createStep(`Evicted ${lru.key}. Size now ${cacheObj.size}`, [8], {
                            title: 'ÁßªÈô§ LRU',
                            text: `ÁßªÈô§ÁØÄÈªû ${lru.key} ‰∏¶Âæû Map ‰∏≠Âà™Èô§Á¥ÄÈåÑ„ÄÇ`,
                            formula: `remove(lru); map.erase(${lru.key})`
                        }));
                    }
                }
            }
            
            // Final idle state
            steps.push(createStep("Ready", [], {
                title: 'Êìç‰ΩúÂÆåÊàê',
                text: 'Á≠âÂæÖ‰∏ã‰∏ÄÂÄãÊåá‰ª§„ÄÇ',
                formula: 'Ready'
            }));
            
            viz.setSteps(steps);
        }

        function removeNode(node) {
            const p = node.prev;
            const n = node.next;
            p.next = n;
            n.prev = p;
        }

        function insertMRU(node) {
            const p = cacheObj.tail.prev; // Current MRU
            const t = cacheObj.tail;
            
            p.next = node;
            node.prev = p;
            node.next = t;
            t.prev = node;
        }

        // Viz
        const svg = d3.select("#viz-svg");
        const gList = d3.select("#list-group");
        const gMap = d3.select("#map-group");

        // Add Label
        gList.append("text").attr("x", 0).attr("y", -30).text("Double Linked List (LRU ‚Üî MRU)").attr("fill", "#94a3b8").attr("class", "node-subtext");

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;

            // Render List Nodes
            // Layout: Linear horizontal. Head left, Tail right.
            const nodes = step.nodes;
            const NODE_W = 60, NODE_H = 40, GAP = 40;
            
            nodes.forEach((n, i) => {
                n.x = i * (NODE_W + GAP);
                n.y = 0;
            });

            // SVG Updates
            const nodeSel = gList.selectAll(".node-g").data(nodes, d => d.id);
            const nEnter = nodeSel.enter().append("g").attr("class", "node-g");
            
            nEnter.append("rect").attr("width", NODE_W).attr("height", NODE_H)
                .attr("x", -NODE_W/2).attr("y", -NODE_H/2)
                .attr("class", "node-rect");
                
            nEnter.append("text").attr("class", "node-text").attr("dy", 5);
            nEnter.append("text").attr("class", "node-subtext").attr("dy", -NODE_H/2 - 5); // Label (Head/Tail)

            const nUpdate = nodeSel.merge(nEnter).transition().duration(300)
                .attr("transform", d => `translate(${d.x}, 0)`);
                
            nUpdate.select("rect").attr("class", d => {
                let c = "node-rect";
                if(d.type === 'dummy') c+= " dummy";
                if(d.state) c+= " " + d.state;
                return c;
            });
            
            nUpdate.select(".node-text").text(d => d.type==='dummy' ? d.id.toUpperCase() : `K:${d.key}`);
            
            // Links
            const links = [];
            for(let i=0; i<nodes.length-1; i++) {
                links.push({s: nodes[i], t: nodes[i+1]});
            }
            
            const linkSel = gList.selectAll(".link").data(links, d => d.s.id+"-"+d.t.id);
            linkSel.enter().append("path").attr("class", "link")
                .merge(linkSel)
                .transition().duration(300)
                .attr("d", d => {
                    const sx = d.s.x + NODE_W/2;
                    const tx = d.t.x - NODE_W/2 - 5;
                    return `M ${sx},0 L ${tx},0`;
                });
            linkSel.exit().remove();

            // Map
            // Simple row of keys
            const mapData = step.mapKeys.map((k, i) => ({key: k, i}));
            const mSel = gMap.selectAll(".map-g").data(mapData, d => d.key);
            const mEnter = mSel.enter().append("g").attr("class", "map-g");
            mEnter.append("rect").attr("width", 50).attr("height", 25).attr("class", "map-box");
            mEnter.append("text").attr("class", "map-text").attr("x", 25).attr("y", 17).attr("text-anchor", "middle");
            
            const mUpdate = mSel.merge(mEnter).attr("transform", (d) => `translate(${d.i * 60}, 0)`);
            mUpdate.select("text").text(d => `K:${d.key}`);
            
            mSel.exit().remove();
            
            // Map Links (Curved to list nodes)
            // Need to find node position for key
            // This is tricky as 'nodes' in step are linear.
            // visual connections.
            const mapLinks = [];
            step.mapKeys.forEach((k, i) => {
                const targetNode = nodes.find(n => n.key === k && n.type === 'node');
                if(targetNode) {
                    mapLinks.push({
                        kx: i * 60 + 25, ky: 25, // Map box bottom center
                        nx: targetNode.x, ny: 130 // List node top (relative to map group?)
                        // List group is at y=150. Map group y=30. Diff = 120.
                        // List node y=0 inside group.
                        // Target Y relative to Map group is 120 + targetNode.y - NODE_H/2
                    });
                }
            });
            
            const mlSel = gMap.selectAll(".map-link").data(mapLinks);
            mlSel.enter().append("path").attr("class", "map-link")
                .merge(mlSel)
                .transition().duration(300)
                .attr("d", d => `M ${d.kx},${d.ky} L ${d.nx},100`); // Simple straight line to expected list Y
            mlSel.exit().remove();
        }

        function resetCache() {
            cacheObj.cap = parseInt(document.getElementById('capInput').value);
            cacheObj.head.next = cacheObj.tail;
            cacheObj.tail.prev = cacheObj.head;
            cacheObj.map = {};
            cacheObj.size = 0;
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps([createStep("Reset", [], {title:'ÈáçÁΩÆ', text:'Â∑≤Ê∏ÖÁ©∫Âø´Âèñ', formula:'size=0'})]);
        }

        function doPut() {
            const k = parseInt(document.getElementById('keyInput').value);
            const v = parseInt(document.getElementById('valInput').value);
            runOp('put', k, v);
        }
        
        function doGet() {
            const k = parseInt(document.getElementById('keyInput').value);
            runOp('get', k, 0);
        }

        window.addEventListener('load', () => {
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            resetCache();
        });
    </script>
</body>
</html>
