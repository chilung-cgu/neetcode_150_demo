<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LRU Cache - D3 Dynamic Viz</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            min-height: 500px;
        }

        /* SVG */
        .stage-viewport {
            width: 100%; height: 400px;
            background: rgba(30, 41, 59, 0.4);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(148, 163, 184, 0.2);
            position: relative;
        }
        #viz-svg { width: 100%; height: 100%; }

        /* Nodes */
        .node-rect { fill: #1e293b; stroke: #3b82f6; stroke-width: 2px; rx: 8; ry: 8; transition: fill 0.3s; }
        .node-rect.dummy { fill: #0f172a; stroke: #64748b; stroke-dasharray: 4; }
        .node-rect.active { stroke: #fbbf24; stroke-width: 3px; filter: drop-shadow(0 0 5px #fbbf24); } /* Accessed */
        .node-rect.new { stroke: #22c55e; fill: rgba(34, 197, 94, 0.1); } /* New */
        .node-rect.evicted { stroke: #ef4444; opacity: 0.3; } /* Evicted */

        .node-text { fill: white; font-family: monospace; font-size: 14px; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        .node-sub { fill: #94a3b8; font-size: 10px; text-anchor: middle; }

        /* Links */
        .link-path { fill: none; stroke: #64748b; stroke-width: 2px; marker-end: url(#arrow); opacity: 0.6; transition: all 0.5s; }
        .link-path.prev { stroke: #475569; stroke-width: 1px; stroke-dasharray: 3; marker-end: none; marker-start: url(#arrow-rev); }

        /* Map */
        .map-item { transition: transform 0.5s; }
        .map-rect { fill: rgba(30, 41, 59, 0.8); stroke: #a855f7; stroke-width: 1px; rx: 4; }
        .map-text { fill: #e2e8f0; font-size: 12px; font-family: monospace; }
        .map-link { fill: none; stroke: #a855f7; stroke-width: 1px; stroke-dasharray: 2; opacity: 0.4; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: start; justify-content: center; }
        input[type=number] { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 60px; }
        button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; font-weight: 600; height: 40px; }
        .btn-put { background: #22c55e; }
        .btn-get { background: #f59e0b; color: #0f172a; }
        .btn-reset { background: #64748b; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; width: 100%; box-sizing: border-box; }
        
        .legend { display: flex; gap: 15px; font-size: 0.8rem; color: #cbd5e1; margin-bottom: 5px; justify-content: center; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">LRU Cache</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <div>
                            <label style="font-size:0.8rem; color:#94a3b8;">Cap:</label>
                            <input type="number" id="capInput" value="3" min="1" max="5">
                            <button class="btn-reset" onclick="initCache()">Reset</button>
                        </div>
                        <div style="width:10px;"></div>
                        <div>
                            <label style="font-size:0.8rem; color:#94a3b8;">Key:</label>
                            <input type="number" id="keyInput" value="1">
                        </div>
                        <div>
                            <label style="font-size:0.8rem; color:#94a3b8;">Val:</label>
                            <input type="number" id="valInput" value="10">
                        </div>
                        <div style="display:flex; gap:5px;">
                            <button class="btn-put" onclick="performOp('put')">Put</button>
                            <button class="btn-get" onclick="performOp('get')">Get</button>
                        </div>
                    </div>
                </div>

                <div class="visualization-area">
                    <div class="legend">
                       <div class="legend-item"><div class="legend-color" style="background:#0f172a; border:1px dashed #64748b"></div>Dummy (LRU/MRU)</div>
                       <div class="legend-item"><div class="legend-color" style="background:#1e293b; border:1px solid #3b82f6"></div>Node</div>
                       <div class="legend-item"><div class="legend-color" style="background:rgba(30,41,59,0.8); border:1px solid #a855f7"></div>Map Entry</div>
                    </div>
                    
                    <div class="stage-viewport">
                        <svg id="viz-svg">
                            <defs>
                                <marker id="arrow" viewBox="0 -5 10 10" refX="42" refY="0" markerWidth="6" markerHeight="6" orient="auto">
                                    <path d="M0,-5L10,0L0,5" fill="#64748b"/>
                                </marker>
                                <marker id="arrow-rev" viewBox="0 -5 10 10" refX="-32" refY="0" markerWidth="6" markerHeight="6" orient="auto">
                                    <path d="M10,-5L0,0L10,5" fill="#475569"/>
                                </marker>
                            </defs>
                            <g id="map-group"></g>
                            <g id="list-group"></g>
                        </svg>
                    </div>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>
                
                 <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">2x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card logic-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'class LRUCache {', id: 0 },
            { line: '    Node *left, *right;', id: 1 },
            { line: '    unordered_map<int, Node*> map;', id: 2 },
            { line: '    int get(int key) {', id: 3 },
            { line: '        if (exists) { remove(node); insert(node); return val; }', id: 4 },
            { line: '        return -1;', id: 5 },
            { line: '    }', id: 6 },
            { line: '    void put(int key, int value) {', id: 7 },
            { line: '        if (exists) remove(node);', id: 8 },
            { line: '        map[key] = new Node(k, v); insert(node);', id: 9 },
            { line: '        if (size > cap) { remove(left->next); map.erase(k); }', id: 10 },
            { line: '    }', id: 11 },
            { line: '};', id: 12 }
        ];

        let viz;
        let capacity = 3;
        let cacheNodes = []; 
        let cacheMap = {}; 
        let nextId = 1;
        const LEFT_ID = 'L';
        const RIGHT_ID = 'R';
        
        function initCache() {
            capacity = parseInt(document.getElementById('capInput').value);
            cacheNodes = [
                {id: LEFT_ID, k: 'L', v: 'LRU', type: 'dummy', prev: null, next: RIGHT_ID},
                {id: RIGHT_ID, k: 'R', v: 'MRU', type: 'dummy', prev: LEFT_ID, next: null}
            ];
            cacheMap = {}; 
            nextId = 1;
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps([{
                nodes: JSON.parse(JSON.stringify(cacheNodes)),
                map: {},
                msg: `Init LRUCache(Cap=\${capacity}). Left=LRU, Right=MRU.`,
                highlightLines: [0, 1, 2],
                explanation: { title: "ÂàùÂßãÂåñ", text: "Âª∫Á´ã Dummy ÁØÄÈªûÂíåÁ©∫ Map„ÄÇ", formula: "size=0" }
            }]);
        }
        
        function performOp(type) {
            const key = parseInt(document.getElementById('keyInput').value);
            const val = parseInt(document.getElementById('valInput').value);
            const steps = generateOpSteps(type, key, val);
            viz.appendSteps(steps); 
        }

        function generateOpSteps(type, k, v) {
            const steps = [];
            const snap = (msg, lines, expl) => ({
                nodes: JSON.parse(JSON.stringify(cacheNodes)),
                map: JSON.parse(JSON.stringify(cacheMap)),
                activeKey: k,
                opType: type,
                msg,
                highlightLines: lines,
                explanation: expl
            });

            if (type === 'get') {
                steps.push(snap(`GET(\${k})`, [3], { title: "GET", text: `ËÆÄÂèñ Key=\${k}„ÄÇ`, formula: `get(\${k})` }));
                if (k in cacheMap) {
                    const nodeId = cacheMap[k];
                    removeNode(nodeId);
                    insertNode(nodeId);
                    steps.push(snap(`Hit: Move \${k} to MRU`, [4], { title: "ÂëΩ‰∏≠", text: "Ëàá Move to Front„ÄÇ", formula: "Hit" }));
                } else {
                    steps.push(snap(`Miss: Key \${k} not found`, [5], { title: "Êú™ÂëΩ‰∏≠", text: "ËøîÂõû -1„ÄÇ", formula: "Miss" }));
                }
            } else if (type === 'put') {
                steps.push(snap(`PUT(\${k}, \${v})`, [7], { title: "PUT", text: `ÂØ´ÂÖ• Key=\${k}„ÄÇ`, formula: `put(\${k}, \${v})` }));
                if (k in cacheMap) {
                    const nodeId = cacheMap[k];
                    removeNode(nodeId);
                    const node = cacheNodes.find(n => n.id === nodeId);
                    node.v = v;
                    insertNode(nodeId);
                    steps.push(snap(`Update \${k}, Move to MRU`, [8, 9], { title: "Êõ¥Êñ∞", text: "Êõ¥Êñ∞ÂÄº‰∏¶ÁßªËá≥ MRU„ÄÇ", formula: "Update" }));
                } else {
                    const newNodeId = ++nextId;
                    const newNode = {id: newNodeId, k: k, v: v, type: 'node'};
                    cacheNodes.push(newNode); 
                    cacheMap[k] = newNodeId;
                    insertNode(newNodeId);
                    steps.push(snap(`Insert [\${k}:\${v}] at MRU`, [9], { title: "ÊèíÂÖ•", text: "ÊèíÂÖ•Êñ∞ÁØÄÈªû„ÄÇ", formula: "Insert" }));
                    
                    if (Object.keys(cacheMap).length > capacity) {
                        const lNode = cacheNodes.find(n => n.id === LEFT_ID);
                        const lruId = lNode.next;
                        const lruNode = cacheNodes.find(n => n.id === lruId);
                        removeNode(lruId);
                        delete cacheMap[lruNode.k];
                        steps.push(snap(`Evict LRU (\${lruNode.k})`, [10], { title: "Ê∑òÊ±∞", text: `ÂÆπÈáèÊªøÔºåÁßªÈô§ LRU ÁØÄÈªû„ÄÇ`, formula: "Evict" }));
                    }
                }
            }
            return steps;
        }
        
        function removeNode(id) {
            const node = cacheNodes.find(n => n.id === id);
            const p = cacheNodes.find(n => n.id === node.prev);
            const n = cacheNodes.find(n => n.id === node.next);
            p.next = n.id; n.prev = p.id;
            node.prev = null; node.next = null;
        }
        
        function insertNode(id) {
            const node = cacheNodes.find(n => n.id === id);
            const right = cacheNodes.find(n => n.id === RIGHT_ID);
            const prev = cacheNodes.find(n => n.id === right.prev);
            prev.next = id; right.prev = id;
            node.prev = prev.id; node.next = right.id;
        }

        const svg = d3.select("#viz-svg");
        const width = 600; const height = 400;
        svg.attr("viewBox", `0 0 \${width} \${height}`);

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;
            if (step.explanation) {
                document.getElementById('explanation').innerHTML = `
                    <div class="expl-title">\${step.explanation.title}</div>
                    <div class="expl-text">\${step.explanation.text}</div>
                    <div class="expl-formula">\${step.explanation.formula}</div>
                `;
            }

            const nodes = step.nodes;
            const map = step.map || {};
            
            const orderedIds = [];
            let curr = LEFT_ID;
            let safety = 0;
            while(curr && safety < 100) {
                orderedIds.push(curr);
                const n = nodes.find(x => x.id === curr);
                curr = n ? n.next : null;
                safety++;
            }
            
            const renderNodes = nodes.filter(n => orderedIds.includes(n.id));
            const startX = 50; const startY = 250; const spacing = 80;
            renderNodes.forEach((n, i) => {
                n.x = startX + i * spacing; n.y = startY;
            });
            
            // Draw
            const mapG = svg.select("#map-group"); // ensure group exists
            if (mapG.empty()) svg.append("g").attr("id", "map-group");
            
            // Map keys
            const mapKeys = Object.keys(map);
            const mapSel = mapG.selectAll(".map-item").data(mapKeys, k => k);
            const mapEnter = mapSel.enter().append("g").attr("class", "map-item");
            mapEnter.append("rect").attr("class", "map-rect").attr("width", 50).attr("height", 30);
            mapEnter.append("text").attr("class", "map-text").attr("x", 25).attr("y", 20).attr("text-anchor", "middle");
            
            mapSel.merge(mapEnter).transition().duration(500)
                .attr("transform", (k, i) => `translate(\${50 + i*80}, 50)`);
                
            mapSel.merge(mapEnter).select("text").text(k => `K:\${k}`);
            mapSel.exit().remove();
            
            // Map Links
            const mlSel = svg.selectAll(".map-link").data(mapKeys);
            mlSel.enter().append("path").attr("class", "map-link")
                 .merge(mlSel).transition().duration(500)
                 .attr("d", (k, i) => {
                     const nid = map[k];
                     const node = renderNodes.find(n => n.id === nid);
                     if (!node) return "";
                     const mx = 50 + i*80 + 25; const my = 80;
                     return `M\${mx},\${my} C\${mx},\${(my+node.y)/2} \${node.x},\${(my+node.y)/2} \${node.x},\${node.y-10}`;
                 });
            mlSel.exit().remove();

            // List Nodes
            let listG = svg.select("#list-group");
            if (listG.empty()) listG = svg.append("g").attr("id", "list-group");

            const nodeSel = listG.selectAll(".node-g").data(renderNodes, d => d.id);
            const nodeEnter = nodeSel.enter().append("g").attr("class", "node-g");
            nodeEnter.append("rect").attr("class", "node-rect").attr("width", 50).attr("height", 40).attr("x", -25).attr("y", -20);
            nodeEnter.append("text").attr("class", "node-text").attr("dy", 0);
            nodeEnter.append("text").attr("class", "node-sub").attr("dy", 15);
            
            const nodeMerge = nodeSel.merge(nodeEnter).transition().duration(500)
                 .attr("transform", d => `translate(\${d.x}, \${d.y})`);
                 
            nodeMerge.select(".node-rect").attr("class", d => {
                let c = "node-rect";
                if(d.type === 'dummy') c += " dummy";
                if(step.activeKey == d.k) c += " active";
                return c;
            })
            nodeMerge.select(".node-text").text(d => d.type==='dummy' ? d.v : `\${d.k}:\${d.v}`);
            
            nodeSel.exit().remove();
            
            // Links
            const links = [];
            renderNodes.forEach(n => {
                if(n.next) {
                   const t = renderNodes.find(x => x.id === n.next);
                   if (t) links.push({s:n, t:t, id: `next-\${n.id}-\${t.id}`, type:'next'});
                }
                if(n.prev) {
                   const t = renderNodes.find(x => x.id === n.prev);
                   if (t) links.push({s:n, t:t, id: `prev-\${n.id}-\${t.id}`, type:'prev'});
                }
            });
            
            // Only draw Next links for clarity? Or both?
            // Drawing both makes it cluttered. Let's draw ONE double arrow or just next line.
            // Simplified: Draw Next arrows. Prev is implied.
            const simpleLinks = links.filter(l => l.type === 'next');
            
            const linkSel = listG.selectAll(".link-path").data(simpleLinks, d => d.id);
            const linkEnter = linkSel.enter().append("path").attr("class", "link-path");
            linkSel.merge(linkEnter).transition().duration(500)
                .attr("d", d => `M\${d.s.x+25},\${d.s.y} L\${d.t.x-33},\${d.t.y}`); 
            linkSel.exit().remove();
        }

        window.addEventListener('load', initCache);
    </script>
</body>
</html>
