<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merge Two Sorted Lists - D3 Dynamic Viz</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            min-height: 480px;
        }

        /* SVG */
        .stage-viewport {
            width: 100%; height: 350px;
            background: rgba(30, 41, 59, 0.4);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(148, 163, 184, 0.2);
            position: relative;
        }
        #viz-svg { width: 100%; height: 100%; }

        /* Nodes */
        .node-circle { stroke-width: 2px; transition: fill 0.3s; r: 20px; }
        .node-text { fill: white; font-family: monospace; font-size: 14px; font-weight: bold; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        
        .node-l1 { fill: #3b82f6; stroke: #60a5fa; }
        .node-l2 { fill: #a855f7; stroke: #c084fc; }
        .node-dummy { fill: #64748b; stroke: #94a3b8; stroke-dasharray: 4; }
        
        .node-active { stroke: #fbbf24; stroke-width: 4px; filter: drop-shadow(0 0 5px #fbbf24); }
        .node-merged { fill: #22c55e; stroke: #4ade80; } /* After merge */

        /* Links */
        .link-path { fill: none; stroke: #64748b; stroke-width: 2px; marker-end: url(#arrow); transition: all 0.5s; opacity: 0.6; }
        .link-path.merged { stroke: #22c55e; marker-end: url(#arrow-success); opacity: 1; stroke-width: 3px; }

        /* Pointers */
        .ptr-label { font-size: 12px; font-weight: bold; text-anchor: middle; fill: white; font-family: monospace; }
        .ptr-arrow { stroke: white; stroke-width: 2px; fill: none; marker-end: url(#arrow-white); }
        
        /* Row Labels */
        .row-label { font-size: 12px; fill: #94a3b8; text-anchor: start; font-weight: bold; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: start; justify-content: center; }
        input[type=text] { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 120px; }
        button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; font-weight: 600; height: 40px; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; width: 100%; box-sizing: border-box; }
        
        .legend { display: flex; gap: 15px; font-size: 0.8rem; color: #cbd5e1; margin-bottom: 5px; justify-content: center; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Merge Two Sorted Lists</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <div>
                            <label style="font-size:0.8rem; color:#94a3b8;">List 1:</label>
                            <input type="text" id="l1Input" value="1, 2, 4">
                        </div>
                        <div>
                            <label style="font-size:0.8rem; color:#94a3b8;">List 2:</label>
                            <input type="text" id="l2Input" value="1, 3, 4">
                        </div>
                        <div style="display:flex; flex-direction:column; gap:5px;">
                            <button onclick="runVisualizer()">Merge</button>
                        </div>
                    </div>
                </div>

                <div class="visualization-area">
                    <div class="legend">
                       <div class="legend-item"><div class="legend-color" style="background:#3b82f6"></div>List 1</div>
                       <div class="legend-item"><div class="legend-color" style="background:#a855f7"></div>List 2</div>
                       <div class="legend-item"><div class="legend-color" style="background:#22c55e"></div>Merged</div>
                       <div class="legend-item"><div class="legend-color" style="background:#fbbf24"></div>Scanning</div>
                    </div>
                    
                    <div class="stage-viewport">
                        <svg id="viz-svg">
                            <defs>
                                <marker id="arrow" viewBox="0 -5 10 10" refX="25" refY="0" markerWidth="6" markerHeight="6" orient="auto">
                                    <path d="M0,-5L10,0L0,5" fill="#64748b"/>
                                </marker>
                                <marker id="arrow-success" viewBox="0 -5 10 10" refX="25" refY="0" markerWidth="6" markerHeight="6" orient="auto">
                                    <path d="M0,-5L10,0L0,5" fill="#22c55e"/>
                                </marker>
                                <marker id="arrow-white" viewBox="0 -5 10 10" refX="10" refY="0" markerWidth="6" markerHeight="6" orient="auto">
                                    <path d="M0,-5L10,0L0,5" fill="white"/>
                                </marker>
                            </defs>
                        </svg>
                    </div>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn" onclick="runVisualizer()">‚Üª ÈáçÁΩÆ</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">2x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card logic-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {', id: 0 },
            { line: '    ListNode dummy(0);', id: 1 },
            { line: '    ListNode* tail = &dummy;', id: 2 },
            { line: '    while (l1 && l2) {', id: 3 },
            { line: '        if (l1->val < l2->val) {', id: 4 },
            { line: '            tail->next = l1;', id: 5 },
            { line: '            l1 = l1->next;', id: 6 },
            { line: '        } else {', id: 7 },
            { line: '            tail->next = l2;', id: 8 },
            { line: '            l2 = l2->next;', id: 9 },
            { line: '        }', id: 10 },
            { line: '        tail = tail->next;', id: 11 },
            { line: '    }', id: 12 },
            { line: '    if (l1) tail->next = l1;', id: 13 },
            { line: '    if (l2) tail->next = l2;', id: 14 },
            { line: '    return dummy.next;', id: 15 },
            { line: '}', id: 16 }
        ];

        let viz;

        function simulate(arr1, arr2) {
            const steps = [];
            
            // Build Nodes
            // We need unique IDs across lists. 
            // Lets prefix: l1_0, l1_1... l2_0...
            
            const nodes = [];
            const l1Nodes = arr1.map((v, i) => ({id: `l1_${i}`, val: v, type: 'l1', next: (i<arr1.length-1 ? `l1_${i+1}` : null), row: 0, col: i}));
            const l2Nodes = arr2.map((v, i) => ({id: `l2_${i}`, val: v, type: 'l2', next: (i<arr2.length-1 ? `l2_${i+1}` : null), row: 1, col: i}));
            
            // Add dummy node
            const dummy = {id: 'dummy', val: 'D', type: 'dummy', next: null, row: 2, col: -1}; // Merged row starts at 2
            
            nodes.push(dummy, ...l1Nodes, ...l2Nodes);
            
            let l1 = l1Nodes.length > 0 ? l1Nodes[0].id : null;
            let l2 = l2Nodes.length > 0 ? l2Nodes[0].id : null;
            let tail = dummy.id;
            
            // Helper to take snapshot
            const snap = (nodes, pL1, pL2, pTail) => {
                return {
                    nodes: JSON.parse(JSON.stringify(nodes)),
                    pointers: { l1: pL1, l2: pL2, tail: pTail }
                };
            };

            steps.push({
                ...snap(nodes, l1, l2, tail),
                msg: "Init Dummy Node. tail = &dummy",
                highlightLines: [0, 1, 2],
                explanation: {
                    title: "ÂàùÂßãÂåñ",
                    text: "Âª∫Á´ã Dummy ÁØÄÈªû‰ΩúÁÇ∫Âêà‰ΩµÈèàË°®ÁöÑÈ†≠„ÄÇtail ÊåáÈáùÂàùÂßãÊåáÂêë Dummy„ÄÇ",
                    formula: "tail = dummy"
                }
            });

            let mergedCount = 0;

            while (l1 && l2) {
                // Determine values
                const n1 = nodes.find(n => n.id === l1);
                const n2 = nodes.find(n => n.id === l2);
                
                steps.push({
                    ...snap(nodes, l1, l2, tail),
                    msg: `Compare l1(${n1.val}) vs l2(${n2.val})`,
                    highlightLines: [3, 4],
                    explanation: {
                        title: "ÊØîËºÉÁØÄÈªûÂÄº",
                        text: `ÊØîËºÉ l1 (${n1.val}) Âíå l2 (${n2.val}) ÁöÑÂ§ßÂ∞è„ÄÇ`,
                        formula: `${n1.val} < ${n2.val} ?`
                    }
                });

                let chosenId;
                if (n1.val < n2.val) {
                    chosenId = l1;
                    
                    // Logic: tail->next = l1
                    const tNode = nodes.find(n => n.id === tail);
                    tNode.next = l1;
                    
                    // Move chosen node to merged row (visual)
                    const cNode = nodes.find(n => n.id === l1);
                    cNode.row = 2; // merged row
                    cNode.col = mergedCount; 
                    cNode.type = 'merged';
                    mergedCount++;
                    l1 = cNode.next; // Advance l1 logic
                    
                    // Note: In visual, cNode.next physically still points to old L1 remainder.
                    // But conceptually l1 ptr moves.
                    
                    steps.push({
                        ...snap(nodes, l1, l2, tail),
                        msg: `l1 smaller. tail->next = l1 (${n1.val}). Advance l1.`,
                        highlightLines: [5, 6],
                        explanation: {
                            title: "ÈÄ£Êé•ËºÉÂ∞èÁØÄÈªû (L1)",
                            text: `L1 ÁöÑÂÄºËºÉÂ∞èÔºåÂ∞áÂÖ∂Êé•Âú® tail ÂæåÈù¢Ôºå‰∏¶Â∞á L1 ÊåáÈáùÂæåÁßª„ÄÇ`,
                            formula: "tail->next = l1; l1 = l1->next"
                        }
                    });
                } else {
                    chosenId = l2;
                    
                    const tNode = nodes.find(n => n.id === tail);
                    tNode.next = l2;
                    
                    const cNode = nodes.find(n => n.id === l2);
                    cNode.row = 2;
                    cNode.col = mergedCount;
                    cNode.type = 'merged';
                    mergedCount++;
                    l2 = cNode.next;
                    
                    steps.push({
                        ...snap(nodes, l1, l2, tail),
                        msg: `l2 smaller/equal. tail->next = l2 (${n2.val}). Advance l2.`,
                        highlightLines: [7, 8, 9],
                        explanation: {
                            title: "ÈÄ£Êé•ËºÉÂ∞èÁØÄÈªû (L2)",
                            text: `L2 ÁöÑÂÄºËºÉÂ∞èÊàñÁõ∏Á≠âÔºåÂ∞áÂÖ∂Êé•Âú® tail ÂæåÈù¢Ôºå‰∏¶Â∞á L2 ÊåáÈáùÂæåÁßª„ÄÇ`,
                            formula: "tail->next = l2; l2 = l2->next"
                        }
                    });
                }
                
                tail = chosenId;
                steps.push({
                    ...snap(nodes, l1, l2, tail),
                    msg: "Advance tail",
                    highlightLines: [11],
                    explanation: {
                        title: "ÁßªÂãï Tail",
                        text: "Tail ÊåáÈáùÁßªÂãïÂà∞ÂâõÂä†ÂÖ•ÁöÑÁØÄÈªû„ÄÇ",
                        formula: "tail = tail->next"
                    }
                });
            }
            
            // Remaining
            if (l1) {
                const tNode = nodes.find(n => n.id === tail);
                tNode.next = l1;
                
                // Move rest of l1 to merged row?
                // Visual polish: traverse rest and move them?
                // Or just link. Let's move them for visual consistency.
                let runner = l1;
                while(runner) {
                    const rNode = nodes.find(n => n.id === runner);
                    rNode.row = 2;
                    rNode.col = mergedCount++;
                    rNode.type = 'merged';
                    runner = rNode.next;
                }
                
                steps.push({
                    ...snap(nodes, null, l2, tail), // l1 effectively merged
                    msg: "Connect remaining L1 nodes.",
                    highlightLines: [13],
                    explanation: {
                        title: "ÈÄ£Êé•Ââ©È§ò L1",
                        text: "L1 ÈÇÑÊúâÂâ©È§òÁØÄÈªûÔºåÁõ¥Êé•ÂÖ®ÈÉ®Êé•Âú® tail ÂæåÈù¢„ÄÇ",
                        formula: "tail->next = l1"
                    }
                });
            } else if (l2) {
                const tNode = nodes.find(n => n.id === tail);
                tNode.next = l2;
                
                let runner = l2;
                while(runner) {
                    const rNode = nodes.find(n => n.id === runner);
                    rNode.row = 2;
                    rNode.col = mergedCount++;
                    rNode.type = 'merged';
                    runner = rNode.next;
                }
                
                steps.push({
                    ...snap(nodes, l1, null, tail),
                    msg: "Connect remaining L2 nodes.",
                    highlightLines: [14],
                    explanation: {
                        title: "ÈÄ£Êé•Ââ©È§ò L2",
                        text: "L2 ÈÇÑÊúâÂâ©È§òÁØÄÈªûÔºåÁõ¥Êé•ÂÖ®ÈÉ®Êé•Âú® tail ÂæåÈù¢„ÄÇ",
                        formula: "tail->next = l2"
                    }
                });
            }
            
            steps.push({
                ...snap(nodes, l1, l2, tail),
                final: true,
                msg: "Done. Return dummy.next",
                highlightLines: [15],
                explanation: {
                    title: "ÂÆåÊàê",
                    text: "Âêà‰ΩµÂÆåÊàêÔºåËøîÂõû Dummy ÁØÄÈªûÁöÑ‰∏ã‰∏ÄÂÄãÁØÄÈªû‰ΩúÁÇ∫Êñ∞ÈèàË°®ÁöÑÈ†≠„ÄÇ",
                    formula: "return dummy.next"
                }
            });

            return steps;
        }

        // --- Render ---
        const svg = d3.select("#viz-svg");
        const width = 600;
        const height = 400;
        svg.attr("viewBox", `0 0 ${width} ${height}`);

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;
            
            if (step.explanation) {
                document.getElementById('explanation').innerHTML = `
                    <div class="expl-title">${step.explanation.title}</div>
                    <div class="expl-text">${step.explanation.text}</div>
                    <div class="expl-formula">${step.explanation.formula}</div>
                `;
            }

            const nodes = step.nodes;
            const ptr = step.pointers;
            
            // Layout Rows
            // Row 0: y=100 (L1 origin)
            // Row 1: y=200 (L2 origin)
            // Row 2: y=300 (Merged)
            // But visually, simpler if Merged is middle?
            // Let's stick to Top/Bottom merging to Bottom or Middle?
            // Let's do: L1 at Y=100, L2 at Y=200. Merged moves nodes to Y=300.
            // X positioning based on 'col'.
            
            const nodeR = 20;
            const spacing = 70;
            const offsetX = 50;
            
            // Update node coords
            nodes.forEach(n => {
                n.targetX = offsetX + n.col * spacing + (n.type === 'dummy' ? 0 : spacing); // Dummy at start
                n.targetY = 100 + n.row * 80; 
                // Row mapping: 0->80, 1->160, 2->240?
                // n.row was 0(L1), 1(L2), 2(Merged)
                if (n.row === 0) n.targetY = 100;
                else if (n.row === 1) n.targetY = 180;
                else if (n.row === 2) n.targetY = 300;
            });
            
            // Draw Links first
            const links = [];
            nodes.forEach(n => {
                if (n.next) {
                    const target = nodes.find(tn => tn.id === n.next);
                    if (target) {
                        links.push({
                            s: {x: n.targetX, y: n.targetY},
                            t: {x: target.targetX, y: target.targetY},
                            id: `${n.id}-${target.id}`,
                            isMerged: n.type === 'merged' || n.type === 'dummy'
                        });
                    }
                }
            });
            
            const linkSel = svg.selectAll(".link-path").data(links, d => d.id);
            const linkEnter = linkSel.enter().append("path").attr("class", "link-path");
            
            linkSel.merge(linkEnter)
                .transition().duration(500)
                .attr("d", d => {
                    return `M${d.s.x+nodeR},${d.s.y} L${d.t.x-nodeR-5},${d.t.y}`;
                })
                .attr("class", d => d.isMerged ? "link-path merged" : "link-path");
            
            linkSel.exit().remove();

            // Draw Nodes
            const nodeSel = svg.selectAll(".node-g").data(nodes, d => d.id);
            const nodeEnter = nodeSel.enter().append("g").attr("class", "node-g");
            
            nodeEnter.append("circle").attr("class", "node-circle").attr("r", nodeR);
            nodeEnter.append("text").attr("class", "node-text").attr("dy", 1);
            
            const nodeMerge = nodeSel.merge(nodeEnter);
            nodeMerge.transition().duration(500)
                .attr("transform", d => `translate(${d.targetX}, ${d.targetY})`);
            
            nodeMerge.select("circle")
                .attr("class", d => {
                    let c = "node-circle";
                    if (d.type === 'l1') c += " node-l1";
                    else if (d.type === 'l2') c += " node-l2";
                    else if (d.type === 'dummy') c += " node-dummy";
                    else c += " node-merged";
                    
                    if (ptr.l1 === d.id || ptr.l2 === d.id) c += " node-active";
                    if (ptr.tail === d.id) c += " node-active"; // tail highlight separate?
                    return c;
                });
            
            nodeMerge.select("text").text(d => d.val);
            
            nodeSel.exit().remove();
            
            // Draw Pointers
            const pointers = [
                {id: ptr.l1, label: 'l1', yOff: -30},
                {id: ptr.l2, label: 'l2', yOff: -30},
                {id: ptr.tail, label: 'tail', yOff: 30}
            ].filter(p => p.id); // Filter nulls
            
            const ptrSel = svg.selectAll(".ptr-g").data(pointers, d => d.label);
            const ptrEnter = ptrSel.enter().append("g").attr("class", "ptr-g");
            
            ptrEnter.append("rect").attr("width", 40).attr("height", 20).attr("x", -20).attr("y", -10).attr("rx", 4).attr("fill", "#64748b");
            ptrEnter.append("text").attr("class", "ptr-label").attr("dy", 4);
            ptrEnter.append("path").attr("class", "ptr-arrow").attr("d", "M0,10 L0,20"); 
            
            const ptrMerge = ptrSel.merge(ptrEnter);
            ptrMerge.transition().duration(500)
                .attr("transform", d => {
                    const node = nodes.find(n => n.id === d.id);
                    if (!node) return `translate(0,0)`;
                    const y = node.targetY + d.yOff + (d.yOff > 0 ? 10 : -10);
                    return `translate(${node.targetX}, ${y})`;
                });
            
            ptrMerge.select("text").text(d => d.label);
            ptrMerge.select("rect").style("fill", d => {
                if (d.label === 'l1') return "#3b82f6";
                if (d.label === 'l2') return "#a855f7";
                return "#22c55e"; // tail
            });
            
            ptrMerge.select("path").attr("d", d => d.yOff < 0 ? "M0,10 L0,25" : "M0,-10 L0,-25").attr("marker-end", "url(#arrow-white)");
            
            ptrSel.exit().remove();
            
            // Row Labels
            svg.selectAll(".row-label-text").remove();
            svg.append("text").attr("x", 10).attr("y", 105).text("List 1").attr("class", "row-label");
            svg.append("text").attr("x", 10).attr("y", 185).text("List 2").attr("class", "row-label");
            svg.append("text").attr("x", 10).attr("y", 305).text("Merged").attr("class", "row-label");
        }

        function runVisualizer() {
            const l1Raw = document.getElementById('l1Input').value;
            const l2Raw = document.getElementById('l2Input').value;
            const l1 = l1Raw.split(',').map(x=>parseInt(x.trim())).filter(x=>!isNaN(x));
            const l2 = l2Raw.split(',').map(x=>parseInt(x.trim())).filter(x=>!isNaN(x));
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(l1, l2));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
