<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merge Two Sorted Lists - D3 å‹•æ…‹è¦–è¦ºåŒ–</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 450px;
        }
        
        #viz-svg { width: 100%; height: 400px; }

        .node-circle { stroke-width: 3px; transition: all 0.5s; r: 20px; }
        .node-text { fill: white; font-weight: bold; font-family: monospace; font-size: 14px; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        
        .link { fill: none; stroke: #64748b; stroke-width: 2px; marker-end: url(#arrow); transition: all 0.5s; opacity: 0.6; }
        
        /* Node Types */
        .node-l1 { fill: #3b82f6; stroke: #2563eb; }
        .node-l2 { fill: #a855f7; stroke: #9333ea; }
        .node-merged { stroke: #22c55e; fill: rgba(34, 197, 94, 0.2); } 

        .node-dimmed { opacity: 0.3; }
        .node-active { stroke: #fbbf24; stroke-width: 4px; filter: drop-shadow(0 0 8px rgba(251, 191, 36, 0.6)); }

        /* Labels */
        .label-text { font-size: 14px; fill: #94a3b8; font-weight: bold; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; }
        .input-row label { color: #94a3b8; font-size: 0.9rem; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 120px; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; margin-top: 15px; width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="åˆ‡æ›ä¸»é¡Œ">ğŸŒ“</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Merge Two Sorted Lists</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label>List 1:</label>
                        <input type="text" id="l1Input" value="1,2,7">
                        <label>List 2:</label>
                        <input type="text" id="l2Input" value="1,3,4">
                        <button onclick="runVisualizer()">åˆä½µ</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <svg id="viz-svg">
                        <defs>
                            <marker id="arrow" markerWidth="10" markerHeight="10" refX="22" refY="3" orient="auto">
                                <path d="M0,0 L0,6 L9,3 z" fill="#64748b" />
                            </marker>
                        </defs>
                        <g id="main-group" transform="translate(50, 50)"></g>
                        <g id="labels-group" transform="translate(10, 50)"></g>
                    </svg>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">ç•¶å‰æ­¥é©Ÿ</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">â† ä¸Šä¸€æ­¥</button>
                    <div class="step-indicator">æ­¥é©Ÿ <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">ä¸‹ä¸€æ­¥ â†’</button>
                    <button class="viz-btn" onclick="runVisualizer()">â†» é‡ç½®</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">â–¶ è‡ªå‹•æ’­æ”¾</button>
                    <div class="speed-control">
                        <label>é€Ÿåº¦:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">é‚è¼¯è§£é‡‹</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'ListNode* mergeTwoLists(list1, list2) {', id: 0 },
            { line: '    ListNode dummy;', id: 1 },
            { line: '    ListNode* tail = &dummy;', id: 2 },
            { line: '    while(list1 && list2) {', id: 3 },
            { line: '        if(list1->val < list2->val) {', id: 4 },
            { line: '            tail->next = list1;', id: 5 },
            { line: '            list1 = list1->next;', id: 6 },
            { line: '        } else {', id: 7 },
            { line: '            tail->next = list2;', id: 8 },
            { line: '            list2 = list2->next;', id: 9 },
            { line: '        }', id: 10 },
            { line: '        tail = tail->next;', id: 11 },
            { line: '    }', id: 12 },
            { line: '    if(list1) tail->next = list1;', id: 13 },
            { line: '    if(list2) tail->next = list2;', id: 14 },
            { line: '    return dummy.next;', id: 15 },
            { line: '}', id: 16 }
        ];

        let viz;

        function simulate(arr1, arr2) {
            const steps = [];
            
            // Build initial nodes with positions
            // L1 row: y=50
            // L2 row: y=150
            // Result row: y=250 (conceptually)
            // But we will move nodes to result
            
            // Give unique IDs
            const nodes1 = arr1.map((v, i) => ({id: `l1-${i}`, val: v, type: 'l1', idx: i}));
            const nodes2 = arr2.map((v, i) => ({id: `l2-${i}`, val: v, type: 'l2', idx: i}));
            
            let p1 = 0, p2 = 0;
            const merged = []; // List of IDs in merged order
            
            const pushState = (msg, hl, activeIds=[], explanation=null) => {
                steps.push({
                    nodes1: JSON.parse(JSON.stringify(nodes1)),
                    nodes2: JSON.parse(JSON.stringify(nodes2)), // Include nodes2
                    p1, p2, merged: [...merged],
                    msg, highlightLines: hl,
                    activeIds,
                    explanation
                });
            };

            // Init
            pushState("Init: Dummy node prepared", [1, 2], [], {
                title: 'åˆå§‹åŒ–',
                text: 'å»ºç«‹ Dummy ç¯€é»ä½œç‚ºçµæœéˆè¡¨çš„é–‹é ­ã€‚Tail æŒ‡æ¨™æŒ‡å‘ Dummyã€‚',
                formula: 'tail = &dummy'
            });

            while(p1 < nodes1.length && p2 < nodes2.length) {
                const n1 = nodes1[p1];
                const n2 = nodes2[p2];
                
                pushState(`Compare: ${n1.val} vs ${n2.val}`, [3, 4], [n1.id, n2.id], {
                    title: 'æ¯”è¼ƒç¯€é»å€¼',
                    text: `æ¯”è¼ƒ List1 ç•¶å‰ç¯€é» (${n1.val}) èˆ‡ List2 ç•¶å‰ç¯€é» (${n2.val})ã€‚`,
                    formula: `list1->val (${n1.val}) ${n1.val < n2.val ? '<' : '>='} list2->val (${n2.val})`
                });

                if (n1.val < n2.val) {
                    merged.push(n1.id);
                    pushState(`Append List1 Node (${n1.val})`, [5, 6], [n1.id], {
                        title: 'é€£æ¥è¼ƒå°å€¼ (List1)',
                        text: `å› ç‚º ${n1.val} < ${n2.val}ï¼Œæ‰€ä»¥å°‡ List1 çš„ç¯€é»æ¥åˆ° result éˆè¡¨å¾Œé¢ã€‚<br>Tail ç§»å‹•åˆ°æ­¤ç¯€é»ã€‚List1 æŒ‡æ¨™å‰é€²ã€‚`,
                        formula: 'tail->next = list1; list1 = list1->next'
                    });
                    p1++;
                } else {
                    merged.push(n2.id);
                    pushState(`Append List2 Node (${n2.val})`, [8, 9], [n2.id], {
                        title: 'é€£æ¥è¼ƒå°å€¼ (List2)',
                        text: `å› ç‚º ${n2.val} <= ${n1.val}ï¼Œæ‰€ä»¥å°‡ List2 çš„ç¯€é»æ¥åˆ° result éˆè¡¨å¾Œé¢ã€‚<br>Tail ç§»å‹•åˆ°æ­¤ç¯€é»ã€‚List2 æŒ‡æ¨™å‰é€²ã€‚`,
                        formula: 'tail->next = list2; list2 = list2->next'
                    });
                    p2++;
                }
                
                pushState("Tail advanced", [11], merged.length > 0 ? [merged[merged.length-1]] : [], {
                    title: 'æ›´æ–° Tail',
                    text: 'Tail æŒ‡é‡ç¾åœ¨æŒ‡å‘å‰›åŠ å…¥çš„ç¯€é»ï¼Œæº–å‚™é€£æ¥ä¸‹ä¸€å€‹ã€‚',
                    formula: 'tail = tail->next'
                });
            }

            // Remainder
            if(p1 < nodes1.length) {
                // Add all rest
                const rest = nodes1.slice(p1).map(n=>n.id);
                merged.push(...rest);
                pushState("Append remaining List1", [13], rest, {
                    title: 'é€£æ¥å‰©é¤˜ List1',
                    text: 'List2 å·²ç©ºï¼Œå°‡ List1 å‰©é¤˜æ‰€æœ‰ç¯€é»ç›´æ¥æ¥åˆ° Tail å¾Œé¢ã€‚',
                    formula: 'tail->next = list1'
                });
            } else if (p2 < nodes2.length) {
                const rest = nodes2.slice(p2).map(n=>n.id);
                merged.push(...rest);
                pushState("Append remaining List2", [14], rest, {
                    title: 'é€£æ¥å‰©é¤˜ List2',
                    text: 'List1 å·²ç©ºï¼Œå°‡ List2 å‰©é¤˜æ‰€æœ‰ç¯€é»ç›´æ¥æ¥åˆ° Tail å¾Œé¢ã€‚',
                    formula: 'tail->next = list2'
                });
            }

            pushState("Done", [15], merged, {
                title: 'å®Œæˆ',
                text: 'åˆä½µå®Œæˆã€‚è¿”å› Dummy.next ä½œç‚ºæ–°éˆè¡¨çš„é ­ã€‚',
                formula: 'return dummy.next'
            });

            return steps;
        }

        const svg = d3.select("#viz-svg");
        const gMain = d3.select("#main-group");
        const gLabels = d3.select("#labels-group");

        // Static labels
        gLabels.append("text").attr("x", 0).attr("y", 0).text("List 1").attr("class", "label-text").attr("fill", "#3b82f6");
        gLabels.append("text").attr("x", 0).attr("y", 100).text("List 2").attr("class", "label-text").attr("fill", "#a855f7");
        gLabels.append("text").attr("x", 0).attr("y", 200).text("Merged").attr("class", "label-text").attr("fill", "#22c55e");

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;

            // Compute Node Positions based on state
            // merged: list of IDs
            // nodes1 & nodes2 are static lists, but we need to check if they are in merged
            
            const nodeData = [];
            const NODE_GAP = 60;
            const START_X = 80;

            // Helper to get node by ID
            const findNode = (id) => {
                let n = step.nodes1.find(x=>x.id===id);
                if(n) return {...n};
                return step.nodes1.concat(/*dummy*/).find(x=>x.id===id); // wait, logic helper
                // We don't have explicit step.nodes1/2 updated with positions in step gen
                // Just use the arrays passed in closure? No, step has them but they don't change props
            };
            
            // Reconstruct all nodes for display
            // List 1
            step.nodes1.forEach(n => {
                const isMerged = step.merged.includes(n.id);
                if(isMerged) {
                    const idx = step.merged.indexOf(n.id);
                    nodeData.push({ ...n, x: START_X + idx * NODE_GAP, y: 200, state: 'merged' });
                } else {
                    // Original pos, but maybe shifted if p1 advanced? 
                    // No, stick to absolute index position for clarity or shift?
                    // Better to keep them in row
                    nodeData.push({ ...n, x: START_X + n.idx * NODE_GAP, y: 0, state: 'l1' });
                }
            });
            
            // List 2
            step.nodes2.forEach(n => {
                const isMerged = step.merged.includes(n.id);
                if(isMerged) {
                    // Already added? merged list contains ID.
                    // But we push to nodeData only once? 
                    // merged contains ID. nodeData needs x,y.
                    // If we process merged list specifically, we can order them?
                    // Better: iterate merged list for positions y=200.
                    // Iterate remaining nodes1 for y=0.
                    // Iterate remaining nodes2 for y=100.
                } else {
                    nodeData.push({ ...n, x: START_X + n.idx * NODE_GAP, y: 100, state: 'l2' });
                }
            });
            
            // Merged Row
            step.merged.forEach((id, i) => {
                // Find node in inputs
                let n = step.nodes1.find(x=>x.id===id) || step.nodes2.find(x=>x.id===id);
                if(n) {
                    nodeData.push({ ...n, x: START_X + i * NODE_GAP, y: 200, state: 'merged' });
                }
            });

            // Viz
            const nSel = gMain.selectAll(".node-g").data(nodeData, d => d.id);
            const nEnter = nSel.enter().append("g").attr("class", "node-g");
            nEnter.append("circle").attr("class", "node-circle");
            nEnter.append("text").attr("class", "node-text").attr("dy", 1);
            
            const nUpdate = nSel.merge(nEnter).transition().duration(500)
                .attr("transform", d => `translate(${d.x}, ${d.y})`);
                
            nUpdate.select("circle")
                .attr("class", d => {
                    let c = "node-circle";
                    if(d.state === 'l1') c += " node-l1";
                    else if(d.state === 'l2') c += " node-l2";
                    else c += " node-merged";
                    
                    if(step.activeIds && step.activeIds.includes(d.id)) {
                        c += " node-active"; // Highlight comparison
                    }
                    return c;
                });
            
            nUpdate.select("text").text(d => d.val);
            nSel.exit().remove();
            
            // Links (merged only?)
            const links = [];
            // Merged chain
            for(let i=0; i<step.merged.length-1; i++) {
                links.push({s: i, t: i+1}); // visual index in merged row
            }
            // What about next pointers in L1/L2?
            // Visual simplification: show next pointers in L1/L2 until they are merged.
            // If in L1 row, point to next in L1 row.
            // ... simple implementation: only merged links for now to show result.
            
            const lSel = gMain.selectAll(".link").data(links);
            lSel.enter().append("path").attr("class", "link")
                .merge(lSel)
                .transition().duration(500)
                .attr("d", d => {
                    const sx = START_X + d.s * NODE_GAP;
                    const tx = START_X + d.t * NODE_GAP - 25; // Arrow gap
                    return `M ${sx},200 L ${tx},200`;
                });
            lSel.exit().remove();
        }

        function runVisualizer() {
            const arr1 = document.getElementById('l1Input').value.split(',').map(x=>parseInt(x.trim())).filter(n=>!isNaN(n));
            const arr2 = document.getElementById('l2Input').value.split(',').map(x=>parseInt(x.trim())).filter(n=>!isNaN(n));
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(arr1, arr2));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
