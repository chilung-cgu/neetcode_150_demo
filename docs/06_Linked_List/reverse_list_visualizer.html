<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reverse Linked List - D3 ç²¾ç·»è¦–è¦ºåŒ–</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 400px;
        }
        
        #viz-svg { width: 100%; height: 350px; }

        .node-circle { fill: #334155; stroke: #64748b; stroke-width: 3px; transition: all 0.3s; }
        .node-circle.active { fill: rgba(251, 191, 36, 0.1); stroke: #fbbf24; }
        .node-circle.processed { fill: rgba(34, 197, 94, 0.1); stroke: #22c55e; }

        .node-text { fill: white; font-weight: bold; font-family: monospace; font-size: 16px; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        
        .link { fill: none; stroke: #64748b; stroke-width: 2px; marker-end: url(#arrow); transition: all 0.5s; opacity: 0.6; }
        .link.reversed { stroke: #22c55e; marker-end: url(#arrow-reversed); }
        .link.null { stroke-dasharray: 5; opacity: 0.3; }

        /* Pointers */
        .ptr-label { font-size: 12px; font-weight: bold; text-anchor: middle; fill: white; }
        
        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 200px; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; margin-top: 15px; width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="åˆ‡æ›ä¸»é¡Œ">ğŸŒ“</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Reverse Linked List (Iterative)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label>Nodes:</label>
                        <input type="text" id="nodesInput" value="1, 2, 3, 4, 5">
                        <button onclick="runVisualizer()">åŸ·è¡Œ</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <svg id="viz-svg">
                        <defs>
                            <marker id="arrow" markerWidth="10" markerHeight="10" refX="24" refY="3" orient="auto">
                                <path d="M0,0 L0,6 L9,3 z" fill="#64748b" />
                            </marker>
                            <marker id="arrow-reversed" markerWidth="10" markerHeight="10" refX="24" refY="3" orient="auto">
                                <path d="M0,0 L0,6 L9,3 z" fill="#22c55e" />
                            </marker>
                        </defs>
                        <g id="main-group" transform="translate(50, 150)"></g>
                        <g id="pointers-group" transform="translate(50, 150)"></g>
                    </svg>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">ç•¶å‰æ­¥é©Ÿ</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">â† ä¸Šä¸€æ­¥</button>
                    <div class="step-indicator">æ­¥é©Ÿ <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">ä¸‹ä¸€æ­¥ â†’</button>
                    <button class="viz-btn" onclick="runVisualizer()">â†» é‡ç½®</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">â–¶ è‡ªå‹•æ’­æ”¾</button>
                    <div class="speed-control">
                        <label>é€Ÿåº¦:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">é‚è¼¯è§£é‡‹</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'ListNode* reverseList(ListNode* head) {', id: 0 },
            { line: '    ListNode *prev = nullptr;', id: 1 },
            { line: '    ListNode *curr = head;', id: 2 },
            { line: '    while (curr != nullptr) {', id: 3 },
            { line: '        ListNode *next = curr->next;', id: 4 },
            { line: '        curr->next = prev;', id: 5 },
            { line: '        prev = curr;', id: 6 },
            { line: '        curr = next;', id: 7 },
            { line: '    }', id: 8 },
            { line: '    return prev;', id: 9 },
            { line: '}', id: 10 }
        ];

        let viz;

        function simulate(values) {
            const steps = [];
            // Nodes structure: {id, val, x, y}
            // Layout: horizontal
            const nodes = values.map((v, i) => ({
                id: i, val: v, x: i * 80 + 20, y: 0
            }));
            
            // Links: source (id) -> target (id)
            // Initially 0->1, 1->2 ...
            let links = [];
            for(let i=0; i<nodes.length-1; i++) {
                links.push({s: i, t: i+1});
            }

            // Pointers state: index in 'nodes' array or -1 (null)
            // prev, curr, next
            
            const pushState = (msg, hl, prev, curr, next, explanation) => {
                steps.push({
                    nodes: JSON.parse(JSON.stringify(nodes)),
                    links: JSON.parse(JSON.stringify(links)),
                    pointers: { prev, curr, next },
                    msg, highlightLines: hl,
                    explanation
                });
            };

            // Init
            let prev = -1; // null
            let curr = 0;  // head
            let next = -1; // undefined initially

            pushState("Init: prev=null, curr=head", [1, 2], prev, curr, next, {
                title: 'åˆå§‹åŒ–æŒ‡é‡',
                text: 'åˆå§‹åŒ–å…©å€‹æŒ‡é‡ï¼š<br>prev (å‰ä¸€å€‹ç¯€é») æŒ‡å‘ nullã€‚<br>curr (ç•¶å‰ç¯€é») æŒ‡å‘ headã€‚<br>æº–å‚™é–‹å§‹éæ­·ä¸¦åè½‰ã€‚',
                formula: 'prev = null; curr = head'
            });

            while(curr < nodes.length) {
                // Loop Start
                pushState(`Loop: curr=${nodes[curr].val}`, [3], prev, curr, next, {
                    title: 'é€²å…¥è¿´åœˆ',
                    text: `æª¢æŸ¥ curr æ˜¯å¦ç‚º nullã€‚ç•¶å‰ curr æŒ‡å‘ ${nodes[curr].val}ï¼Œç¹¼çºŒåŸ·è¡Œã€‚`,
                    formula: 'curr != null'
                });

                // next = curr.next
                // Finding next based on initial structure logic (which is linear i -> i+1)
                // BUT after reversal links change? No, 'next' logic follows OLD structure or current links?
                // In code: next = curr->next.
                // Initially curr(0)->next(1).
                // Wait, if we change structure, we must track actual links.
                // Links array holds current structure.
                const currLink = links.find(l => l.s === curr);
                next = currLink ? currLink.t : -1; // -1 as null
                
                // Correction: In standard reversal, next is simply the original next node.
                // Since this is SLL, we can just say index+1 if we haven't messed up indices usage.
                // Yes, we traverse linearly 0, 1, 2... so next is just curr+1 (in original indices) if not reversed yet?
                // Actually, logic is: save 'curr->next' (which points to next node in original chain).
                // Since we process linearly, this is always the node at index curr+1.
                // But strictly speaking, we rely on the link.
                // Let's rely on simulated 'links' state.
                // initially links are s->t.
                // When we reverse, we change s->t to s->prev.
                
                // Wait, if we use find(l => l.s === curr), initially it returns (curr, curr+1). Correct.
                // After reversal of previous node, does it affect current?
                // No, previous node changed ITS next. Current node still points to its original next.
                // So this logic holds.
                
                pushState(`Save next: next = ${next!==-1 ? nodes[next].val : 'null'}`, [4], prev, curr, next, {
                    title: 'æš«å­˜ Next',
                    text: `ç‚ºäº†ä¸ä¸Ÿå¤±å¾ŒçºŒéˆè¡¨ï¼Œå…ˆå°‡ curr->next å­˜å…¥ next æŒ‡é‡ã€‚<br>Next æŒ‡å‘ ${next!==-1 ? nodes[next].val : 'null'}ã€‚`,
                    formula: 'next = curr->next'
                });

                // curr->next = prev
                // Update links
                links = links.filter(l => l.s !== curr);
                if(prev !== -1) {
                    links.push({s: curr, t: prev, type: 'reversed'});
                }
                // (Visual: if prev is null, no link out of curr, pointing to nothing)

                pushState(`Reverse: ${nodes[curr].val} -> ${prev!==-1?nodes[prev].val:'null'}`, [5], prev, curr, next, {
                    title: 'åè½‰æŒ‡é‡',
                    text: `å°‡ curr çš„ next æŒ‡é‡æŒ‡å‘ prevã€‚<br>ç¾åœ¨ ${nodes[curr].val} æŒ‡å‘ ${prev!==-1?nodes[prev].val:'null'}ã€‚<br>é€™æ˜¯åè½‰çš„é—œéµæ­¥é©Ÿã€‚`,
                    formula: 'curr->next = prev'
                });

                // prev = curr
                prev = curr;
                pushState(`Move prev: prev = ${nodes[prev].val}`, [6], prev, curr, next, {
                    title: 'ç§»å‹• prev',
                    text: `prev å‘å‰ç§»å‹•ä¸€æ­¥ï¼Œè®Šæˆç•¶å‰ç¯€é» ${nodes[prev].val}ã€‚<br>ç‚ºä¸‹ä¸€æ¬¡è¿­ä»£åšæº–å‚™ã€‚`,
                    formula: 'prev = curr'
                });

                // curr = next
                curr = (next === -1) ? nodes.length : next; // use length to signify end of loop condition logic
                
                pushState(`Move curr: curr = ${curr<nodes.length ? nodes[curr].val : 'null'}`, [7], prev, curr, next, {
                    title: 'ç§»å‹• curr',
                    text: `curr å‘å‰ç§»å‹•ä¸€æ­¥ï¼ŒæŒ‡å‘å‰›æ‰æš«å­˜çš„ nextã€‚<br>æº–å‚™è™•ç†ä¸‹ä¸€å€‹ç¯€é»ã€‚`,
                    formula: 'curr = next'
                });
            }

            pushState("Done: return prev", [9], prev, curr, next, {
                title: 'å®Œæˆ',
                text: `curr ç‚º nullï¼Œè¿´åœˆçµæŸã€‚<br>prev åœåœ¨æ–°çš„é ­ç¯€é» (${nodes[prev].val})ã€‚<br>è¿”å› prevã€‚`,
                formula: 'return prev'
            });

            return steps;
        }

        const svg = d3.select("#viz-svg");
        const gMain = d3.select("#main-group");
        const gPtrs = d3.select("#pointers-group");

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;

            // Links
            const linkData = step.links.map(l => ({
                s: step.nodes[l.s], t: step.nodes[l.t], type: l.type
            }));
            
            const lSel = gMain.selectAll(".link").data(linkData, d => d.s.id + "-" + d.t.id);
            lSel.enter().append("path").attr("class", "link")
                .merge(lSel)
                .transition().duration(500)
                .attr("d", d => {
                    // Start and end points
                    const sx = d.s.x, sy = d.s.y;
                    const tx = d.t.x, ty = d.t.y;
                    
                    if(d.type === 'reversed') {
                        // Curve below
                        return `M ${sx},${sy+15} Q ${(sx+tx)/2},${sy+60} ${tx},${ty+15}`;
                    } else {
                        // Straight or slight curve above
                        return `M ${sx},${sy-15} L ${tx},${ty-15}`;
                    }
                })
                .attr("class", d => d.type === 'reversed' ? "link reversed" : "link")
                .attr("marker-end", d => d.type === 'reversed' ? "url(#arrow-reversed)" : "url(#arrow)");
            
            lSel.exit().remove();

            // Nodes
            const nSel = gMain.selectAll(".node-g").data(step.nodes, d => d.id);
            const nEnter = nSel.enter().append("g").attr("class", "node-g");
            nEnter.append("circle").attr("r", 20).attr("class", "node-circle");
            nEnter.append("text").attr("class", "node-text").attr("dy", 2);
            
            const nUpdate = nSel.merge(nEnter)
                .attr("transform", d => `translate(${d.x}, ${d.y})`);
            
            nUpdate.select("circle").attr("class", d => {
                // Highlight if involved
                let c = "node-circle";
                if(step.pointers.curr === d.id) c += " active";
                if(step.pointers.prev === d.id) c += " processed";
                return c;
            });
            nUpdate.select("text").text(d => d.val);
            nSel.exit().remove();

            // Pointers
            const ptrs = [
                {id: 'prev', idx: step.pointers.prev, color: '#22c55e', offset: 40},
                {id: 'curr', idx: step.pointers.curr, color: '#fbbf24', offset: 60},
                {id: 'next', idx: step.pointers.next, color: '#f97316', offset: 80}
            ];
            
            const pSel = gPtrs.selectAll(".ptr-g").data(ptrs, d => d.id);
            const pEnter = pSel.enter().append("g").attr("class", "ptr-g");
            pEnter.append("path").attr("d", "M0,0 L-5,10 L5,10 Z").attr("class", "pointer-arrow");
            pEnter.append("text").attr("class", "ptr-label").attr("y", 22);
            
            const pUpdate = pSel.merge(pEnter).transition().duration(400)
                .attr("transform", d => {
                    let x = 0;
                    if(d.idx === -1 || d.idx === undefined) x = -50; 
                    else if(d.idx >= step.nodes.length) x = step.nodes[step.nodes.length-1].x + 80;
                    else x = step.nodes[d.idx].x;
                    
                    return `translate(${x}, ${d.offset}) rotate(180)`;
                });
                
            pUpdate.select("path").style("fill", d => d.color);
            pUpdate.select("text").text(d => d.id).style("fill", d => d.color)
                .attr("transform", "rotate(180) translate(0, 10)"); // Text right side up
                
            pSel.exit().remove();
        }

        function runVisualizer() {
            const vals = document.getElementById('nodesInput').value.split(',').map(x=>x.trim());
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(vals));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
