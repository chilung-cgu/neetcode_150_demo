<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reorder List - D3 Á≤æÁ∑ªË¶ñË¶∫Âåñ</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 480px;
        }
        
        #viz-svg { width: 100%; height: 400px; }

        .node-circle { stroke-width: 3px; transition: all 0.5s; fill: #334155; stroke: #64748b; }
        .node-circle.first-half { stroke: #3b82f6; fill: rgba(59, 130, 246, 0.1); }
        .node-circle.second-half { stroke: #a855f7; fill: rgba(168, 85, 247, 0.1); }
        
        .node-text { fill: white; font-weight: bold; font-family: monospace; font-size: 14px; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        
        .link { fill: none; stroke: #64748b; stroke-width: 2px; marker-end: url(#arrow); transition: all 0.5s; opacity: 0.6; }
        .link.merge { stroke: #22c55e; stroke-width: 3px; }

        /* Pointers */
        .ptr-label { font-size: 12px; font-weight: bold; text-anchor: middle; fill: white; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 150px; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; margin-top: 15px; width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Reorder List (L0 -> Ln -> L1 -> Ln-1 ...)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label>List:</label>
                        <input type="text" id="nodesInput" value="1, 2, 3, 4, 5">
                        <button onclick="runVisualizer()">Reorder</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <svg id="viz-svg">
                        <defs>
                            <marker id="arrow" markerWidth="10" markerHeight="10" refX="22" refY="3" orient="auto">
                                <path d="M0,0 L0,6 L9,3 z" fill="#64748b" />
                            </marker>
                        </defs>
                        <g id="main-group" transform="translate(50, 50)"></g>
                        <g id="overlay-group" transform="translate(50, 50)"></g>
                    </svg>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn" onclick="runVisualizer()">‚Üª ÈáçÁΩÆ</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'void reorderList(ListNode* head) {', id: 0 },
            { line: '    // 1. Find Middle', id: 1 },
            { line: '    slow = head; fast = head->next;', id: 2 },
            { line: '    while (fast && fast->next) {', id: 3 },
            { line: '        slow = slow->next;', id: 4 },
            { line: '        fast = fast->next->next;', id: 5 },
            { line: '    }', id: 6 },
            { line: '    // 2. Reverse Second Half', id: 7 },
            { line: '    second = slow->next; slow->next = null;', id: 8 },
            { line: '    prev = null;', id: 9 },
            { line: '    while (second) {', id: 10 },
            { line: '        temp = second->next; second->next = prev;', id: 11 },
            { line: '        prev = second; second = temp;', id: 12 },
            { line: '    }', id: 13 },
            { line: '    // 3. Merge', id: 14 },
            { line: '    second = prev; first = head;', id: 15 },
            { line: '    while (second) {', id: 16 },
            { line: '        t1 = first->next; t2 = second->next;', id: 17 },
            { line: '        first->next = second; second->next = t1;', id: 18 },
            { line: '        first = t1; second = t2;', id: 19 },
            { line: '    }', id: 20 },
            { line: '}', id: 21 },
        ];

        let viz;

        function simulate(values) {
            const steps = [];
            // Basic nodes: 0..N-1
            const nodes = values.map((v, i) => ({ id: i, val: v, group: 'none' }));
            let links = [];
            for(let i=0; i<nodes.length-1; i++) links.push({s:i, t:i+1});

            // State capture
            const pushState = (msg, hl, ptrs={}, mode='linear', explanation=null) => {
                steps.push({
                    nodes: JSON.parse(JSON.stringify(nodes)),
                    links: JSON.parse(JSON.stringify(links)),
                    ptrs,
                    mode,
                    msg, highlightLines: hl,
                    explanation
                });
            };

            // Phase 1: Find Middle
            let slow = 0, fast = 0; // indices
            
            // Logic correction for Fast Init: fast = head.next? Code uses head.next.
            // If length=1, fast is null.
            if(values.length > 1) fast = 1; else fast = -1; // null
            
            pushState("Phase 1: Â∞ãÊâæ‰∏≠Èªû (Fast & Slow)", [1, 2], {slow, fast}, 'linear', {
                title: 'Phase 1: Â∞ãÊâæ‰∏≠Èªû',
                text: '‰ΩøÁî®Âø´ÊÖ¢ÊåáÊ®ô (Fast & Slow) Â∞ãÊâæÈèàË°®ÁöÑ‰∏≠Èªû„ÄÇSlow ÊØèÊ¨°Ëµ∞‰∏ÄÊ≠•ÔºåFast ÊØèÊ¨°Ëµ∞ÂÖ©Ê≠•„ÄÇ',
                formula: 'slow = head, fast = head->next'
            });

            // Fast logic matches code: while (fast && fast->next)
            // Simulating node structure traversal
            let fastNode = fast === -1 ? null : nodes[fast];
            // Safe traversal simulation
            
            while(fast !== -1 && fast+1 < nodes.length) { // fast.next != null
                // fast move 2
                let nextFast = fast + 2; 
                if(nextFast >= nodes.length) nextFast = -1; // off bound
                
                slow = slow + 1;
                fast = nextFast;
                
                pushState(`Slow -> ${slow}, Fast moves 2`, [3, 4, 5], {slow, fast}, 'linear', {
                    title: 'ÁßªÂãïÊåáÊ®ô',
                    text: `Slow ÁßªÂãïÂà∞ ${nodes[slow].val}„ÄÇ<br>Fast ÁßªÂãïÂÖ©Ê≠•„ÄÇÁï∂ Fast Âà∞ÈÅîÊú´Â∞æÊôÇÔºåSlow Â∞á‰ΩçÊñº‰∏≠Èªû„ÄÇ`,
                    formula: 'slow = slow->next; fast = fast->next->next'
                });
            }
            
            pushState(`‰∏≠ÈªûÊâæÂà∞: ${nodes[slow].val}`, [6], {slow}, 'linear', {
                title: 'Á¢∫Ë™ç‰∏≠Èªû',
                text: `Slow ÊåáÂêëÈèàË°®‰∏≠Èªû (Ââç‰∏ÄÁØÄÈªûÔºåËã•ÁÇ∫ÂÅ∂Êï∏Èï∑Â∫¶)„ÄÇÊàëÂÄëÂ∞áÂæûÊ≠§ËôïÂàáÊñ∑ÈèàË°®„ÄÇ`,
                formula: 'mid = slow'
            });

            // Phase 2: Split and Reverse
            const midIdx = slow;
            const secondStartIdx = midIdx + 1;
            
            // Cut link
            links = links.filter(l => l.s !== midIdx);
            
            // Identify groups for coloring
            for(let i=0; i<=midIdx; i++) nodes[i].group = 'first';
            for(let i=secondStartIdx; i<nodes.length; i++) nodes[i].group = 'second';
            
            pushState("Phase 2: ÂàáÊñ∑‰∏¶ÂèçËΩâÂæåÂçäÊÆµ", [7, 8], {second: secondStartIdx}, 'split', {
                title: 'Phase 2: ÂàáÂâ≤ËàáÂèçËΩâ',
                text: 'Â∞áÈèàË°®Âæû‰∏≠ÈªûÂàáÊñ∑„ÄÇÊ∫ñÂÇôÂèçËΩâÂæåÂçäÊÆµÈèàË°® (Á¥´Ëâ≤ÈÉ®ÂàÜ)„ÄÇ',
                formula: 'second = slow->next; slow->next = null'
            });

            // Reverse second half logic
            // Nodes indices: secondStartIdx ... n-1
            let prev = -1;
            let curr = secondStartIdx;
            
            // If empty second half (e.g. length 1)
            if(curr >= nodes.length) curr = -1; 

            while(curr !== -1) {
                // next temp logic
                // Find current 'next' from links
                const link = links.find(l => l.s === curr);
                const next = link ? link.t : -1;
                
                // Remove out link
                links = links.filter(l => l.s !== curr);
                // Add reverse link
                if(prev !== -1) links.push({s: curr, t: prev});
                
                // Move ptrs
                const oldCurr = curr;
                curr = next;
                prev = oldCurr;
                
                pushState("Reversing...", [10, 11, 12], {prev, curr: oldCurr}, 'split', {
                    title: 'ÂèçËΩâ‰∏≠',
                    text: `Â∞áÂæåÂçäÊÆµÁØÄÈªû ${nodes[oldCurr].val} ÁöÑÊåáÈáùÂèçÂêë„ÄÇ`,
                    formula: 'curr->next = prev'
                });
            }
            
            // New head of second list is 'prev'.
            const head2 = prev; // index
            pushState("ÂèçËΩâÂÆåÊàêÔºåÊ∫ñÂÇôÂêà‰Ωµ", [13, 14], {first: 0, second: head2}, 'split', {
                title: 'ÂèçËΩâÂÆåÊàê',
                text: 'ÂæåÂçäÊÆµÂ∑≤ÂèçËΩâ„ÄÇÁèæÂú®ÊàëÂÄëÊúâÂÖ©ÂÄãÈèàË°®ÔºöÈ†≠ÂçäÊÆµ (ËóçËâ≤) ÂíåÂèçËΩâÂæåÁöÑÂæåÂçäÊÆµ (Á¥´Ëâ≤)„ÄÇ',
                formula: 'Time to Merge'
            });

            // Phase 3: Merge
            let p1 = 0;
            let p2 = head2;
            
            while(p1 !== -1 && p2 !== -1) {
                // t1 = p1.next, t2 = p2.next
                // Find nexts in current links structure
                const l1 = links.find(l => l.s === p1);
                const t1 = l1 ? l1.t : -1;
                
                const l2 = links.find(l => l.s === p2);
                const t2 = l2 ? l2.t : -1;
                
                // Re-wire
                // p1 -> p2
                links = links.filter(l => l.s !== p1);
                links.push({s: p1, t: p2, type: 'merge'});
                
                // p2 -> t1
                links = links.filter(l => l.s !== p2);
                if(t1 !== -1) {
                    links.push({s: p2, t: t1, type: 'merge'});
                }
                
                pushState(`Merge: ${nodes[p1].val} -> ${nodes[p2].val}`, [17, 18], {first: p1, second: p2}, 'merge', {
                    title: '‰∫§ÈåØÂêà‰Ωµ',
                    text: `Â∞á List2 ÁöÑÁØÄÈªû (${nodes[p2].val}) ÊèíÂÖ•Âà∞ List1 ÁöÑÁØÄÈªû (${nodes[p1].val}) ‰πãÂæå„ÄÇ`,
                    formula: 'p1->next = p2; p2->next = t1'
                });
                
                p1 = t1;
                p2 = t2;
            }
            
            pushState("ÂÆåÊàê", [21], {}, 'merge', {
                title: 'ÂÆåÊàê',
                text: 'ÈèàË°®ÈáçÊéíÁµêÊùü„ÄÇ',
                formula: 'Done'
            });

            return steps;
        }

        const svg = d3.select("#viz-svg");
        const gMain = d3.select("#main-group");
        const gOverlay = d3.select("#overlay-group");

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;

            // Layout Calculation
            const SPACING = 70;
            const START_X = 50;
            
            step.nodes.forEach(n => {
                if(step.mode === 'linear') {
                    n.x = START_X + n.id * SPACING;
                    n.y = 150;
                } else if (step.mode === 'split') {
                    if (n.group === 'second') {
                        n.x = START_X + (n.id - (step.nodes.length/2)) * SPACING + 100; // offset?
                        // Simplification: keep relative x but shift y
                        n.x = START_X + n.id * SPACING; // Keep X to show reversing in place logically?
                        // Or stack them?
                        // Let's put second half below
                        n.y = 250;
                    } else {
                        n.x = START_X + n.id * SPACING;
                        n.y = 150;
                    }
                } else if (step.mode === 'merge') {
                    // Re-calculate x based on current chain order is hard without traversing links.
                    // Visual simplification: Keep original X but fluctuate Y?
                    // Or keep 'split' Y positions but draw new links?
                    // Better: Keep split layout to see the "zipper" effect clearly.
                    if (n.group === 'second') n.y = 250; else n.y = 150;
                    n.x = START_X + n.id * SPACING;
                }
            });

            // Links
            const lSel = gMain.selectAll(".link").data(step.links, d => d.s + "-" + d.t);
            lSel.enter().append("path").attr("class", "link")
                .merge(lSel)
                .transition().duration(500)
                .attr("d", d => {
                    const s = step.nodes[d.s];
                    const t = step.nodes[d.t];
                    return `M ${s.x},${s.y} L ${t.x},${t.y}`;
                })
                .attr("stroke", d => d.type === 'merge' ? '#22c55e' : null);
            lSel.exit().remove();

            // Nodes
            const nSel = gMain.selectAll(".node-g").data(step.nodes, d => d.id);
            const nEnter = nSel.enter().append("g").attr("class", "node-g");
            nEnter.append("circle").attr("r", 20).attr("class", "node-circle");
            nEnter.append("text").attr("class", "node-text").attr("dy", 1);
            
            const nUpdate = nSel.merge(nEnter).transition().duration(500)
                .attr("transform", d => `translate(${d.x}, ${d.y})`);
            
            nUpdate.select("circle").attr("class", d => {
                let c = "node-circle";
                if(d.group === 'first') c+= " first-half";
                if(d.group === 'second') c+= " second-half";
                return c;
            })
            // Highlight ptrs
            .style("stroke", d => {
                if(Object.values(step.ptrs).includes(d.id)) return "#fbbf24";
                return null;
            })
            .style("stroke-width", d => Object.values(step.ptrs).includes(d.id) ? 4 : 3);

            nUpdate.select("text").text(d => d.val);
            nSel.exit().remove();

            // Pointers Overlay
            const ptrData = [];
            Object.entries(step.ptrs).forEach(([k, v]) => {
                if(v !== -1 && step.nodes[v]) {
                    ptrData.push({l: k, x: step.nodes[v].x, y: step.nodes[v].y});
                }
            });
            
            const pSel = gOverlay.selectAll(".ptr").data(ptrData, d => d.l);
            const pEnter = pSel.enter().append("g").attr("class", "ptr");
            pEnter.append("text").attr("class", "ptr-label").attr("y", -30);
            
            const pUpdate = pSel.merge(pEnter).transition().duration(500)
                .attr("transform", d => `translate(${d.x}, ${d.y})`);
                
            pUpdate.select("text").text(d => d.l);
            pSel.exit().remove();
        }

        function runVisualizer() {
            const vals = document.getElementById('nodesInput').value.split(',').map(x=>parseInt(x.trim()));
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(vals));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
