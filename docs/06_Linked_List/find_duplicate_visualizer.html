<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Find Duplicate Number - Floyd's Algo</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 480px;
        }
        
        #viz-svg { width: 100%; height: 400px; }

        .node-circle { stroke-width: 3px; transition: all 0.3s; fill: #334155; stroke: #64748b; }
        .node-circle.start { stroke: #3b82f6; }
        .node-circle.cycle { stroke: #a855f7; fill: rgba(168, 85, 247, 0.1); }
        .node-circle.found { fill: #22c55e; stroke: #fbbf24; filter: drop-shadow(0 0 10px rgba(34, 197, 94, 0.8)); }

        .node-text { fill: white; font-weight: bold; font-family: monospace; font-size: 14px; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        .node-idx { fill: #94a3b8; font-size: 10px; text-anchor: middle; }

        .link { fill: none; stroke: #64748b; stroke-width: 2px; marker-end: url(#arrow); opacity: 0.6; }
        
        /* Pointers */
        .ptr-slow { fill: #22c55e; stroke: #16a34a; }
        .ptr-fast { fill: #ef4444; stroke: #b91c1c; }
        .ptr-label { font-size: 12px; font-weight: bold; text-anchor: middle; fill: white; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 200px; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; margin-top: 15px; width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="åˆ‡æ›ä¸»é¡Œ">ğŸŒ“</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Find Duplicate - è¦–ç‚º Linked List Cycle</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label>Nums:</label>
                        <input type="text" id="numsInput" value="1,3,4,2,2">
                        <button onclick="runVisualizer()">åŸ·è¡Œ</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <svg id="viz-svg">
                        <defs>
                            <marker id="arrow" markerWidth="10" markerHeight="10" refX="22" refY="3" orient="auto">
                                <path d="M0,0 L0,6 L9,3 z" fill="#64748b" />
                            </marker>
                        </defs>
                        <g id="main-group" transform="translate(30, 30)"></g>
                        <g id="overlay-group" transform="translate(30, 30)"></g>
                    </svg>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">ç•¶å‰æ­¥é©Ÿ</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">â† ä¸Šä¸€æ­¥</button>
                    <div class="step-indicator">æ­¥é©Ÿ <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">ä¸‹ä¸€æ­¥ â†’</button>
                    <button class="viz-btn" onclick="runVisualizer()">â†» é‡ç½®</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">â–¶ è‡ªå‹•æ’­æ”¾</button>
                    <div class="speed-control">
                        <label>é€Ÿåº¦:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">é‚è¼¯è§£é‡‹</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'int findDuplicate(vector<int>& nums) {', id: 0 },
            { line: '    int slow = 0, fast = 0;', id: 1 },
            { line: '    do {', id: 2 },
            { line: '        slow = nums[slow];', id: 3 },
            { line: '        fast = nums[nums[fast]];', id: 4 },
            { line: '    } while (slow != fast);', id: 5 },
            { line: '    slow = 0;', id: 6 },
            { line: '    while (slow != fast) {', id: 7 },
            { line: '        slow = nums[slow];', id: 8 },
            { line: '        fast = nums[fast];', id: 9 },
            { line: '    }', id: 10 },
            { line: '    return slow;', id: 11 },
            { line: '}', id: 12 }
        ];

        let viz;

        function simulate(nums) {
            const steps = [];
            // Build Graph Logic based on indices
            // Each index i points to nums[i]
            // We need to trace the path from 0 to identify the Rho shape physically
            
            const visited = new Set();
            const path = [];
            let curr = 0;
            let cycleEntry = -1;
            
            // Layout Pre-calculation
            // Trace full path
            const nodes = []; 
            for(let i=0; i<nums.length; i++) nodes.push({id:i, val:i, type:'unused'}); // Default all potential indices
            
            while(!visited.has(curr)) {
                visited.add(curr);
                path.push(curr);
                curr = nums[curr];
            }
            cycleEntry = curr; // The first repeated node in path traversal
            
            // Split path into stem and cycle
            const entryIndex = path.indexOf(cycleEntry);
            const stem = path.slice(0, entryIndex);
            const cycle = path.slice(entryIndex);
            
            // Assign Coordinates
            const SPACING = 60;
            const RADIUS = 80;
            
            // Stem
            stem.forEach((nodeIdx, i) => {
                const node = nodes[nodeIdx];
                node.x = 50 + i * SPACING;
                node.y = 50;
                node.type = (i===0) ? 'start' : 'stem';
            });
            
            // Cycle
            const cx = 50 + stem.length * SPACING + 20;
            const cy = 160;
            cycle.forEach((nodeIdx, i) => {
                const angle = -Math.PI/2 + (2 * Math.PI * i) / cycle.length;
                const node = nodes[nodeIdx];
                node.x = cx + Math.cos(angle) * RADIUS;
                node.y = cy + Math.sin(angle) * RADIUS;
                node.type = 'cycle';
            });
            
            // Nodes not in path?
            // Just stack them somewhere
            let unusedX = 0;
            nodes.filter(n => n.type === 'unused').forEach(n => {
                n.x = unusedX * 40 + 50;
                n.y = 350;
                unusedX++;
                n.hidden = true; // Maybe hide them to avoid confusion
            });

            // Links: i -> nums[i]
            const links = [];
            nodes.forEach(n => {
                if(!n.hidden) {
                    const target = nums[n.id];
                    // Only draw if target is visible
                    if (!nodes[target].hidden) {
                        links.push({source: n.id, target: target});
                    }
                }
            });

            // Init
            steps.push({
                nodes: JSON.parse(JSON.stringify(nodes)),
                links,
                s: 0, f: 0,
                msg: "Init: Slow=Fast=0",
                highlightLines: [1],
                explanation: {
                    title: 'åˆå§‹åŒ–',
                    text: 'åˆ©ç”¨é™£åˆ—å€¼ä½œç‚ºæŒ‡æ¨™ (i -> nums[i])ï¼Œæ­¤å•é¡Œè½‰åŒ–ç‚º Linked List Cycle æª¢æ¸¬ã€‚<br>åˆå§‹åŒ– Slow å’Œ Fast æŒ‡æ¨™æŒ‡å‘ç´¢å¼• 0ã€‚',
                    formula: 'slow = 0, fast = 0'
                }
            });

            // Phase 1
            let slow = 0, fast = 0;
            do {
                // Move Slow
                slow = nums[slow];
                // Move Fast
                fast = nums[nums[fast]];
                
                steps.push({
                    nodes: JSON.parse(JSON.stringify(nodes)),
                    links,
                    s: slow, f: fast,
                    msg: `Phase 1: Slow->${slow}, Fast->${fast}`,
                    highlightLines: [4, 5, 6],
                    explanation: {
                        title: 'ç¬¬ä¸€éšæ®µï¼šå°‹æ‰¾ç›¸é‡é»',
                        text: `Slow èµ°ä¸€æ­¥ (nums[slow]) åˆ° ${slow}<br>Fast èµ°å…©æ­¥ (nums[nums[fast]]) åˆ° ${fast}<br>å¦‚æœ Fast è¿½ä¸Š Slowï¼Œä»£è¡¨æœ‰ç’°ã€‚`,
                        formula: 'slow = nums[slow]; fast = nums[nums[fast]]'
                    }
                });
            } while (slow !== fast);

            steps.push({
                nodes: JSON.parse(JSON.stringify(nodes)),
                links,
                s: slow, f: fast,
                msg: "ç›¸é‡! é€²å…¥ Phase 2",
                highlightLines: [6],
                explanation: {
                    title: 'ç›¸é‡ï¼',
                    text: `Slow å’Œ Fast åœ¨ç´¢å¼• ${slow} ç›¸é‡ã€‚æ­¤æ™‚ç¢ºèªæœ‰ç’°ã€‚<br>æ ¹æ“š Floyd Cycle æ¼”ç®—æ³•ï¼Œå¾ç›¸é‡é»å’Œèµ·é»åŒæ™‚å‡ºç™¼ï¼Œæœƒåœ¨ç’°çš„å…¥å£ç›¸é‡ã€‚`,
                    formula: 'slow == fast'
                }
            });

            // Phase 2
            slow = 0;
            steps.push({
                nodes: JSON.parse(JSON.stringify(nodes)),
                links,
                s: slow, f: fast,
                msg: "é‡ç½® Slow = 0",
                highlightLines: [7],
                explanation: {
                    title: 'ç¬¬äºŒéšæ®µï¼šå°‹æ‰¾å…¥å£',
                    text: 'å°‡ Slow é‡ç½®å›èµ·é» (0)ï¼ŒFast ç•™åœ¨ç›¸é‡é»ã€‚',
                    formula: 'slow = 0'
                }
            });

            while (slow !== fast) {
                slow = nums[slow];
                fast = nums[fast]; // Fast moves 1 step now
                
                steps.push({
                    nodes: JSON.parse(JSON.stringify(nodes)),
                    links,
                    s: slow, f: fast,
                    msg: `Phase 2: Slow->${slow}, Fast->${fast} (å„èµ°ä¸€æ­¥)`,
                    highlightLines: [8, 9],
                    explanation: {
                        title: 'åŒæ­¥å‰é€²',
                        text: `Slow èµ°ä¸€æ­¥ -> ${slow}<br>Fast èµ°ä¸€æ­¥ -> ${fast}<br>å…©è€…é€Ÿåº¦ç›¸åŒï¼Œå¿…åœ¨ç’°å…¥å£ç›¸é‡ã€‚`,
                        formula: 'slow = nums[slow]; fast = nums[fast]'
                    }
                });
            }

            steps.push({
                nodes: JSON.parse(JSON.stringify(nodes)),
                links,
                s: slow, f: fast,
                found: slow,
                msg: `æ‰¾åˆ°é‡è¤‡å€¼ (Cycle Entry): ${slow}`,
                highlightLines: [11],
                final: true,
                explanation: {
                    title: 'æ‰¾åˆ°é‡è¤‡æ•¸',
                    text: `Slow å’Œ Fast åœ¨ç´¢å¼• ${slow} ç›¸é‡ï¼Œé€™å°±æ˜¯ç’°çš„å…¥å£ï¼Œä¹Ÿå°±æ˜¯é‡è¤‡çš„æ•¸å­—ï¼`,
                    formula: `return ${slow}`
                }
            });

            return steps;
        }

        const svg = d3.select("#viz-svg");
        const gMain = d3.select("#main-group");
        const gOverlay = d3.select("#overlay-group");

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;

            // Links
            // Need coords from nodes
            const nodeMap = new Map(step.nodes.map(n=>[n.id, n]));
            const linkData = step.links.map(l => ({
                s: nodeMap.get(l.source), t: nodeMap.get(l.target)
            })).filter(d => d.s && d.t); // safety

            const lSel = gMain.selectAll(".link").data(linkData);
            lSel.enter().append("path").attr("class", "link")
                .merge(lSel)
                .transition().duration(500)
                .attr("d", d => {
                    // Straight or Curved?
                    return `M ${d.s.x},${d.s.y} L ${d.t.x},${d.t.y}`; 
                    // Simple L for now, graph layout handles cycle shape nicely
                });
            lSel.exit().remove();

            // Nodes
            const nodes = gMain.selectAll(".node-g").data(step.nodes.filter(n=>!n.hidden), d=>d.id);
            const nEnter = nodes.enter().append("g").attr("class", "node-g");
            nEnter.append("circle").attr("r", 18).attr("class", "node-circle");
            nEnter.append("text").attr("class", "node-text").attr("dy", 1);
            nEnter.append("text").attr("class", "node-idx").attr("dy", 28);

            const nUpdate = nodes.merge(nEnter)
                .attr("transform", d => `translate(${d.x}, ${d.y})`);
            
            nUpdate.select("circle").attr("class", d => {
                let c = "node-circle";
                if(d.type==='start') c += " start";
                if(d.type==='cycle') c += " cycle";
                if(step.found !== undefined && d.id === step.found) c += " found";
                return c;
            })
            .style("stroke-width", d => (d.id === step.s || d.id === step.f) ? (step.found !== undefined ? 4 : 3) : 2);

            nUpdate.select(".node-text").text(d => d.id); // Show Index as Label? Or Value?
            // The problem is about finding the duplicate VALUE. 
            // In this graph conversion, node index i points to nums[i].
            // The nodes represent the INDICES. The value is the NEXT POINTER.
            // Wait, actually: index 0 -> value nums[0]. The node IS index 0. The edge goes to node index nums[0].
            // So the label should remain the Index (which is the value in range [1, n]).
            // Correct.
            nUpdate.select(".node-idx").text(d => `nums[${d.id}]`); // Optional

            nodes.exit().remove();

            // Pointers
            const pointers = [
                {id:'S', idx:step.s, color:'#22c55e', offset:-30},
                {id:'F', idx:step.f, color:'#ef4444', offset:-50}
            ];
            
            const ptrs = gOverlay.selectAll(".ptr-g").data(pointers, d=>d.id);
            const pEnter = ptrs.enter().append("g").attr("class", "ptr-g");
            pEnter.append("path").attr("d", "M0,0 L-6,-10 L6,-10 Z").attr("fill", d=>d.color);
            pEnter.append("text").attr("class", "ptr-label").attr("y", -15).text(d=>d.id).attr("fill", d=>d.color);
            
            ptrs.merge(pEnter).transition().duration(400)
                .attr("transform", d => {
                    const n = step.nodes[d.idx]; 
                    if(!n || n.hidden) return `translate(0,0)`; // shouldn't happen
                    return `translate(${n.x}, ${n.y})`;
                });
            ptrs.exit().remove();
        }

        function runVisualizer() {
            const str = document.getElementById('numsInput').value;
            const nums = str.split(',').map(x=>parseInt(x.trim())).filter(n=>!isNaN(n));
            
            if(nums.length < 2) return;

            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(nums));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
