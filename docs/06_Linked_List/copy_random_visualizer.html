<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Copy List with Random Pointer - D3 ç²¾ç·»è¦–è¦ºåŒ–</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 500px;
        }
        
        #viz-svg { width: 100%; height: 450px; }

        .node-circle { stroke-width: 3px; transition: all 0.3s; fill: #334155; }
        .node-circle.original { stroke: #3b82f6; fill: #1e293b; }
        .node-circle.copy { stroke: #22c55e; fill: #1e293b; }
        .node-circle.active { stroke: #fbbf24; fill: rgba(251, 191, 36, 0.1); }

        .node-text { fill: white; font-weight: bold; font-family: monospace; font-size: 14px; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        .node-subtext { fill: #94a3b8; font-size: 10px; text-anchor: middle; }

        .link { fill: none; stroke-width: 2px; transition: all 0.5s; opacity: 0.8; }
        .link.next { stroke: #64748b; marker-end: url(#arrow-next); }
        .link.random { stroke: #a855f7; stroke-dasharray: 4; marker-end: url(#arrow-random); }
        .link.map-link { stroke: #fbbf24; stroke-dasharray: 2; opacity: 0.4; }
        
        /* Map Entry */
        .map-box { fill: rgba(30, 41, 59, 0.8); stroke: #475569; rx: 6; }
        .map-text { fill: #cbd5e1; font-size: 12px; font-family: monospace; text-anchor: middle; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 120px; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; margin-top: 15px; width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="åˆ‡æ›ä¸»é¡Œ">ğŸŒ“</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Copy Random List (HashMap Approach)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label>Values:</label>
                        <input type="text" id="valsInput" value="7,13,11,10,1">
                        <label>Randoms (Indices):</label>
                        <input type="text" id="randsInput" value="null,0,4,2,0">
                        <button onclick="runVisualizer()">è¤‡è£½</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <svg id="viz-svg">
                        <defs>
                            <marker id="arrow-next" markerWidth="10" markerHeight="10" refX="22" refY="3" orient="auto">
                                <path d="M0,0 L0,6 L9,3 z" fill="#64748b" />
                            </marker>
                            <marker id="arrow-random" markerWidth="10" markerHeight="10" refX="22" refY="3" orient="auto">
                                <path d="M0,0 L0,6 L9,3 z" fill="#a855f7" />
                            </marker>
                        </defs>
                        <g id="map-group" transform="translate(50, 20)"></g>
                        <g id="main-group" transform="translate(50, 150)"></g>
                    </svg>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">ç•¶å‰æ­¥é©Ÿ</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">â† ä¸Šä¸€æ­¥</button>
                    <div class="step-indicator">æ­¥é©Ÿ <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">ä¸‹ä¸€æ­¥ â†’</button>
                    <button class="viz-btn" onclick="runVisualizer()">â†» é‡ç½®</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">â–¶ è‡ªå‹•æ’­æ”¾</button>
                    <div class="speed-control">
                        <label>é€Ÿåº¦:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">é‚è¼¯è§£é‡‹</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'Node* copyRandomList(Node* head) {', id: 0 },
            { line: '    if (!head) return nullptr;', id: 1 },
            { line: '    unordered_map<Node*, Node*> map;', id: 2 },
            { line: '    Node* curr = head;', id: 3 },
            { line: '    // Phase 1: Copy Nodes', id: 4 },
            { line: '    while (curr) {', id: 5 },
            { line: '        map[curr] = new Node(curr->val);', id: 6 },
            { line: '        curr = curr->next;', id: 7 },
            { line: '    }', id: 8 },
            { line: '    // Phase 2: Connect Pointers', id: 9 },
            { line: '    curr = head;', id: 10 },
            { line: '    while (curr) {', id: 11 },
            { line: '        map[curr]->next = map[curr->next];', id: 12 },
            { line: '        map[curr]->random = map[curr->random];', id: 13 },
            { line: '        curr = curr->next;', id: 14 },
            { line: '    }', id: 15 },
            { line: '    return map[head];', id: 16 },
            { line: '}', id: 17 }
        ];

        let viz;

        function simulate(values, rands) {
            const steps = [];
            // Org Links
            const nodes = values.map((v,i) => ({id: i, val: v, type: 'org'}));
            let links = [];
            for(let i=0; i<nodes.length; i++) {
                if(i < nodes.length-1) links.push({s: i, t: i+1, type: 'next'});
                if(rands[i] !== null) links.push({s: i, t: rands[i], type: 'random'});
            }

            // State: 
            // map: { orgId: copyId } (Visual mapping)
            // copyNodes: array of nodes {id, val, type: 'copy'}
            // copyLinks: array of links
            
            const map = {}; // orgId -> copyNodeObject
            const copyNodes = [];
            const copyLinks = [];
            
            const pushState = (msg, hl, activeId=null, explanation=null) => {
                steps.push({
                    orgNodes: JSON.parse(JSON.stringify(nodes)),
                    orgLinks: JSON.parse(JSON.stringify(links)),
                    copyNodes: JSON.parse(JSON.stringify(copyNodes)),
                    copyLinks: JSON.parse(JSON.stringify(copyLinks)),
                    map: {...map}, // shallow copy of keys is enough as values are ids
                    activeId,
                    msg, highlightLines: hl,
                    explanation
                });
            };

            pushState("Init: HashMap prepared", [1, 2], null, {
                title: 'åˆå§‹åŒ– Map',
                text: 'æº–å‚™ä¸€å€‹ HashMap ä¾†å„²å­˜ `Old Node -> New Node` çš„å°æ‡‰é—œä¿‚ã€‚',
                formula: 'map<Node*, Node*>'
            });

            // Phase 1
            for(let i=0; i<nodes.length; i++) {
                const node = nodes[i];
                pushState(`Phase 1: Copy Node ${node.val}`, [5], node.id, {
                    title: `è¨ªå• Original Node ${node.val}`,
                    text: `éæ­·åŸéˆè¡¨ã€‚ç•¶å‰ç¯€é»å€¼ç‚º ${node.val}ã€‚`,
                    formula: 'curr = head'
                });
                
                // Create Copy
                const copyNode = { id: `c-${node.id}`, val: node.val, type: 'copy', orgId: node.id };
                copyNodes.push(copyNode);
                map[node.id] = copyNode.id;
                
                pushState(`Created Copy ${node.val}, Add to Map`, [6], node.id, {
                    title: 'å»ºç«‹å‰¯æœ¬',
                    text: `å»ºç«‹æ–°ç¯€é» ${node.val}ã€‚ä¸¦å°‡å°æ‡‰é—œä¿‚å­˜å…¥ Mapï¼šOriginal(${node.id}) -> Copy(${copyNode.id})ã€‚`,
                    formula: 'map[curr] = new Node(curr->val)'
                });
            }

            // Phase 2
            pushState("Phase 2: Use Map to connect pointers", [10, 11], null, {
                title: 'Phase 2: é€£æ¥æŒ‡é‡',
                text: 'å†æ¬¡éæ­·åŸéˆè¡¨ï¼Œåˆ©ç”¨ Map æŸ¥æ‰¾å°æ‡‰çš„å‰¯æœ¬ç¯€é»ï¼Œä¸¦é€£æ¥ Next å’Œ Random æŒ‡é‡ã€‚',
                formula: 'curr = head'
            });

            for(let i=0; i<nodes.length; i++) {
                const orgId = i;
                const copyId = map[orgId];
                
                pushState(`Connect pointers for Copy ${nodes[i].val}`, [11], orgId, {
                    title: `è™•ç†ç¯€é» ${nodes[i].val}`,
                    text: `å–å‡ºåŸç¯€é»å°æ‡‰çš„å‰¯æœ¬ç¯€é»ï¼Œæº–å‚™è¨­å®šå…¶ Next å’Œ Randomã€‚`,
                    formula: 'copy = map[curr]'
                });

                // Next
                if(i < nodes.length-1) {
                    const nextOrgId = i + 1;
                    const nextCopyId = map[nextOrgId];
                    copyLinks.push({s: copyId, t: nextCopyId, type: 'next'});
                    
                    pushState(`Set Next: Copy(${nodes[i].val}) -> Copy(${nodes[i+1].val})`, [12], orgId, {
                        title: 'é€£æ¥ Next',
                        text: `åŸç¯€é»çš„ Next æ˜¯ ${nodes[i+1].val}ã€‚é€é Map æ‰¾åˆ°å°æ‡‰çš„å‰¯æœ¬ï¼Œå°‡ç•¶å‰å‰¯æœ¬çš„ Next æŒ‡å‘å®ƒã€‚`,
                        formula: 'map[curr]->next = map[curr->next]'
                    });
                }

                // Random
                if(rands[i] !== null) {
                    const randOrgId = rands[i];
                    const randCopyId = map[randOrgId];
                    copyLinks.push({s: copyId, t: randCopyId, type: 'random'});
                    
                    pushState(`Set Random: Copy(${nodes[i].val}) -> Copy(${nodes[rands[i]].val})`, [13], orgId, {
                        title: 'é€£æ¥ Random',
                        text: `åŸç¯€é»çš„ Random æŒ‡å‘ ${nodes[rands[i]].val}ã€‚é€é Map æ‰¾åˆ°å°æ‡‰çš„å‰¯æœ¬ï¼Œé€£æ¥ Random æŒ‡é‡ã€‚`,
                        formula: 'map[curr]->random = map[curr->random]'
                    });
                }
            }

            pushState("Done", [16], null, {
                title: 'å®Œæˆ',
                text: 'è¿”å›è¤‡è£½éˆè¡¨çš„é ­ç¯€é» (map[head])ã€‚',
                formula: 'return map[head]'
            });

            return steps;
        }

        const svg = d3.select("#viz-svg");
        const gMap = d3.select("#map-group");
        const gMain = d3.select("#main-group");

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;

            const SPACING = 80;
            
            // Layout Original Nodes (Top Row)
            step.orgNodes.forEach((n, i) => {
                n.x = i * SPACING;
                n.y = 0;
            });
            
            // Layout Copy Nodes (Bottom Row)
            step.copyNodes.forEach((n, i) => {
                n.x = i * SPACING;
                n.y = 150;
            });

            // Map Visualization
            // A box above showing Key->Val lines?
            // Or just draw dashed lines from Top Node to Bottom Node indicating map relationship?
            // Simple dashed lines are best for "Map" concept in graph viz
            
            const mapLinks = [];
            step.copyNodes.forEach(cn => {
                const org = step.orgNodes.find(n => n.id === cn.orgId); // orgId stored in copy
                if(org) {
                    mapLinks.push({s: org, t: cn});
                }
            });

            const mlSel = gMain.selectAll(".link-map").data(mapLinks);
            mlSel.enter().append("path").attr("class", "link map-link")
                .merge(mlSel)
                .transition().duration(500)
                .attr("d", d => `M ${d.s.x},${d.s.y+20} L ${d.t.x},${d.t.y-20}`);
            mlSel.exit().remove();

            // Render Links (Org and Copy)
            const allLinks = [
                ...step.orgLinks.map(l => ({...l, srcNodes: step.orgNodes})),
                ...step.copyLinks.map(l => ({...l, srcNodes: step.copyNodes}))
            ];
            
            // Need to map IDs to coords. copy IDs are strings "c-X".
            // Helper
            const getNode = (list, id) => list.find(n => n.id === id);

            const lSel = gMain.selectAll(".link-graph").data(allLinks, d => d.s + "-" + d.t + "-" + (d.srcNodes === step.copyNodes ? 'c' : 'o'));
            const lEnter = lSel.enter().append("path").attr("class", d => "link " + d.type);
            
            lSel.merge(lEnter).transition().duration(500)
                .attr("class", d => "link-graph link " + d.type)
                .attr("d", d => {
                    const s = getNode(d.srcNodes, d.s);
                    const t = getNode(d.srcNodes, d.t);
                    if(!s || !t) return "";
                    
                    if(d.type === 'next') {
                        return `M ${s.x+15},${s.y} L ${t.x-15},${t.y}`;
                    } else {
                        // Random curve
                        // Curve up for original, down for copy?
                        // Or simple curve
                        const dir = (d.srcNodes === step.orgNodes) ? -1 : 1;
                        const h = 40 * dir;
                        return `M ${s.x},${s.y} Q ${(s.x+t.x)/2},${s.y+h} ${t.x},${t.y}`;
                    }
                });
            lSel.exit().remove();

            // Nodes
            const allNodes = [...step.orgNodes, ...step.copyNodes];
            const nSel = gMain.selectAll(".node-g").data(allNodes, d => d.id);
            const nEnter = nSel.enter().append("g").attr("class", "node-g");
            nEnter.append("circle").attr("r", 15).attr("class", "node-circle");
            nEnter.append("text").attr("class", "node-text").attr("dy", 1);
            if(step.activeId !== null) nEnter.append("text").attr("class", "node-subtext").attr("dy", 28); // Label?

            const nUpdate = nSel.merge(nEnter).transition().duration(500)
                .attr("transform", d => `translate(${d.x}, ${d.y})`);
            
            nUpdate.select("circle").attr("class", d => {
                let c = "node-circle";
                if(d.type === 'org') c += " original";
                if(d.type === 'copy') c += " copy";
                if(d.id === step.activeId) c += " active";
                return c;
            });
            nUpdate.select(".node-text").text(d => d.val);
            
            nSel.exit().remove();
        }

        function runVisualizer() {
            const vStr = document.getElementById('valsInput').value;
            const rStr = document.getElementById('randsInput').value;
            
            const vals = vStr.split(',').map(x=>parseInt(x.trim()));
            const rands = rStr.split(',').map(x => {
                const t = x.trim();
                return (t==='null'||t==='') ? null : parseInt(t);
            });
            
            // Validate length
            if(vals.length !== rands.length) {
                alert("Values and Randoms length mismatch");
                return;
            }

            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(vals, rands));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
