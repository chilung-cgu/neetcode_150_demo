<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reverse in K-Group - D3 Visualizer</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 480px;
        }
        
        #viz-svg { width: 100%; height: 400px; }

        .node-circle { stroke-width: 3px; transition: all 0.3s; fill: #334155; stroke: #64748b; }
        .node-circle.dummy { stroke-dasharray: 4; fill: #1e293b; }
        .node-circle.kth { stroke: #a855f7; fill: rgba(168, 85, 247, 0.1); }
        .node-circle.active { stroke: #fbbf24; fill: rgba(251, 191, 36, 0.1); }
        .node-circle.processed { stroke: #22c55e; fill: rgba(34, 197, 94, 0.1); }

        .node-text { fill: white; font-weight: bold; font-family: monospace; font-size: 14px; text-anchor: middle; pointer-events: none; }
        .node-label { fill: #94a3b8; font-size: 10px; text-anchor: middle; }

        .link { fill: none; stroke: #64748b; stroke-width: 2px; marker-end: url(#arrow); transition: all 0.5s; opacity: 0.6; }
        .link.reversed { stroke: #22c55e; }
        .link.reversing { stroke: #ef4444; stroke-dasharray: 4; animation: dash 1s linear infinite; }
        
        @keyframes dash { to { stroke-dashoffset: -20; } }

        /* Group Box */
        .group-box { fill: none; stroke: #a855f7; stroke-width: 2px; stroke-dasharray: 5; rx: 10; transition: all 0.5s; }
        .group-label { fill: #a855f7; font-size: 12px; font-weight: bold; }

        /* Pointers */
        .ptr-label { font-size: 12px; font-weight: bold; text-anchor: middle; fill: white; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 150px; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; margin-top: 15px; width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="åˆ‡æ›ä¸»é¡Œ">ğŸŒ“</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Reverse Nodes in k-Group</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label>List:</label>
                        <input type="text" id="nodesInput" value="1, 2, 3, 4, 5">
                        <label>k:</label>
                        <input type="number" id="kInput" value="2" min="1" style="width: 50px;">
                        <button onclick="runVisualizer()">åŸ·è¡Œ</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <svg id="viz-svg">
                        <defs>
                            <marker id="arrow" markerWidth="10" markerHeight="10" refX="22" refY="3" orient="auto">
                                <path d="M0,0 L0,6 L9,3 z" fill="#64748b" />
                            </marker>
                        </defs>
                        <g id="main-group" transform="translate(50, 100)"></g>
                        <g id="overlay-group" transform="translate(50, 100)"></g>
                    </svg>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">ç•¶å‰æ­¥é©Ÿ</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">â† ä¸Šä¸€æ­¥</button>
                    <div class="step-indicator">æ­¥é©Ÿ <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">ä¸‹ä¸€æ­¥ â†’</button>
                    <button class="viz-btn" onclick="runVisualizer()">â†» é‡ç½®</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">â–¶ è‡ªå‹•æ’­æ”¾</button>
                    <div class="speed-control">
                        <label>é€Ÿåº¦:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">é‚è¼¯è§£é‡‹</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'ListNode* reverseKGroup(head, k) {', id: 0 },
            { line: '    dummy.next = head; groupPrev = dummy;', id: 1 },
            { line: '    while(true) {', id: 2 },
            { line: '        kth = getKth(groupPrev, k);', id: 3 },
            { line: '        if(!kth) break;', id: 4 },
            { line: '        groupNext = kth->next;', id: 5 },
            { line: '        // Reverse Group', id: 6 },
            { line: '        prev = kth->next; curr = groupPrev->next;', id: 7 },
            { line: '        while(curr != groupNext) {', id: 8 },
            { line: '            tmp = curr->next;', id: 9 },
            { line: '            curr->next = prev;', id: 10 },
            { line: '            prev = curr; curr = tmp;', id: 11 },
            { line: '        }', id: 12 },
            { line: '        // Connect', id: 13 },
            { line: '        tmp = groupPrev->next;', id: 14 },
            { line: '        groupPrev->next = kth;', id: 15 },
            { line: '        groupPrev = tmp;', id: 16 },
            { line: '    }', id: 17 },
            { line: '    return dummy.next;', id: 18 },
            { line: '}', id: 19 }
        ];

        let viz;

        function simulate(values, k) {
            const steps = [];
            
            // Initial Nodes: Dummy(0) + Values
            const nodes = [{id:0, val:'D', type:'dummy'}];
            values.forEach((v,i) => nodes.push({id:i+1, val:v, type:'norm'}));
            
            // Initial Links: 0->1, 1->2...
            let links = [];
            for(let i=0; i<nodes.length-1; i++) {
                links.push({source: nodes[i].id, target: nodes[i+1].id});
            }
            
            const pushState = (msg, hl, pointers={}, groupInfo=null, explanation=null) => {
                steps.push({
                    nodes: JSON.parse(JSON.stringify(nodes)),
                    links: JSON.parse(JSON.stringify(links)), // Links structure changes!
                    pointers: {...pointers},
                    groupInfo, // {start: nodeID, end: nodeID} to draw box
                    msg, highlightLines: hl,
                    explanation
                });
            };

            // Pointers are Node indices in 'nodes' array
            let groupPrev = 0; // Index of dummy
            pushState("Init: groupPrev = Dummy", [1], {groupPrev}, null, {
                title: 'åˆå§‹åŒ–',
                text: 'å»ºç«‹ Dummy ç¯€é»æŒ‡å‘ Headã€‚åˆå§‹åŒ– groupPrev æŒ‡å‘ Dummyã€‚<br>groupPrev æ°¸é æŒ‡å‘ç•¶å‰è¦è™•ç†çš„ Group çš„å‰ä¸€å€‹ç¯€é»ã€‚',
                formula: 'dummy.next = head'
            });

            while(true) {
                // Find Kth
                let kth = groupPrev;
                for(let i=0; i<k; i++) {
                    const nextLink = links.find(l => l.source === nodes[kth].id);
                    if(!nextLink) { kth = -1; break; } // End of list
                    // Find index of target
                    const nextIdx = nodes.findIndex(n => n.id === nextLink.target);
                    if(nextIdx === -1) { kth = -1; break; }
                    kth = nextIdx;
                }

                if(kth === -1 || kth === groupPrev) {
                    pushState("ä¸è¶³ k å€‹ç¯€é»ï¼ŒçµæŸ", [4], {groupPrev}, null, {
                        title: 'æª¢æŸ¥å‰©é¤˜ç¯€é»',
                        text: `å¾ groupPrev å¾€å¾Œæ•¸ï¼Œç™¼ç¾ä¸è¶³ k=${k} å€‹ç¯€é»ã€‚ä¸éœ€è¦åè½‰ã€‚æ¼”ç®—æ³•çµæŸã€‚`,
                        formula: 'if (!kth) break'
                    });
                    break;
                }

                pushState(`æ‰¾åˆ°ç¬¬ k å€‹ç¯€é»: ${nodes[kth].val}`, [3], {groupPrev, kth}, {start: nodes[groupPrev].id, end: nodes[kth].id}, {
                    title: 'ç¢ºèª Group ç¯„åœ',
                    text: `æˆåŠŸæ‰¾åˆ°ç¬¬ k å€‹ç¯€é» (#${nodes[kth].val})ã€‚é€™ k å€‹ç¯€é»å°‡é€²è¡Œåè½‰ã€‚<br>ç¯„åœ: groupPrev.next åˆ° kth`,
                    formula: `kth = node(${nodes[kth].val})`
                });

                // Identify Group Nodes
                // Start from groupPrev.next
                // To visualize reversal, we need to know the group range.
                // Reversal Logic:
                
                // Get groupNext (node after kth) -> actually relying on link structure
                const kthLink = links.find(l => l.source === nodes[kth].id);
                const groupNextId = kthLink ? kthLink.target : null;
                
                pushState(`GroupNext target: ${groupNextId !== null ? 'Node '+groupNextId : 'null'}`, [5], {groupPrev, kth}, {start: nodes[groupPrev].id, end: nodes[kth].id}, {
                    title: 'è¨˜éŒ„ä¸‹ä¸€çµ„é–‹é ­',
                    text: 'æš«å­˜ groupNext æŒ‡æ¨™ï¼Œä»¥ä¾¿åè½‰å¾Œé‡æ–°é€£æ¥éˆè¡¨ã€‚',
                    formula: 'groupNext = kth.next'
                });

                // Reverse Loop
                // prev starts as groupNext (conceptually null or next segment head)
                // curr starts at groupPrev.next
                
                let prevId = groupNextId; // ID
                let currLink = links.find(l => l.source === nodes[groupPrev].id);
                let currId = currLink.target;
                
                // Track start/end for viz
                const groupStartId = currId;
                const groupEndId = nodes[kth].id;

                pushState("æº–å‚™åè½‰: prev = groupNext, curr = First in Group", [7], 
                    {groupPrev, curr: nodes.findIndex(n=>n.id===currId)}, 
                    {startId: groupStartId, endId: groupEndId},
                    {
                        title: 'æº–å‚™åè½‰',
                        text: 'åˆå§‹åŒ–åè½‰æ‰€éœ€çš„æŒ‡æ¨™ï¼š<br>curr æŒ‡å‘çµ„å…§ç¬¬ä¸€å€‹ç¯€é»<br>prev åˆå§‹åŒ–ç‚º groupNext (åè½‰å¾Œï¼Œçµ„å…§ç¬¬ä¸€å€‹ç¯€é»æ‡‰é€£æ¥åˆ°ä¸‹ä¸€çµ„)',
                        formula: 'curr = groupPrev.next; prev = groupNext'
                    }
                );

                while(currId !== groupNextId && currId !== undefined && currId !== null) { // Safe check
                    // tmp = curr.next
                    const cl = links.find(l => l.source === currId);
                    const tmpId = cl ? cl.target : null;
                    
                    // curr.next = prev
                    // Update LINK
                    // Remove old link from curr
                    links = links.filter(l => l.source !== currId);
                    // Add new link curr -> prev
                    if(prevId !== null) {
                        links.push({source: currId, target: prevId, type: 'reversed'});
                    } // if null, strictly it points to null, we just show no link
                    
                    // Viz update
                    pushState(`åè½‰ ${nodes.find(n=>n.id===currId).val} æŒ‡å‘ ${prevId!==null?nodes.find(n=>n.id===prevId)?.val:'null'}`, [10], 
                        {groupPrev, curr: nodes.findIndex(n=>n.id===currId)},
                        {startId: groupStartId, endId: groupEndId},
                        {
                            title: 'åè½‰æŒ‡é‡ (Reversal)',
                            text: `å°‡ ${nodes.find(n=>n.id===currId).val} çš„ next æŒ‡é‡æŒ‡å‘å‰ä¸€å€‹ç¯€é» (prev)ã€‚<br>é€™æ˜¯æ¨™æº–çš„åè½‰éˆè¡¨æ“ä½œã€‚`,
                            formula: 'curr.next = prev'
                        }
                    );

                    // Move pointers
                    prevId = currId;
                    currId = tmpId;
                }

                // Connect
                // tmp = groupPrev.next (which is stored groupStartId)
                // groupPrev.next = kth (which was last node, now head)
                
                // Update link from groupPrev
                links = links.filter(l => l.source !== nodes[groupPrev].id);
                if(nodes[kth]) {
                    links.push({source: nodes[groupPrev].id, target: nodes[kth].id});
                }
                
                pushState("é€£æ¥: groupPrev -> New Head (kth)", [15], 
                    {groupPrev},
                    {startId: groupStartId, endId: groupEndId},
                    {
                        title: 'é€£æ¥ Group é ­éƒ¨',
                        text: `åè½‰å®Œæˆå¾Œï¼ŒåŸä¾†çš„ç¬¬ k å€‹ç¯€é»è®Šæˆäº†æ–°çš„é ­ã€‚<br>è®“ groupPrev æŒ‡å‘é€™å€‹æ–°é ­ (${nodes[kth].val})ã€‚`,
                        formula: 'groupPrev.next = kth'
                    }
                );

                // groupPrev = tmp (old first)
                groupPrev = nodes.findIndex(n => n.id === groupStartId);
                
                pushState("ç§»å‹• groupPrev åˆ°æœ¬çµ„å°¾éƒ¨", [16], {groupPrev}, null, {
                    title: 'æ›´æ–° groupPrev',
                    text: `æœ¬çµ„åŸä¾†çš„é ­ (${nodes[groupPrev].val}) ç¾åœ¨è®Šæˆäº†å°¾éƒ¨ã€‚<br>å°‡ groupPrev æ›´æ–°åˆ°æ­¤ä½ç½®ï¼Œæº–å‚™è™•ç†ä¸‹ä¸€çµ„ã€‚`,
                    formula: 'groupPrev = original_head'
                });
            }
            
            return steps;
        }

        const svg = d3.select("#viz-svg");
        const gMain = d3.select("#main-group");
        const gOverlay = d3.select("#overlay-group");

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;

            // Layout
            // Linear Layout based on current structure? 
            // Or fixed standard layout? 
            // Reversal changes structure. 
            // Let's use a fixed layout for nodes initially to avoid chaotic movement, 
            // but update links to show reversal.
            // Nodes don't move x,y. Links curve back.
            
            const SPACING = 70;
            step.nodes.forEach((n, i) => {
                n.x = i * SPACING;
                n.y = 0;
            });

            // Group Box
            gOverlay.selectAll(".group-box").remove();
            gOverlay.selectAll(".group-label").remove();
            if(step.groupInfo && step.groupInfo.startId) {
                const sNode = step.nodes.find(n => n.id === step.groupInfo.startId);
                const eNode = step.nodes.find(n => n.id === step.groupInfo.endId);
                if(sNode && eNode) {
                    const minX = Math.min(sNode.x, eNode.x) - 30;
                    const maxX = Math.max(sNode.x, eNode.x) + 30;
                    const w = maxX - minX;
                    gOverlay.append("rect").attr("class", "group-box")
                        .attr("x", minX).attr("y", -40)
                        .attr("width", w).attr("height", 80);
                    gOverlay.append("text").attr("class", "group-label")
                        .attr("x", (minX+maxX)/2).attr("y", -45)
                        .attr("text-anchor", "middle").text("Current k-Group");
                }
            }

            // Links
            // Map link target IDs to objects
            const nodeMap = new Map(step.nodes.map(n=>[n.id, n]));
            const linkData = step.links.map(l => ({
                s: nodeMap.get(l.source),
                t: nodeMap.get(l.target),
                type: l.type
            })).filter(l => l.s && l.t);

            const lSel = gMain.selectAll(".link").data(linkData, d => d.s.id + "-" + d.t.id);
            lSel.enter().append("path").attr("class", "link")
                .merge(lSel)
                .transition().duration(500)
                .attr("d", d => {
                    const dist = Math.abs(d.s.x - d.t.x);
                    if(dist > SPACING + 10) {
                        // Curve
                        return `M ${d.s.x+20},0 Q ${(d.s.x+d.t.x)/2},${d.s.x < d.t.x ? 50 : 50} ${d.t.x-25},0`; // always curve down?
                    }
                    return `M ${d.s.x+20},0 L ${d.t.x-25},0`;
                })
                .attr("marker-end", "url(#arrow)")
                .attr("class", d => d.type === 'reversed' ? "link reversed" : "link");
            lSel.exit().remove();

            // Nodes
            const nSel = gMain.selectAll(".node-g").data(step.nodes, d => d.id);
            const nEnter = nSel.enter().append("g").attr("class", "node-g");
            nEnter.append("circle").attr("r", 20).attr("class", "node-circle");
            nEnter.append("text").attr("class", "node-text").attr("dy", 1);
            
            const nUpdate = nSel.merge(nEnter).attr("transform", d => `translate(${d.x}, ${d.y})`);
            
            nUpdate.select("circle").attr("class", d => {
                let c = "node-circle";
                if(d.type==='dummy') c+=" dummy";
                // Ptr highlighting
                Object.values(step.pointers).forEach(idx => {
                    if(idx !== -1 && step.nodes[idx] && step.nodes[idx].id === d.id) c+= " active"; 
                });
                return c;
            })
            .style("stroke-width", 3);

            nUpdate.select("text").text(d => d.val);
            nSel.exit().remove();

            // Pointers
            const ptrData = [];
            Object.keys(step.pointers).forEach(key => {
                const idx = step.pointers[key];
                if(idx !== undefined && idx !== -1 && step.nodes[idx]) {
                    ptrData.push({label: key, x: step.nodes[idx].x, y: 0});
                }
            });
            
            // Adjust y for stacking? simple implementation first
            const pSel = gOverlay.selectAll(".ptr-g").data(ptrData, d=>d.label);
            const pEnter = pSel.enter().append("g").attr("class", "ptr-g");
            pEnter.append("path").attr("d", "M0,0 L-5,10 L5,10 Z").attr("fill", "#fbbf24");
            pEnter.append("text").attr("class", "ptr-label").attr("y", 22);
            
            const pUpdate = pSel.merge(pEnter)
                .transition().duration(400)
                .attr("transform", (d, i) => `translate(${d.x}, ${d.y + 25 + i*15}) rotate(180)`); // Stack down
            
            pUpdate.select("text").text(d => d.label).attr("transform", "rotate(180) translate(0, 10)"); // fix text
            pSel.exit().remove();
        }

        function runVisualizer() {
            const vals = document.getElementById('nodesInput').value.split(',').map(x=>parseInt(x.trim())).filter(n=>!isNaN(n));
            const k = parseInt(document.getElementById('kInput').value);
            
            if(vals.length < 1 || k < 1) return;
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(vals, k));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
