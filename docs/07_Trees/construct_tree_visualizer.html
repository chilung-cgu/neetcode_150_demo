<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Construct Binary Tree - D3 Dynamic Viz</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            min-height: 600px;
        }

        /* SVG */
        .stage-viewport {
            width: 100%; height: 400px;
            background: rgba(30, 41, 59, 0.4);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(148, 163, 184, 0.2);
            position: relative;
        }
        #viz-svg { width: 100%; height: 100%; }

        /* Nodes */
        .node-circle { stroke-width: 2px; transition: all 0.5s; fill: #334155; stroke: #64748b; opacity: 0; } 
        .node-visible { opacity: 1; }
        .node-active { stroke: #fbbf24; fill: rgba(251, 191, 36, 0.2); stroke-width: 3px; }
        .node-done { fill: #1e293b; stroke: #22c55e; }

        .node-text { fill: white; font-weight: bold; font-family: monospace; font-size: 14px; text-anchor: middle; dominant-baseline: middle; opacity: 0; pointer-events: none; }
        .text-visible { opacity: 1; }
        
        .link-path { fill: none; stroke: #64748b; stroke-width: 2px; transition: all 0.5s; opacity: 0; }
        .link-visible { opacity: 0.6; }

        /* Array Visualization */
        .arrays-panel {
            display: flex; flex-direction: column; gap: 10px; width: 95%;
            background: rgba(15, 23, 42, 0.6); padding: 10px; border-radius: 8px; border: 1px solid #475569;
        }
        .array-row { display: flex; align-items: center; gap: 10px; }
        .array-lbl { width: 70px; text-align: right; color: #94a3b8; font-size: 0.8rem; font-weight: bold; }
        .array-bar { display: flex; gap: 5px; overflow-x: auto; padding-bottom: 5px; }
        .cell {
            width: 30px; height: 30px; border: 1px solid #475569; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            color: #cbd5e1; font-family: monospace; font-size: 0.9rem;
            transition: all 0.3s;
        }
        .cell.focus { background: rgba(59, 130, 246, 0.2); border-color: #3b82f6; color: white; } /* Current Range */
        .cell.root { background: #fbbf24; border-color: #f59e0b; color: #0f172a; font-weight: bold; transform: scale(1.1); } /* Selected Root */
        .cell.dim { opacity: 0.2; } /* Out of range */

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; justify-content: center; }
        input[type=text] { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 220px; }
        button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; font-weight: 600; height: 40px; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; width: 100%; box-sizing: border-box; }
        
        .legend { display: flex; gap: 15px; font-size: 0.8rem; color: #cbd5e1; margin-bottom: 5px; justify-content: center; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Construct Binary Tree</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <div>
                            <label style="font-size:0.8rem; color:#94a3b8;">Preorder:</label>
                            <input type="text" id="preInput" value="3,9,20,15,7">
                        </div>
                        <div>
                            <label style="font-size:0.8rem; color:#94a3b8;">Inorder:</label>
                            <input type="text" id="inInput" value="9,3,15,20,7">
                        </div>
                        <div style="display:flex; flex-direction:column; gap:5px;">
                            <button onclick="runVisualizer()">Build</button>
                        </div>
                    </div>
                </div>

                <div class="visualization-area">
                    <div class="arrays-panel">
                        <div class="array-row">
                            <div class="array-lbl">Preorder</div>
                            <div class="array-bar" id="preDisp"></div>
                        </div>
                        <div class="array-row">
                            <div class="array-lbl">Inorder</div>
                            <div class="array-bar" id="inDisp"></div>
                        </div>
                    </div>

                    <div class="legend">
                       <div class="legend-item"><div class="legend-color" style="background:rgba(59,130,246,0.2); border:1px solid #3b82f6"></div>Active Range</div>
                       <div class="legend-item"><div class="legend-color" style="background:#fbbf24"></div>Selected Root</div>
                    </div>

                    <div class="stage-viewport">
                        <svg id="viz-svg">
                            <g id="main-group" transform="translate(40, 40)"></g>
                        </svg>
                    </div>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn" onclick="runVisualizer()">‚Üª ÈáçÁΩÆ</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">2x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card logic-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'TreeNode* buildTree(preorder, inorder) {', id: 0 },
            { line: '    if (preorder.empty() || inorder.empty()) return NULL;', id: 1 },
            { line: '    TreeNode* root = new TreeNode(preorder[0]);', id: 2 },
            { line: '    int mid = find(inorder, preorder[0]);', id: 3 },
            { line: '    root->left = buildTree(preorder[1:mid+1], inorder[0:mid]);', id: 4 },
            { line: '    root->right = buildTree(preorder[mid+1:], inorder[mid+1:]);', id: 5 },
            { line: '    return root;', id: 6 },
            { line: '}', id: 7 }
        ];

        let viz;

        // We pre-calculate final tree layout to place nodes correctly, 
        // but only reveal them as constructed.
        function buildTreeLogic(pre, inord) {
            if(!pre.length || !inord.length) return null;
            let rootVal = pre[0];
            let root = { val: rootVal, id: Math.random(), left: null, right: null };
            let mid = inord.indexOf(rootVal);
            root.left = buildTreeLogic(pre.slice(1, mid+1), inord.slice(0, mid));
            root.right = buildTreeLogic(pre.slice(mid+1), inord.slice(mid+1));
            return root;
        }

        function getLayout(rootNode) {
            if(!rootNode) return [];
            const h = d3.hierarchy(rootNode);
            const treeLayout = d3.tree().size([500, 300]);
            treeLayout(h);
            const nodes = [];
            h.descendants().forEach(d => {
                nodes.push({
                    id: d.data.id, val: d.data.val,
                    x: d.x + 50, y: d.y + 50,
                    parentId: d.parent ? d.parent.data.id : null
                });
            });
            return nodes;
        }

        function simulate(pre, inord) {
            const steps = [];
            const fullTree = buildTreeLogic(pre, inord);
            if(!fullTree) return [];
            const layout = getLayout(fullTree); // static positions
            
            // Map: id -> visible (bool)
            // also tracking active node
            let visibleSet = new Set();
            
            const snap = (rangePre, rangeIn, activeRootVal, activeId, msg, lines, info) => ({
                layout,
                visibleSet: new Set(visibleSet),
                preFull: pre, 
                inFull: inord,
                rangePre, rangeIn, // {start, end} indices
                activeRootVal, activeId,
                msg, highlightLines: lines, explanation: info
            });

            // Recursive construction simulation
            // We pass global indices to slice arrays visually
            
            const construct = (pStart, pEnd, iStart, iEnd) => {
                // pStart inclusive, pEnd exclusive
                
                if (pStart >= pEnd || iStart >= iEnd) {
                    steps.push(snap({s:pStart, e:pEnd}, {s:iStart, e:iEnd}, null, null, "Base Case: Range Empty. Return NULL.", [1], {
                        title: "Base Case", text: "Èô£ÂàóÁØÑÂúçÁÇ∫Á©∫ÔºåËøîÂõû NULL„ÄÇ", formula: "return NULL"
                    }));
                    return null;
                }
                
                const rootVal = pre[pStart];
                // Find visible node ID
                const node = layout.find(n => n.val === rootVal && !visibleSet.has(n.id)); 
                // Note: duplicates handling is tricky. We assume unique for simplicity or use layout search path.
                // Assuming unique for visualization simplicity as standard problem.
                const nodeId = node ? node.id : null;
                
                steps.push(snap({s:pStart, e:pEnd}, {s:iStart, e:iEnd}, rootVal, null, `Root is preorder[${pStart}] = ${rootVal}`, [2], {
                    title: "ÈÅ∏ÊìáÊ†πÁØÄÈªû", text: `Preorder Á¨¨‰∏ÄÂÄãÂÖÉÁ¥† ${rootVal} ÁÇ∫Áï∂ÂâçÂ≠êÊ®πÁöÑÊ†π„ÄÇ`, formula: "root = pre[0]"
                }));
                
                if(nodeId) visibleSet.add(nodeId);
                
                // Find in Inorder
                let mid = -1;
                for(let k=iStart; k<iEnd; k++) {
                    if (inord[k] === rootVal) { mid = k; break; }
                }
                
                steps.push(snap({s:pStart, e:pEnd}, {s:iStart, e:iEnd}, rootVal, nodeId, `Found ${rootVal} at Inorder[${mid}]`, [3], {
                    title: "Âú®‰∏≠Â∫è‰∏≠Â∞ãÊâæ", text: `Âú®‰∏≠Â∫èÈÅçÊ≠∑‰∏≠ÊâæÂà∞ ${rootVal} ÁöÑ‰ΩçÁΩÆ (Index ${mid})„ÄÇÂ∑¶ÈÇäÊòØÂ∑¶Â≠êÊ®πÔºåÂè≥ÈÇäÊòØÂè≥Â≠êÊ®π„ÄÇ`, formula: "mid = find(inorder, root)"
                }));
                
                const leftSize = mid - iStart;
                
                // Left
                steps.push(snap({s:pStart+1, e:pStart+1+leftSize}, {s:iStart, e:mid}, null, nodeId, `Recurse Left (Size ${leftSize})`, [4], {
                    title: "ÊßãÂª∫Â∑¶Â≠êÊ®π", text: `ÈÅûÊ≠∏ÊßãÂª∫Â∑¶Â≠êÊ®π„ÄÇPreorder Âèñ ${leftSize} ÂÄãÂÖÉÁ¥†ÔºåInorder Âèñ root Â∑¶ÂÅ¥ÂÖÉÁ¥†„ÄÇ`, formula: "build(left)"
                }));
                construct(pStart+1, pStart+1+leftSize, iStart, mid);
                
                // Right
                steps.push(snap({s:pStart+1+leftSize, e:pEnd}, {s:mid+1, e:iEnd}, null, nodeId, `Recurse Right`, [5], {
                    title: "ÊßãÂª∫Âè≥Â≠êÊ®π", text: `ÈÅûÊ≠∏ÊßãÂª∫Âè≥Â≠êÊ®π„ÄÇÂèñÂâ©È§òÂÖÉÁ¥†„ÄÇ`, formula: "build(right)"
                }));
                construct(pStart+1+leftSize, pEnd, mid+1, iEnd);
                
                steps.push(snap({s:pStart, e:pEnd}, {s:iStart, e:iEnd}, rootVal, nodeId, `Subtree ${rootVal} Done`, [6], {
                    title: "Â≠êÊ®πÂÆåÊàê", text: `‰ª• ${rootVal} ÁÇ∫Ê†πÁöÑÂ≠êÊ®πÊßãÂª∫ÂÆåÊàê„ÄÇ`, formula: "return root"
                }));
            }

            construct(0, pre.length, 0, inord.length);
            
            steps.push(snap({s:0,e:0}, {s:0,e:0}, null, null, "Construction Complete", [7], {
                 title: "ÂÆåÊàê", text: "Êï¥Ê£µÊ®πÊßãÂª∫ÂÆåÁï¢„ÄÇ", formula: "Done"
            }));

            return steps;
        }

        const svg = d3.select("#viz-svg");
        const mainG = svg.select("#main-group");
        
        function render(step) {
            document.getElementById('stepText').textContent = step.msg;
            if (step.explanation) {
                document.getElementById('explanation').innerHTML = `
                    <div class="expl-title">${step.explanation.title}</div>
                    <div class="expl-text">${step.explanation.text}</div>
                    <div class="expl-formula">${step.explanation.formula}</div>
                `;
            }
            
            // Render Arrays
            const renderArray = (containerId, arr, range, activeVal) => {
                const c = document.getElementById(containerId);
                c.innerHTML = '';
                arr.forEach((v, i) => {
                    const el = document.createElement('div');
                    el.className = 'cell';
                    if (i >= range.s && i < range.e) {
                         el.className += ' focus';
                         if (v === activeVal) el.className += ' root';
                    } else {
                        el.className += ' dim';
                    }
                    el.textContent = v;
                    c.appendChild(el);
                });
            };
            
            renderArray('preDisp', step.preFull, step.rangePre, step.activeRootVal);
            renderArray('inDisp', step.inFull, step.rangeIn, step.activeRootVal);

            const nodesData = step.layout;
            
            // Links
            const linksData = nodesData.filter(d => d.parentId !== null).map(d => {
                const p = nodesData.find(x => x.id === d.parentId);
                return { s: p, t: d, id: `${p.id}-${d.id}` };
            });

            const linkSel = mainG.selectAll(".link-path").data(linksData, d => d.id);
            const linkEnter = linkSel.enter().append("path").attr("class", "link-path");
            linkSel.merge(linkEnter).transition().duration(500)
                .attr("d", d => `M${d.s.x},${d.s.y} L${d.t.x},${d.t.y}`)
                .attr("class", d => {
                    // Start node visible AND end node visible?
                    const sVis = step.visibleSet.has(d.s.id);
                    const tVis = step.visibleSet.has(d.t.id);
                    return (sVis && tVis) ? "link-path link-visible" : "link-path";
                });
            linkSel.exit().remove();
            
            // Nodes
            const nodeSel = mainG.selectAll(".node-g").data(nodesData, d => d.id);
            const nodeEnter = nodeSel.enter().append("g").attr("class", "node-g");
            nodeEnter.append("circle").attr("class", "node-circle").attr("r", 18);
            nodeEnter.append("text").attr("class", "node-text").attr("dy", 1);
            
            const nodeMerge = nodeSel.merge(nodeEnter).transition().duration(500)
                .attr("transform", d => `translate(${d.x}, ${d.y})`);
            
            nodeMerge.select("circle").attr("class", d => {
                let c = "node-circle";
                if(step.visibleSet.has(d.id)) {
                    c += " node-visible";
                    if(d.id === step.activeId) c += " node-active";
                    else c += " node-done";
                }
                return c;
            });
            nodeMerge.select("text").attr("class", d => step.visibleSet.has(d.id) ? "node-text text-visible" : "node-text")
                .text(d => d.val);
            nodeSel.exit().remove();
        }

        function runVisualizer() {
            const rawP = document.getElementById('preInput').value;
             const valsP = rawP.split(',').map(x => {
                const t = x.trim().toLowerCase();
                if(t==='null' || t==='') return null;
                return isNaN(parseInt(t)) ? null : parseInt(t);
            });
            const rawI = document.getElementById('inInput').value;
             const valsI = rawI.split(',').map(x => {
                const t = x.trim().toLowerCase();
                if(t==='null' || t==='') return null;
                return isNaN(parseInt(t)) ? null : parseInt(t);
            });
            
            if(valsP.length === 0 || valsI.length === 0) return;
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(valsP, valsI));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
