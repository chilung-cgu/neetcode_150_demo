<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode 84 Visualization</title>
    <!-- 引入共用樣式 -->
    <link rel="stylesheet" href="../assets/visualizer/style.css">
</head>
<body>
    <div class="main-layout">
        <!-- Left Column: Visualization -->
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">HISTOGRAM VISUALIZATION</div>
                <div class="chart-container" id="chartContainer">
                    <!-- Bars generated by JS -->
                </div>

                <div class="controls">
                    <button class="viz-btn" id="prevBtn">← Prev</button>
                    <div class="step-indicator">
                        Step <span id="currentStep">0</span> / <span id="totalSteps">0</span>
                    </div>
                    <button class="viz-btn primary" id="nextBtn">Next →</button>
                    <button class="viz-btn" onclick="resetVisualization()">↻ Reset</button>
                </div>
                <div class="controls-row-2">
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">▶ 自動播放</button>
                    <div class="speed-control">
                        <label>速度:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="2000">0.5x</option>
                            <option value="1500" selected>1x</option>
                            <option value="1000">1.5x</option>
                            <option value="500">2x</option>
                        </select>
                    </div>
                </div>

                
                <div class="state-grid">
                    <div class="state-item">
                        <div class="state-label">Stack (Indices)</div>
                        <div class="state-value" id="stackDisplay" style="color: var(--viz-success);">[ ]</div>
                    </div>
                    <div class="state-item">
                        <div class="state-label">Max Area</div>
                        <div class="state-value" id="maxAreaDisplay" style="color: var(--viz-secondary);">0</div>
                    </div>
                </div>
            </div>

            <div class="viz-card">
                <div class="viz-title">EXPLANATION</div>
                <div class="explanation" id="explanation">
                    <!-- Dynamic text -->
                </div>
            </div>
        </div>

        <!-- Right Column: Code -->
        <div class="code-area">
            <div class="viz-card" style="height: 100%; box-sizing: border-box;">
                <div class="viz-title">ALGORITHM (C++)</div>
                <div class="code-panel" id="codeDisplay">
                    <!-- Code lines generated by JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- 引入共用核心邏輯 -->
    <script src="../assets/visualizer/core.js"></script>
    
    <!-- 題目特定邏輯 -->
    <script>
        // 1. 定義程式碼
        const codeStructure = [
            { line: 'int largestRectangleArea(vector<int>& H) {', id: 0 },
            { line: '    stack<int> st;', id: 1 },
            { line: '    int maxArea = 0;', id: 2 },
            { line: '    H.push_back(0); // Sentinel', id: 3 },
            { line: '', id: 4 },
            { line: '    for (int i = 0; i < H.size(); i++) {', id: 5 },
            { line: '        while (!st.empty() && H[st.top()] > H[i]) {', id: 6 },
            { line: '            int h = H[st.top()]; st.pop();', id: 7 },
            { line: '            int w = st.empty() ? i : i - st.top() - 1;', id: 8 },
            { line: '            maxArea = max(maxArea, h * w);', id: 9 },
            { line: '        }', id: 10 },
            { line: '        st.push(i);', id: 11 },
            { line: '    }', id: 12 },
            { line: '    return maxArea;', id: 13 },
            { line: '}', id: 14 },
        ];

        // 2. 定義演算法產生步驟
        function generateAlgorithmSteps(heightsOriginal) {
            // Copy to avoid mutation issues
            const heights = [...heightsOriginal];
            const steps = [];
            const stack = [];
            let maxArea = 0;
            
            // Add sentinel to data directly for simulation
            // In C++ code we showed push_back(0), so let's simulate that logic
            heights.push(0); 
            const n = heights.length;

            steps.push({
                stack: [...stack],
                maxArea,
                highlightLines: [0, 1, 2, 3],
                explanation: { 
                    title: 'Initialization', 
                    text: '初始化堆疊與最大面積變數。我們在陣列末端加入高度為 0 的哨兵 (Sentinel)，確保最後所有柱子都能被結算。' 
                },
                barStates: heights.map((h, i) => i === n-1 ? 'calculating' : 'normal')
            });

            for (let i = 0; i < n; i++) {
                const currentDiff = i === n-1 ? 'Sentinel (0)' : heights[i];
                
                let barStates = heights.map(h => 'normal');
                stack.forEach(idx => barStates[idx] = 'in-stack');
                barStates[i] = 'current';

                steps.push({
                    stack: [...stack],
                    maxArea,
                    highlightLines: [5, 6],
                    explanation: { 
                        title: `Iteration i = ${i}`, 
                        text: `目前高度: <strong>${currentDiff}</strong>。檢查堆疊頂部是否大於目前高度？` 
                    },
                    barStates: [...barStates],
                    currIndex: i
                });

                while (stack.length > 0 && heights[stack[stack.length - 1]] > heights[i]) {
                    const topIdx = stack.pop();
                    const h = heights[topIdx];
                    const w = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;
                    const area = h * w;
                    maxArea = Math.max(maxArea, area);

                    const popStates = heights.map(h => 'normal');
                    stack.forEach(idx => popStates[idx] = 'in-stack');
                    popStates[topIdx] = 'calculating'; // The one being popped
                    popStates[i] = 'current';          // The one forcing the pop

                    steps.push({
                        stack: [...stack],
                        maxArea,
                        highlightLines: [7, 8, 9],
                        explanation: { 
                            title: `Pop & Calculate`, 
                            text: `Index ${topIdx} (H=${h}) 被 Index ${i} (H=${heights[i]}) 擋住。`,
                            formula: `Area = H(${h}) × W(${w}) = ${area}` 
                        },
                        barStates: popStates,
                        currIndex: i
                    });
                }

                stack.push(i);
                
                // State after push
                const pushStates = heights.map(h => 'normal');
                stack.forEach(idx => pushStates[idx] = 'in-stack');
                
                steps.push({
                    stack: [...stack],
                    maxArea,
                    highlightLines: [11],
                    explanation: { 
                        title: `Push Index ${i}`, 
                        text: `將 Index ${i} 推入堆疊，維持單調遞增特性。` 
                    },
                    barStates: pushStates,
                    currIndex: i
                });
            }

            steps.push({
                stack: [...stack],
                maxArea,
                highlightLines: [13],
                explanation: { title: 'Finished', text: `演算法結束，回傳最大面積：${maxArea}` },
                barStates: heights.map(h => 'normal')
            });

            return steps;
        }

        // 3. 初始化 Visualizer
        let viz;
        const initialHeights = [2, 1, 5, 6, 2, 3];

        function init() {
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: (step, data) => {
                    // Render Bars
                    // Note: Our logic added a 0 at the end, so we pass that extended array logic
                    // Or for visual purity, we can just render the original array + sentinel logic
                    // Let's pass the array used in simulation which includes existing 0 sentinel
                    // The standard visualizer expects raw heights.
                    // For simply logic, let's keep it consistent with the simulation data (length + 1)
                    
                    // Display Stack
                    document.getElementById('stackDisplay').textContent = 
                        step.stack.length ? `[ ${step.stack.join(', ')} ]` : '[ ]';
                    
                    // Display Max Area
                    document.getElementById('maxAreaDisplay').textContent = step.maxArea;

                    // Render Chart
                    // We need to know the heights (original + sentinel)
                    const displayHeights = [...initialHeights, 0];
                    AlgorithmVisualizer.renderBars(
                        document.getElementById('chartContainer'),
                        displayHeights,
                        step.barStates || [],
                        { height: 260 }
                    );
                }
            });

            const steps = generateAlgorithmSteps(initialHeights);
            viz.setSteps(steps);
        }

        function resetVisualization() {
            init(); // Re-run logic
        }

        // Start
        window.addEventListener('load', init);

    </script>
</body>
</html>
