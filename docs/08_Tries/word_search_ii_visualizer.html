<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Search II - Á≤æÁ∑ªË¶ñË¶∫Âåñ</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        .dual-view {
            display: flex; gap: 20px; width: 100%; justify-content: center; flex-wrap: wrap;
        }
        
        .view-panel {
            background: rgba(30, 41, 59, 0.4); border-radius: 12px; padding: 10px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            display: flex; flex-direction: column; align-items: center;
        }
        .view-title { font-size: 0.9rem; color: #94a3b8; margin-bottom: 10px; font-weight: bold; }

        /* Grid View */
        .grid-container {
            display: inline-grid; gap: 4px; 
        }
        .cell {
            width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;
            background: #334155; border-radius: 4px; font-weight: bold; color: #cbd5e1;
            transition: all 0.3s;
        }
        .cell.visiting { background: #fbbf24; color: #0f172a; transform: scale(1.1); box-shadow: 0 0 10px rgba(251, 191, 36, 0.5); }
        .cell.backtrack { background: #ef4444; opacity: 0.7; }
        .cell.found { background: #22c55e; color: white; }
        .cell.path { border: 2px solid #60a5fa; }

        /* Trie View (Svg) */
        #trie-svg { width: 300px; height: 300px; background: transparent; }
        
        .trie-node { fill: #3b82f6; stroke: none; transition: all 0.3s; }
        .trie-node.current { fill: #fbbf24; filter: drop-shadow(0 0 5px #fbbf24); }
        .trie-node.match { fill: #22c55e; stroke: #fff; stroke-width: 2px; }
        .trie-node.root { fill: #64748b; }
        .trie-text { fill: white; font-family: monospace; font-size: 10px; pointer-events: none; text-anchor: middle; dominant-baseline: middle; }
        
        .trie-link { stroke: #64748b; stroke-width: 1.5px; opacity: 0.3; }
        .trie-link.active { stroke: #fbbf24; stroke-width: 2px; opacity: 1; }

        /* Result List */
        .found-words { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; min-height: 30px; }
        .word-tag { padding: 4px 10px; background: rgba(34, 197, 94, 0.2); border: 1px solid #22c55e; border-radius: 12px; color: #4ade80; font-size: 0.8rem; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; margin-bottom: 5px; }
        .input-row textarea { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 120px; height: 50px; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 150px; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; font-weight: 600; height: 40px; }

        .step-breakdown {
            background: rgba(30, 41, 59, 0.6);
            border-radius: 12px;
            padding: 15px 20px;
            border-left: 4px solid #3b82f6;
            margin-top: 15px;
            width: 100%; box-sizing: border-box;
        }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Word Search II (Trie + DFS)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <div>
                            <label>Grid (csv):</label>
                            <textarea id="boardInput">o,a,a,n
e,t,a,e
i,h,k,r
i,f,l,v</textarea>
                        </div>
                        <div>
                            <label>Words (comma):</label>
                            <input type="text" id="wordsInput" value="oath,pea,eat,rain">
                        </div>
                        <button onclick="runVisualizer()">ÈñãÂßãÊêúÂ∞ã</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <div class="dual-view">
                        <div class="view-panel">
                            <div class="view-title">Grid (DFS Ë®™Âïè)</div>
                            <div class="grid-container" id="gridDisplay"></div>
                        </div>
                        <div class="view-panel">
                            <div class="view-title">Trie (ÂâçÁ∂¥ÂåπÈÖç)</div>
                            <svg id="trie-svg">
                                <g id="zoom-layer"></g> 
                            </svg>
                        </div>
                    </div>
                    
                    <div style="margin-top: 10px; color: #94a3b8; font-size: 0.9rem;">Â∑≤ÊâæÂà∞ÂñÆË©û:</div>
                    <div class="found-words" id="foundDisplay"></div>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn" onclick="runVisualizer()">‚Üª ÈáçÁΩÆ</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="800" selected>1x</option>
                            <option value="300">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="viz-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <!-- D3.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'void findWords(board, words) {', id: 0 },
            { line: '    Trie* root = buildTrie(words);', id: 1 },
            { line: '    for(int r=0; r<rows; r++)', id: 2 },
            { line: '        for(int c=0; c<cols; c++)', id: 3 },
            { line: '            dfs(r, c, root);', id: 4 },
            { line: '}', id: 5 },
            { line: 'void dfs(r, c, node) {', id: 6 },
            { line: '    char ch = board[r][c];', id: 7 },
            { line: '    if (!node->children[ch]) return;', id: 8 },
            { line: '    node = node->children[ch];', id: 9 },
            { line: '    if (node->word) {', id: 10 },
            { line: '        res.push_back(node->word);', id: 11 },
            { line: '        node->word = null; // Dedup', id: 12 },
            { line: '    }', id: 13 },
            { line: '    board[r][c] = \'#\'; // Visited', id: 14 },
            { line: '    dfs(r+1, c, node); dfs(r-1, c, node); ...', id: 15 },
            { line: '    board[r][c] = ch; // Backtrack', id: 16 },
            { line: '}', id: 17 }
        ];

        let viz;
        let idCounter = 0;

        // --- Trie Logic ---
        function buildDetailedTrie(words) {
            const root = { id: 'root', char: '', children: {}, word: null };
            let cnt = 0;
            for(let w of words) {
                let curr = root;
                for(let c of w) {
                    if(!curr.children[c]) {
                        curr.children[c] = { id: `t-${++cnt}`, char: c, children: {}, word: null };
                    }
                    curr = curr.children[c];
                }
                curr.word = w;
            }
            return root;
        }

        function generateSteps(boardInput, wordsInput) {
            const steps = [];
            const board = boardInput.map(row => [...row]);
            const R = board.length, C = board[0].length;
            const root = buildDetailedTrie(wordsInput);
            
            // Initial Step
            steps.push({
                board: JSON.parse(JSON.stringify(board)),
                root: JSON.parse(JSON.stringify(root)), // snapshot trie state
                trieActive: 'root',
                gridActive: null,
                found: [],
                highlightLines: [1],
                msg: "ÊßãÂª∫ Trie ÂÆåÁï¢ÔºåÊ∫ñÂÇôÈñãÂßã DFS"
            });

            const foundWords = [];

            const dfs = (r, c, trieNodePath) => {
                // Get current trie node from path (last id)
                // Need to traverse our snapshot structure? 
                // Simulation uses the real `root` object structure we built.
                
                // For visualization, we need the ID of the current trie node
                let currNode = root;
                for(let i=1; i<trieNodePath.length; i++) {
                    // This logic is tricky. Instead of re-traversing, let's pass the node object in recursion?
                    // Yes, but for step snapshot we need IDs.
                }
                // Simpler: pass currNode in recursion
            };
            
            // Re-implement simplified DFS with step recording
            
            const runDFS = (r, c, node) => {
                const char = board[r][c];
                // Check Trie
                if (!node.children[char]) return;
                
                const nextNode = node.children[char];
                
                // Step: Moving to grid cell and trie node
                steps.push({
                    board: JSON.parse(JSON.stringify(board)),
                    root: root, // Structure doesn't change, passing ref is okay if we don't mutate structure (we do mutate node.word)
                    // Actually we mutate node.word to null for dedup. Better deep copy root or track found words separately.
                    // Let's track found separately.
                    trieActive: nextNode.id,
                    gridActive: { r, c },
                    found: [...foundWords],
                    highlightLines: [7, 8, 9],
                    msg: `Grid (${r},${c}) '${char}' ÂåπÈÖç Trie ÁØÄÈªû`
                });

                if (nextNode.word) {
                    foundWords.push(nextNode.word);
                    const w = nextNode.word;
                    nextNode.word = null; // Dedup in simulation
                    
                    steps.push({
                        board: JSON.parse(JSON.stringify(board)), // needed?
                        trieActive: nextNode.id,
                        gridActive: { r, c },
                        found: [...foundWords],
                        highlightLines: [10, 11, 12],
                        msg: `ÊâæÂà∞ÂñÆË©û: "${w}"ÔºÅ`
                    });
                }

                const temp = board[r][c];
                board[r][c] = '#';
                
                steps.push({
                    board: JSON.parse(JSON.stringify(board)),
                    found: [...foundWords],
                    trieActive: nextNode.id,
                    gridActive: { r, c, visited: true },
                    highlightLines: [14],
                    msg: `Ê®ôË®ò (${r},${c}) ÁÇ∫ Visited`
                });

                const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                for (let [dr, dc] of dirs) {
                    const nr = r + dr, nc = c + dc;
                    if (nr >= 0 && nr < R && nc >= 0 && nc < C && board[nr][nc] !== '#') {
                        if (nextNode.children[board[nr][nc]]) { // Optimization: only recurse if trie has path
                             runDFS(nr, nc, nextNode);
                        }
                    }
                }

                board[r][c] = temp;
                steps.push({
                    board: JSON.parse(JSON.stringify(board)),
                    found: [...foundWords],
                    trieActive: node.id, // Back to parent
                    gridActive: { r, c, backtrack: true },
                    highlightLines: [16],
                    msg: `ÂõûÊ∫Ø (${r},${c})`
                });
            };

            for(let r=0; r<R; r++) {
                for(let c=0; c<C; c++) {
                    if (root.children[board[r][c]]) {
                        runDFS(r, c, root);
                    }
                }
            }
            
            steps.push({
                board: JSON.parse(JSON.stringify(board)),
                root: root,
                trieActive: 'root',
                found: [...foundWords],
                highlightLines: [5],
                msg: "ÊêúÂ∞ãÂÆåÊàê"
            });

            return { steps, root };
        }

        // --- Render ---
        const svg = d3.select("#trie-svg");
        const gLayer = d3.select("#zoom-layer");
        const zoom = d3.zoom().on("zoom", (e) => gLayer.attr("transform", e.transform));
        svg.call(zoom);
        
        // Initial Zoom transform
        svg.call(zoom.transform, d3.zoomIdentity.translate(150, 20).scale(0.8));

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;
            document.getElementById('foundDisplay').innerHTML = step.found.map(w => `<span class="word-tag">${w}</span>`).join('');

            // Render Grid
            const gridC = document.getElementById('gridDisplay');
            if(step.board) {
                gridC.style.gridTemplateColumns = `repeat(${step.board[0].length}, 40px)`;
                gridC.innerHTML = '';
                for(let r=0; r<step.board.length; r++) {
                    for(let c=0; c<step.board[0].length; c++) {
                        let cls = 'cell';
                        const val = step.board[r][c];
                        if (step.gridActive) {
                            if (step.gridActive.r === r && step.gridActive.c === c) {
                                if (step.gridActive.backtrack) cls += ' backtrack';
                                else cls += ' visiting';
                            }
                        }
                        if (val === '#') cls += ' path';
                        
                        const div = document.createElement('div');
                        div.className = cls;
                        div.textContent = val === '#' ? '' : val; // Hide original char if visited? No, logic needs restore. Logic used # but viz wants char.
                        // Actually simulation replaced it. We should keep original board copy for display if we want to show char under visited.
                        // For now show visited marker.
                        gridC.appendChild(div);
                    }
                }
            }

            // Render Trie
            // We use the root from generation time (static structure) but highlight active node
            // Or re-bind data if structure changed? Structure is static after build.
            // Just updated highlights.
            
            // But we need to run d3 hierarchy layout once.
            // Let's do it in runVisualizer or if root changed.
            // Since we pass root in steps, we can re-render.
            
            const root = d3.hierarchy(step.root || {}, d => Object.values(d.children));
            const treeLayout = d3.tree().size([260, 260]);
            treeLayout.nodeSize([30, 40]);
            treeLayout(root);
            
            // Links
            const links = gLayer.selectAll(".trie-link").data(root.links(), d=>d.target.data.id);
            links.enter().append("path").attr("class", "trie-link")
                .merge(links)
                .attr("class", d => {
                    // Activate link if target is active node? No, active node is single point.
                    // Highlight path to active node would be better.
                    return "trie-link";
                })
                .attr("d", d3.linkVertical().x(d=>d.x).y(d=>d.y));
            links.exit().remove();
            
            // Nodes
            const nodes = gLayer.selectAll(".trie-node-g").data(root.descendants(), d=>d.data.id);
            const nEnter = nodes.enter().append("g").attr("class", "trie-node-g");
            nEnter.append("circle").attr("r", 12).attr("class", "trie-node");
            nEnter.append("text").attr("class", "trie-text").attr("dy", 1);
            
            const nUpdate = nodes.merge(nEnter)
                .attr("transform", d=>`translate(${d.x},${d.y})`);
            
            nUpdate.select(".trie-node").attr("class", d => {
                let cls = "trie-node";
                if(d.data.id === step.trieActive) cls += " current";
                if(d.data.word) cls += " match"; // If word exists (not null)
                return cls;
            });
            nUpdate.select(".trie-text").text(d => d.data.char || '.');
            
            nodes.exit().remove();
        }

        function runVisualizer() {
            const bStr = document.getElementById('boardInput').value;
            const wStr = document.getElementById('wordsInput').value;
            
            const board = bStr.trim().split('\n').map(r => r.split(',').map(c => c.trim()));
            const words = wStr.split(',').map(w => w.trim());
            
            if (board.length === 0 || words.length === 0) return;

            const { steps } = generateSteps(board, words);
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(steps);
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
