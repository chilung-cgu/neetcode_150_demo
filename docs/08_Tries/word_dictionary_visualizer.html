<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design Add and Search Words - Á≤æÁ∑ªË¶ñË¶∫Âåñ</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }

        #trie-svg {
            width: 100%; height: 400px;
            background: transparent;
            cursor: move;
        }

        .node-circle {
            fill: #3b82f6; stroke: none;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.3));
            transition: fill 0.3s ease, r 0.3s ease;
        }
        .node-circle.root { fill: #475569; }
        .node-circle.is-end { stroke: #22c55e; stroke-width: 3px; }
        .node-circle.current { fill: #fbbf24; filter: drop-shadow(0 0 10px rgba(251, 191, 36, 0.6)); }
        .node-circle.visited { fill: #64748b; opacity: 0.8; }
        .node-circle.match { fill: #22c55e; }

        .node-text {
            fill: white; font-family: 'Consolas', monospace; font-weight: bold; font-size: 14px;
            text-anchor: middle; dominant-baseline: middle; pointer-events: none;
        }

        .link {
            stroke: #64748b; stroke-width: 2px; opacity: 0.4;
            transition: stroke 0.3s ease, stroke-width 0.3s ease;
        }
        .link.active { stroke: #fbbf24; stroke-width: 3px; opacity: 1; }
        .link.visited { stroke: #64748b; opacity: 0.8; }
        .link.match { stroke: #22c55e; stroke-width: 3px; opacity: 1; }

        .op-tag {
            background: rgba(30, 41, 59, 0.6); padding: 8px 16px; border-radius: 20px;
            color: #94a3b8; font-size: 0.9rem; margin-bottom: 10px; border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
        .input-row input { padding: 8px 12px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; font-weight: 600; }
        .input-hint { font-size: 0.8rem; color: var(--viz-text-muted); margin-top: 5px; }

        .step-breakdown {
            background: rgba(30, 41, 59, 0.6);
            border-radius: 12px;
            padding: 15px 20px;
            border-left: 4px solid #3b82f6;
            margin-top: 15px;
            width: 100%; box-sizing: border-box;
        }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Design Add/Search Words (Ëê¨Áî®Â≠óÂÖÉ)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label>ÂñÆË©û:</label>
                        <input type="text" id="wordInput" value="bad" placeholder="Ëº∏ÂÖ•ÂñÆË©û" maxlength="8">
                        <button onclick="handleOp('add')">Ê∑ªÂä† (Add Word)</button>
                        <button onclick="handleOp('search')">ÊêúÂ∞ã (Search)</button>
                    </div>
                    <div class="input-hint">ÊîØÊè¥ '.' ‰ΩúÁÇ∫Ëê¨Áî®Â≠óÂÖÉ (ÂÉÖÊêúÂ∞ãÊôÇ)</div>
                    <div class="input-row" style="margin-top:10px">
                        <button onclick="resetTrie()" style="background:var(--viz-error);">ÈáçÁΩÆ (Reset)</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <div class="op-tag" id="opDisplay">Ê∫ñÂÇôÂ∞±Á∑í</div>
                    <svg id="trie-svg">
                        <g id="zoom-layer"></g> 
                    </svg>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="viz-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <!-- D3.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'class TrieNode {', id: 0 },
            { line: '    TrieNode* children[26];', id: 1 },
            { line: '    bool isEnd = false;', id: 2 },
            { line: '};', id: 3 },
            { line: 'void addWord(string word) {', id: 4 },
            { line: '    TrieNode* curr = root;', id: 5 },
            { line: '    for (char c : word) {', id: 6 },
            { line: '        if (!curr->children[c]) new Node();', id: 7 },
            { line: '        curr = curr->children[c];', id: 8 },
            { line: '    }', id: 9 },
            { line: '    curr->isEnd = true;', id: 10 },
            { line: '}', id: 11 },
            { line: 'bool search(string word) {', id: 12 },
            { line: '    return dfs(word, 0, root);', id: 13 },
            { line: '}', id: 14 },
            { line: 'bool dfs(string& word, int j, TrieNode* node) {', id: 15 },
            { line: '    for (int i = j; i < word.size(); i++) {', id: 16 },
            { line: '        char c = word[i];', id: 17 },
            { line: '        if (c == \'.\') {', id: 18 },
            { line: '            for (child : node->children) {', id: 19 },
            { line: '                if (dfs(word, i + 1, child)) return true;', id: 20 },
            { line: '            }', id: 21 },
            { line: '            return false;', id: 22 },
            { line: '        }', id: 23 },
            { line: '        if (!node->children[c]) return false;', id: 24 },
            { line: '        node = node->children[c];', id: 25 },
            { line: '    }', id: 26 },
            { line: '    return node->isEnd;', id: 27 },
            { line: '}', id: 28 }
        ];

        let root = { id: 'root', char: '', children: {}, isEnd: false };
        let viz;
        let idCounter = 0;

        function cloneTrie(node) {
            const newNode = { ...node, children: {} };
            for (let k in node.children) {
                newNode.children[k] = cloneTrie(node.children[k]);
            }
            return newNode;
        }

        function generateSteps(startRoot, op, word) {
            const steps = [];
            const newRoot = cloneTrie(startRoot); // Simulation on clone
            
            steps.push({
                root: JSON.parse(JSON.stringify(newRoot)),
                activeIds: ['root'], // Support multiple active nodes for DFS '.'
                highlightLines: op === 'add' ? [4, 5] : [12, 13],
                msg: `${op === 'add' ? 'Ê∑ªÂä†' : 'ÊêúÂ∞ã'}: "${word}"`,
                opName: op,
                focusCharIndex: -1
            });

            if (op === 'add') {
                let curr = newRoot;
                for (let i = 0; i < word.length; i++) {
                    const c = word[i];
                    steps.push({
                        root: JSON.parse(JSON.stringify(newRoot)),
                        activeIds: [curr.id],
                        highlightLines: [6],
                        msg: `ËôïÁêÜÂ≠óÁ¨¶: '${c}'`,
                        opName: op,
                        focusCharIndex: i
                    });

                    if (!curr.children[c]) {
                        curr.children[c] = { id: `n-${++idCounter}`, char: c, children: {}, isEnd: false };
                        steps.push({
                            root: JSON.parse(JSON.stringify(newRoot)),
                            activeIds: [curr.id],
                            highlightLines: [7],
                            msg: `Âª∫Á´ãÊñ∞ÁØÄÈªû '${c}'`,
                            opName: op,
                            focusCharIndex: i
                        });
                    }
                    curr = curr.children[c];
                    steps.push({
                        root: JSON.parse(JSON.stringify(newRoot)),
                        activeIds: [curr.id],
                        highlightLines: [8],
                        msg: `ÁßªÂãïÂà∞ '${c}'`,
                        opName: op,
                        focusCharIndex: i
                    });
                }
                curr.isEnd = true;
                steps.push({
                    root: JSON.parse(JSON.stringify(newRoot)),
                    activeIds: [curr.id],
                    highlightLines: [10],
                    msg: `Ê®ôË®òÁµêÂ∞æ (isEnd)`,
                    opName: op,
                    focusCharIndex: word.length
                });
            } else {
                // Search with Backtracking
                // We need to trace visualization steps inside DFS
                // We'll use a stack or explicit recursion simulation
                // Since simulation modifies nothing but traversal state, explicit recursion for step generation is fine.
                
                const performDFS = (node, index, pathIds) => {
                    // Base steps are tricky in recursion because we want linear timeline.
                    // We push steps to global `steps` array.
                    
                    if (index === word.length) {
                        steps.push({
                            root: JSON.parse(JSON.stringify(newRoot)),
                            activeIds: pathIds,
                            highlightLines: [27],
                            msg: `Âà∞ÈÅîÂñÆË©ûÊú´Â∞æ„ÄÇÊ™¢Êü• isEnd: ${node.isEnd}`,
                            opName: op,
                            resultSuccess: node.isEnd,
                            focusCharIndex: index
                        });
                        return node.isEnd;
                    }

                    const c = word[index];
                    
                    steps.push({
                        root: JSON.parse(JSON.stringify(newRoot)),
                        activeIds: pathIds,
                        highlightLines: [16, 17],
                        msg: `Ê™¢Êü•Á¥¢Âºï ${index} ('${c}')`,
                        opName: op,
                        focusCharIndex: index
                    });

                    if (c === '.') {
                        steps.push({
                            root: JSON.parse(JSON.stringify(newRoot)),
                            activeIds: pathIds,
                            highlightLines: [18, 19],
                            msg: `ÈÅáÂà∞Ëê¨Áî®Â≠óÂÖÉ '.'ÔºåÂòóË©¶ÊâÄÊúâÂ≠êÁØÄÈªû`,
                            opName: op,
                            focusCharIndex: index
                        });

                        const keys = Object.keys(node.children);
                        for (let k of keys) {
                            const child = node.children[k];
                            steps.push({
                                root: JSON.parse(JSON.stringify(newRoot)),
                                activeIds: [...pathIds, child.id], // Show path extension
                                highlightLines: [20],
                                msg: `ÂòóË©¶Â≠êÁØÄÈªû '${k}'`,
                                opName: op,
                                focusCharIndex: index
                            });

                            if (performDFS(child, index + 1, [...pathIds, child.id])) return true;
                            
                            steps.push({
                                root: JSON.parse(JSON.stringify(newRoot)),
                                activeIds: pathIds, // Backtrack visual
                                highlightLines: [21], // loop continue
                                msg: `ÂàÜÊîØ '${k}' Â§±ÊïóÔºåÂõûÊ∫Ø`,
                                opName: op,
                                focusCharIndex: index
                            });
                        }
                        return false;
                    } else {
                        if (!node.children[c]) {
                            steps.push({
                                root: JSON.parse(JSON.stringify(newRoot)),
                                activeIds: pathIds,
                                highlightLines: [24],
                                msg: `Êâæ‰∏çÂà∞Â≠óÁ¨¶ '${c}'ÔºåËøîÂõû false`,
                                opName: op,
                                focusCharIndex: index
                            });
                            return false;
                        }
                        const child = node.children[c];
                        steps.push({
                            root: JSON.parse(JSON.stringify(newRoot)),
                            activeIds: [...pathIds, child.id],
                            highlightLines: [25],
                            msg: `ÂåπÈÖç '${c}'ÔºåÈÄ≤ÂÖ•‰∏ã‰∏ÄÂ±§`,
                            opName: op,
                            focusCharIndex: index
                        });
                        return performDFS(child, index + 1, [...pathIds, child.id]);
                    }
                };

                performDFS(newRoot, 0, ['root']);
            }

            return { steps, finalRoot: newRoot };
        }

        // --- Render ---
        const svg = d3.select("#trie-svg");
        const gLayer = d3.select("#zoom-layer");
        const zoom = d3.zoom().on("zoom", (e) => gLayer.attr("transform", e.transform));
        svg.call(zoom);
        
        let width = 800, height = 400;

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;
            if(step.opName) document.getElementById('opDisplay').textContent = 
                `${step.opName === 'add' ? 'Ê∑ªÂä†' : 'ÊêúÂ∞ã'}: ${document.getElementById('wordInput').value}`;

            const hierarchyData = d3.hierarchy(step.root, d => Object.values(d.children));
            const treeLayout = d3.tree().size([width - 100, height - 100]);
            treeLayout.nodeSize([50, 60]);
            treeLayout(hierarchyData);
            
            const xOffset = width/2;
            const yOffset = 50;

            // Links
            const links = gLayer.selectAll(".link").data(hierarchyData.links(), d => d.target.data.id);
            links.enter().append("path").attr("class", "link")
                 .merge(links)
                 .attr("class", d => {
                     // Check if this link is part of active path
                     // Heuristic: target is in activeIds
                     if (step.activeIds && step.activeIds.includes(d.target.data.id)) return "link active";
                     return "link";
                 })
                 .transition().duration(300)
                 .attr("d", d3.linkVertical().x(d => d.x + xOffset).y(d => d.y + yOffset));
            links.exit().remove();

            // Nodes
            const nodes = gLayer.selectAll(".node").data(hierarchyData.descendants(), d => d.data.id);
            const nEnter = nodes.enter().append("g").attr("class", "node");
            nEnter.append("circle").attr("r", 20).attr("class", "node-circle");
            nEnter.append("text").attr("class", "node-text").attr("dy", 1);
            
            const nUpdate = nodes.merge(nEnter).transition().duration(300)
                .attr("transform", d => `translate(${d.x + xOffset},${d.y + yOffset})`);
            
            nodes.select(".node-circle").attr("class", d => {
                let cls = "node-circle";
                if (d.data.id === 'root') cls += " root";
                if (d.data.isEnd) cls += " is-end";
                
                // Active logic
                const isActive = step.activeIds && step.activeIds.includes(d.data.id);
                // The *last* active id is the current focus
                const isCurrent = step.activeIds && step.activeIds[step.activeIds.length-1] === d.data.id;
                
                if (isActive) cls += " visited"; // path part
                if (isCurrent) cls += " current"; // head
                if (step.resultSuccess && isCurrent) cls += " match";
                
                return cls;
            });
            nodes.select(".node-text").text(d => d.data.char);
            
            nodes.exit().remove();
        }

        function handleOp(op) {
            const word = document.getElementById('wordInput').value.trim().toLowerCase();
            if(!word) return;
            // Check validation: add only letters, search allows '.'
            if(op === 'add' && !/^[a-z]+$/.test(word)) return alert("Ê∑ªÂä†ÂÉÖÈôêËã±ÊñáÂ≠óÊØç");
            if(op === 'search' && !/^[a-z\.]+$/.test(word)) return alert("ÊêúÂ∞ãÂÉÖÈôêÂ≠óÊØçËàá '.'");

            const { steps, finalRoot } = generateSteps(root, op, word);
            if(op === 'add') root = finalRoot;
            viz.setSteps(steps);
        }

        function resetTrie() {
            root = { id: 'root', char: '', children: {}, isEnd: false };
            idCounter = 0;
            svg.selectAll("*").remove(); 
            svg.append("g").attr("id", "zoom-layer");
            viz.setSteps([{root:root, msg:"Â∑≤ÈáçÁΩÆ", highlightLines:[]}]);
        }

        window.addEventListener('load', () => {
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            handleOp('add');
        });
    </script>
</body>
</html>
