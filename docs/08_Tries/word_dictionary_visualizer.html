<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Dictionary - D3 Dynamic Viz</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 500px;
            position: relative;
        }
        
        #viz-svg { width: 100%; height: 450px; cursor: grab; }
        #viz-svg:active { cursor: grabbing; }

        /* Nodes */
        .node-circle { stroke-width: 2px; transition: all 0.3s; fill: #334155; stroke: #64748b; }
        .node-circle.root { fill: #475569; }
        .node-circle.active { stroke: #fbbf24; stroke-width: 3px; fill: rgba(251, 191, 36, 0.1); filter: drop-shadow(0 0 5px #fbbf24); }
        .node-circle.is-end { stroke: #22c55e; stroke-width: 4px; }
        .node-circle.match { fill: rgba(34, 197, 94, 0.2); stroke: #22c55e; stroke-width: 3px; }
        .node-circle.backtrack { stroke: #ef4444; fill: rgba(239, 68, 68, 0.2); }
        
        .node-text { fill: white; font-weight: bold; font-family: monospace; font-size: 14px; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        .node-text.root { font-size: 10px; }

        /* Links */
        .link { fill: none; stroke: #64748b; stroke-width: 2px; transition: all 0.3s; opacity: 0.3; }
        .link.active { stroke: #fbbf24; opacity: 1; stroke-width: 3px; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; justify-content: center; }
        input[type=text] { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 150px; }
        button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; font-weight: 600; height: 38px; }
        button.sec { background: #475569; }
        button.danger { background: #ef4444; }

        .op-status {
            margin-bottom: 15px; padding: 6px 12px; border-radius: 4px;
            background: rgba(15, 23, 42, 0.5); border: 1px solid #334155;
            color: #e2e8f0; font-family: monospace; font-size: 0.9rem;
            min-height: 24px; display: flex; align-items: center; justify-content: center;
        }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; width: 100%; box-sizing: border-box; }
        
        .legend { display: flex; gap: 15px; font-size: 0.8rem; color: #cbd5e1; margin-bottom: 5px; justify-content: center; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Design Word Dictionary ('.' Wildcard)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <input type="text" id="wordInput" value=".ad" placeholder="Word...">
                        <button onclick="runOp('add')">Add Word</button>
                        <button class="sec" onclick="runOp('search')">Search</button>
                        <button class="danger" onclick="resetTrie()">Reset</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <div class="op-status" id="opStatus">Dictionary Initialized.</div>
                    
                    <div class="legend">
                       <div class="legend-item"><div class="legend-color" style="background:#fbbf24"></div>Visiting</div>
                       <div class="legend-item"><div class="legend-color" style="background:#ef4444"></div>Backtrack</div>
                       <div class="legend-item"><div class="legend-color" style="border:2px solid #22c55e"></div>Match</div>
                    </div>

                    <svg id="viz-svg">
                        <g id="main-group" transform="translate(0, 40)"></g>
                    </svg>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn" onclick="runOp('replay')">‚Üª ÈáçÊîæ</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">2x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card logic-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'void addWord(word) { /* Standard Trie Insert */ }', id: 0 },
            { line: 'bool search(word) { return dfs(word, 0, root); }', id: 1 },
            { line: 'bool dfs(word, j, node) {', id: 2 },
            { line: '    for (int i=j; i<word.size(); i++) {', id: 3 },
            { line: '        char c = word[i];', id: 4 },
            { line: '        if (c == \'.\') {', id: 5 },
            { line: '            for (child : node->children)', id: 6 },
            { line: '                if (dfs(word, i+1, child)) return true;', id: 7 },
            { line: '            return false;', id: 8 },
            { line: '        } else {', id: 9 },
            { line: '            if (!node->children[c]) return false;', id: 10 },
            { line: '            node = node->children[c];', id: 11 },
            { line: '        }', id: 12 },
            { line: '    }', id: 13 },
            { line: '    return node->isEnd;', id: 14 },
            { line: '}', id: 15 }
        ];

        let viz;
        let globalTrie = { id: 0, char: 'root', children: {}, isEnd: false };
        let nextNodeId = 1;
        
        function resetTrie() {
            globalTrie = { id: 0, char: 'root', children: {}, isEnd: false };
            nextNodeId = 1;
            runOp('init');
        }

        // Add some default words
        function initDefaults() {
            ["bad", "dad", "mad"].forEach(w => {
                let curr = globalTrie;
                for(let c of w) {
                    if(!curr.children[c]) curr.children[c] = { id: nextNodeId++, char: c, children: {}, isEnd: false };
                    curr = curr.children[c];
                }
                curr.isEnd = true;
            });
        }
        
        // Layout helper
        function getTreeLayout(root) {
            const buildH = (node) => {
                const children = Object.keys(node.children).sort().map(k => buildH(node.children[k]));
                return { 
                    id: node.id, 
                    char: node.char, 
                    isEnd: node.isEnd,
                    children: children.length ? children : null
                };
            };
            const hData = buildH(root);
            const h = d3.hierarchy(hData);
            const treeLayout = d3.tree().nodeSize([40, 60]);
            treeLayout(h);
            return h;
        }

        function runOp(type) {
            const word = document.getElementById('wordInput').value.toLowerCase().trim();
            if (type !== 'init' && type !== 'replay' && !word) return;

            let steps = [];
            
            if (type === 'init') {
                initDefaults();
                const layout = getTreeLayout(globalTrie);
                steps.push({
                    layout, activeId: null, msg: "Trie Reset. Added 'bad', 'dad', 'mad'.", 
                    hl: [], info: { title: "ÈáçÁΩÆ", text: "Â∑≤ÈáçÁΩÆ‰∏¶Ê∑ªÂä†È†êË®≠ÂñÆË©û„ÄÇ", formula: "init()" },
                    statusMap: {}
                });
                viz = new AlgorithmVisualizer({ codeLines: codeStructure, onStepChange: render });
                viz.setSteps(steps);
                render(steps[0]);
                document.getElementById('opStatus').textContent = "Defaults: bad, dad, mad";
                return;
            }

            if(type === 'replay') return;

            // Perform Op
            let layout = getTreeLayout(globalTrie); 
            // Map: node.id -> 'active' | 'match' | 'backtrack'
            let statusMap = {};
            
            const snap = (activeId, msg, lines, info, forceLayoutUpdate) => {
                if(forceLayoutUpdate) layout = getTreeLayout(globalTrie);
                return {
                    layout, 
                    statusMap: JSON.parse(JSON.stringify(statusMap)),
                    activeId,
                    msg, highlightLines: lines, explanation: info
                };
            };

            if (type === 'add') {
                if(word.includes('.')) {
                    document.getElementById('opStatus').textContent = "Error: Cannot add word with '.'";
                    return;
                }
                
                let curr = globalTrie;
                steps.push(snap(curr.id, `Add "${word}"`, [0], { title: "Ê∑ªÂä†ÂñÆË©û", text: `ÊèíÂÖ•ÂñÆË©û "${word}"„ÄÇ`, formula: "addWord()" }));
                
                for(let i=0; i<word.length; i++) {
                    const c = word[i];
                    if(!curr.children[c]) {
                        curr.children[c] = { id: nextNodeId++, char: c, children: {}, isEnd: false };
                        steps.push(snap(curr.id, `Create node '${c}'`, [0], { title: "ÂâµÂª∫ÁØÄÈªû", text: `ÂâµÂª∫ '${c}'„ÄÇ`, formula: "new Node" }, true));
                    }
                    curr = curr.children[c];
                }
                curr.isEnd = true;
                steps.push(snap(curr.id, `Mark end`, [0], { title: "ÂÆåÊàê", text: "Ê®ôË®òÁµêÂ∞æ„ÄÇ", formula: "isEnd = true" }, true));
                document.getElementById('opStatus').textContent = `Added: ${word}`;
            } 
            else if (type === 'search') {
                steps.push(snap(globalTrie.id, `Search "${word}"`, [1], { title: "ÊêúÂ∞ã", text: `ÈñãÂßãÊêúÂ∞ã "${word}"`, formula: "search(word)" }));
                
                // Recursive DFS
                const dfs = (node, idx) => {
                    // statusMap[node.id] = 'active'; // Don't persist active, visualized via activeId
                    
                    if (idx === word.length) {
                        if (node.isEnd) {
                            statusMap[node.id] = 'match';
                            steps.push(snap(node.id, `End of Word matched!`, [14], { title: "ÂåπÈÖçÊàêÂäü", text: "Âà∞ÈÅîÂñÆË©ûÁµêÂ∞æ„ÄÇ", formula: "return true" }));
                            return true;
                        } else {
                            // statusMap[node.id] = 'backtrack'; // Not end
                            steps.push(snap(node.id, `Not End of Word. Backtrack.`, [14], { title: "ÂåπÈÖçÂ§±Êïó", text: "Ë∑ØÂæëÂ≠òÂú®‰ΩÜÈùûÁµêÂ∞æ„ÄÇ", formula: "return false" }));
                            return false;
                        }
                    }
                    
                    const char = word[idx];
                    
                    if (char === '.') {
                        steps.push(snap(node.id, `Wildcard '.' at index ${idx}. Try all children.`, [5, 6], { title: "ÈÄöÈÖçÁ¨¶", text: "ÈÅáÂà∞ '.'ÔºåÂòóË©¶ÊâÄÊúâÂ≠êÁØÄÈªû„ÄÇ", formula: "for child : children" }));
                        
                        const keys = Object.keys(node.children);
                        if (keys.length === 0) {
                            steps.push(snap(node.id, `No children for wildcard. Fail.`, [8], { title: "ÁÑ°Â≠êÁØÄÈªû", text: "ÁÑ°Ë∑ØÂèØËµ∞„ÄÇ", formula: "return false" }));
                            return false;
                        }
                        
                        for(let k of keys) {
                            const child = node.children[k];
                            steps.push(snap(child.id, `Try child '${child.char}' for '.'`, [7], { title: "ÂòóË©¶ÂàÜÊîØ", text: `ÂòóË©¶Â≠êÁØÄÈªû '${child.char}'„ÄÇ`, formula: "dfs(child)" }));
                            
                            if (dfs(child, idx + 1)) return true;
                            
                            steps.push(snap(node.id, `Backtrack from '${child.char}'`, [7], { title: "ÂõûÊ∫Ø", text: `ÂàÜÊîØ '${child.char}' Â§±ÊïóÔºåÂõûÊ∫Ø„ÄÇ`, formula: "backtrack" }));
                            statusMap[child.id] = 'backtrack';
                        }
                        return false;
                    } else {
                        if (node.children[char]) {
                            steps.push(snap(node.children[char].id, `Match '${char}', move next`, [10, 11], { title: "Â≠óÁ¨¶ÂåπÈÖç", text: `ÊâæÂà∞ '${char}'ÔºåÁπºÁ∫å„ÄÇ`, formula: "next" }));
                            if (dfs(node.children[char], idx + 1)) return true;
                             statusMap[node.children[char].id] = 'backtrack';
                            return false;
                        } else {
                            steps.push(snap(node.id, `Missing char '${char}'`, [10], { title: "Â≠óÁ¨¶Áº∫Â§±", text: `ÁÑ°Â≠êÁØÄÈªû '${char}'„ÄÇ`, formula: "return false" }));
                            return false;
                        }
                    }
                };
                
                const res = dfs(globalTrie, 0);
                document.getElementById('opStatus').textContent = `Search "${word}": ${res}`;
                if(!res) {
                    steps.push(snap(null, "Search Failed", [15], { title: "Â§±Êïó", text: "Êú™ËÉΩÂåπÈÖçÂñÆË©û„ÄÇ", formula: "return false" }));
                }
            }

            viz = new AlgorithmVisualizer({ codeLines: codeStructure, onStepChange: render });
            viz.setSteps(steps);
        }

        const svg = d3.select("#viz-svg");
        const mainG = svg.select("#main-group");

        // Zoom/Pan
        const zoom = d3.zoom().on("zoom", (e) => {
            mainG.attr("transform", e.transform);
        });
        svg.call(zoom);
        const initialTransform = d3.zoomIdentity.translate(svg.node().getBoundingClientRect().width/2, 40);
        svg.call(zoom.transform, initialTransform);

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;
            if (step.explanation) {
                document.getElementById('explanation').innerHTML = `
                    <div class="expl-title">${step.explanation.title}</div>
                    <div class="expl-text">${step.explanation.text}</div>
                    <div class="expl-formula">${step.explanation.formula}</div>
                `;
            }

            const root = step.layout;
            const nodes = root.descendants();
            const links = root.links();
            
            // Links
            const linkSel = mainG.selectAll(".link").data(links, d => d.target.data.id);
            linkSel.enter().append("path").attr("class", "link")
                .merge(linkSel).transition().duration(300)
                .attr("d", d3.linkVertical().x(d => d.x).y(d => d.y));
            linkSel.exit().remove();

            // Nodes
            const nodeSel = mainG.selectAll(".node").data(nodes, d => d.data.id);
            const nodeEnter = nodeSel.enter().append("g").attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`);
            
            nodeEnter.append("circle").attr("r", 18).attr("class", "node-circle");
            nodeEnter.append("text").attr("dy", 1).attr("class", "node-text");
            
            const nodeMerge = nodeSel.merge(nodeEnter).transition().duration(300)
                .attr("transform", d => `translate(${d.x},${d.y})`);
            
            nodeMerge.select("circle").attr("class", d => {
                let c = "node-circle";
                if(d.data.char === 'root') c += " root";
                if(d.data.isEnd) c += " is-end";
                
                if(d.data.id === step.activeId) c += " active";
                else if(step.statusMap && step.statusMap[d.data.id] === 'match') c += " match";
                else if(step.statusMap && step.statusMap[d.data.id] === 'backtrack') c += " backtrack";
                
                return c;
            });
            
            nodeMerge.select("text")
                .text(d => d.data.char === 'root' ? 'R' : d.data.char)
                .attr("class", d => d.data.char === 'root' ? "node-text root" : "node-text");

            nodeSel.exit().remove();
        }

        window.addEventListener('load', () => {
             resetTrie();
        });
    </script>
</body>
</html>
