<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design Add and Search Words - è¦–è¦ºåŒ–</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .trie { display: flex; flex-direction: column; align-items: center; margin: 20px 0; min-height: 100px; }
        .level { display: flex; gap: 10px; margin: 5px 0; justify-content: center; }
        .node { width: 35px; height: 35px; display: flex; align-items: center; justify-content: center; font-weight: bold; border-radius: 50%; background: var(--viz-primary); color: white; font-size: 0.9rem; }
        .node.end { border: 3px solid var(--viz-success); }
        .node.current { background: var(--viz-warning); color: #0f172a; }
        .node.matched { background: var(--viz-success); color: #0f172a; }
        .node.wildcard { background: var(--viz-secondary); color: #0f172a; }
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid var(--viz-border); }
        .input-title { font-weight: bold; margin-bottom: 10px; color: var(--viz-text); }
        .input-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
        .input-row input { padding: 8px 12px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }
        .input-hint { font-size: 0.8rem; color: var(--viz-text-muted); margin-top: 5px; }
        .words-list { display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0; }
        .word-tag { padding: 4px 10px; background: var(--viz-success); color: #0f172a; border-radius: 4px; font-size: 0.85rem; }
        .op-display { text-align: center; font-size: 1.1rem; color: var(--viz-secondary); margin: 10px 0; font-weight: bold; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="åˆ‡æ›ä¸»é¡Œ">ğŸŒ“</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">æ·»åŠ èˆ‡æœç´¢å–®è©ï¼ˆTRIE + DFSï¼‰</div>
                <div class="custom-input-section">
                    <div class="input-title">ğŸ® è‡ªè¨‚æ¸¬è©¦</div>
                    <div class="input-row">
                        <input type="text" id="wordInput" placeholder="è¼¸å…¥å–®è©" value="bad" style="width: 120px;">
                        <button onclick="addWord()">addWord</button>
                        <button onclick="searchWord()">search</button>
                    </div>
                    <div class="input-hint">"." å¯åŒ¹é…ä»»æ„å­—æ¯ï¼Œä¾‹å¦‚: ".ad" åŒ¹é… "bad", "dad"</div>
                    <div style="text-align: center; color: var(--text-muted); margin-top: 10px;">å·²æ·»åŠ å–®è©</div>
                    <div class="words-list" id="wordsList"></div>
                </div>
                <div class="op-display" id="opDisplay">-</div>
                <div class="trie" id="trieDisplay"></div>
                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">â† ä¸Šä¸€æ­¥</button>
                    <div class="step-indicator">æ­¥é©Ÿ <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">ä¸‹ä¸€æ­¥ â†’</button>
                    <button class="viz-btn" onclick="resetVisualization()">â†» é‡ç½®</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">â–¶ è‡ªå‹•æ’­æ”¾</button>
                    <div class="speed-control">
                        <label>é€Ÿåº¦:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="2000">0.5x</option>
                            <option value="1500" selected>1x</option>
                            <option value="1000">1.5x</option>
                            <option value="500">2x</option>
                        </select>
                    </div>
                </div>
                <div class="complexity-badge">
                    <span class="label">addWord:</span> O(m)
                    <span class="label" style="margin-left: 12px;">search:</span> O(26^m)
                </div>
                <div class="state-grid">
                    <div class="state-item"><div class="state-label">çµæœ</div><div class="state-value" id="resultDisplay" style="color: var(--viz-success);">-</div></div>
                </div>
                <div class="legend">
                    <div class="legend-item"><div class="legend-color normal"></div>ä¸€èˆ¬ç¯€é»</div>
                    <div class="legend-item"><div class="legend-color current"></div>è¬ç”¨å­—å…ƒ</div>
                    <div class="legend-item"><div class="legend-color in-stack"></div>å–®è©çµå°¾</div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">æ¼”ç®—æ³•èªªæ˜</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">æ¼”ç®—æ³• (C++)</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'class WordDictionary {', id: 0 },
            { line: '    TrieNode* root;', id: 1 },
            { line: 'public:', id: 2 },
            { line: '    void addWord(string word) { /* æ¨™æº–æ’å…¥ */ }', id: 3 },
            { line: '    bool search(string word) {', id: 4 },
            { line: '        return dfs(root, word, 0);', id: 5 },
            { line: '    }', id: 6 },
            { line: '    bool dfs(TrieNode* node, string& word, int i) {', id: 7 },
            { line: '        if (i == word.size()) return node->isEnd;', id: 8 },
            { line: '        if (word[i] == \'.\') {', id: 9 },
            { line: '            for (auto& [c, child] : node->children)', id: 10 },
            { line: '                if (dfs(child, word, i+1)) return true;', id: 11 },
            { line: '        } else {', id: 12 },
            { line: '            if (node->children.count(word[i]))', id: 13 },
            { line: '                return dfs(node->children[word[i]], word, i+1);', id: 14 },
            { line: '        }', id: 15 },
            { line: '        return false;', id: 16 },
            { line: '    }', id: 17 },
            { line: '};', id: 18 },
        ];

        let trie = {};
        let insertedWords = [];

        function insertWordToTrie(word) {
            let node = trie;
            for (const c of word) {
                if (!node[c]) node[c] = {};
                node = node[c];
            }
            node.isEnd = true;
        }

        function searchInTrie(word, node = trie, idx = 0) {
            if (idx === word.length) return node.isEnd === true;
            const c = word[idx];
            if (c === '.') {
                for (const key in node) {
                    if (key !== 'isEnd' && searchInTrie(word, node[key], idx + 1)) return true;
                }
                return false;
            }
            if (!node[c]) return false;
            return searchInTrie(word, node[c], idx + 1);
        }

        function generateAddSteps(word) {
            const steps = [];
            steps.push({
                op: `addWord("${word}")`,
                highlightLines: [3],
                explanation: {
                    title: `æ·»åŠ  "${word}"`,
                    text: `æ¨™æº– Trie æ’å…¥æ“ä½œ<br>å»ºç«‹è·¯å¾‘ä¸¦æ¨™è¨˜çµå°¾`,
                    formula: 'insert(word)'
                }
            });
            insertWordToTrie(word);
            steps.push({
                op: `addWord("${word}") âœ“`,
                path: word.split(''),
                highlightLines: [3],
                explanation: {
                    title: `å®Œæˆæ·»åŠ `,
                    text: `"${word}" å·²åŠ å…¥ Trie`,
                    formula: 'node->isEnd = true'
                }
            });
            return steps;
        }

        function generateSearchSteps(word) {
            const steps = [];
            const hasWildcard = word.includes('.');
            
            steps.push({
                op: `search("${word}")`,
                highlightLines: [4, 5],
                explanation: {
                    title: `æœå°‹ "${word}"`,
                    text: hasWildcard 
                        ? `åŒ…å« "." è¬ç”¨å­—å…ƒ<br>éœ€è¦ DFS å˜—è©¦æ‰€æœ‰å¯èƒ½`
                        : `æ¨™æº– Trie æœå°‹`,
                    formula: 'dfs(root, word, 0)'
                }
            });

            const result = searchInTrie(word);
            
            if (hasWildcard) {
                steps.push({
                    op: `search("${word}")`,
                    wildcardIdx: word.indexOf('.'),
                    highlightLines: [9, 10, 11],
                    explanation: {
                        title: `é‡åˆ° "."`,
                        text: `å˜—è©¦æ‰€æœ‰å¯èƒ½çš„å­—æ¯<br>ä»»ä¸€æˆåŠŸå³è¿”å› true`,
                        formula: 'for (c in children) dfs(child, i+1)'
                    }
                });
            }

            steps.push({
                op: `search("${word}") ${result ? 'âœ“' : 'âœ—'}`,
                result: result,
                highlightLines: result ? [8] : [16],
                explanation: {
                    title: result ? 'æ‰¾åˆ°ï¼' : 'æœªæ‰¾åˆ°',
                    text: result ? `"${word}" å­˜åœ¨æ–¼å­—å…¸ä¸­` : `"${word}" ä¸å­˜åœ¨`,
                    formula: `return ${result}`
                }
            });

            return steps;
        }

        function addWord() {
            const word = document.getElementById('wordInput').value.toLowerCase();
            if (!word || word.includes('.')) {
                alert('addWord ä¸èƒ½åŒ…å« "."');
                return;
            }
            insertedWords.push(word);
            updateWordsList();
            viz.setSteps(generateAddSteps(word));
        }

        function searchWord() {
            const word = document.getElementById('wordInput').value.toLowerCase();
            if (!word) return;
            viz.setSteps(generateSearchSteps(word));
        }

        function updateWordsList() {
            document.getElementById('wordsList').innerHTML = 
                insertedWords.map(w => `<span class="word-tag">${w}</span>`).join('') || 
                '<span style="color: var(--text-muted)">ç„¡</span>';
        }

        function renderTrie() {
            function buildHtml(obj, depth = 0) {
                const entries = Object.entries(obj).filter(([k]) => k !== 'isEnd');
                if (entries.length === 0) return '';
                
                let html = '<div class="level">';
                for (const [char, child] of entries) {
                    let cls = 'node';
                    if (child.isEnd) cls += ' end';
                    html += `<div class="${cls}">${char}</div>`;
                }
                html += '</div>';
                
                for (const [char, child] of entries) {
                    html += buildHtml(child, depth + 1);
                }
                return html;
            }

            const entries = Object.entries(trie).filter(([k]) => k !== 'isEnd');
            if (entries.length === 0) {
                return '<div class="level"><div class="node" style="background: var(--viz-warning)">root</div></div>';
            }
            return '<div class="level"><div class="node" style="background: var(--viz-warning)">root</div></div>' + buildHtml(trie);
        }

        let viz;
        function init() {
            trie = {};
            insertedWords = [];
            updateWordsList();
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: (step) => {
                    document.getElementById('opDisplay').textContent = step.op || '-';
                    document.getElementById('resultDisplay').textContent = 
                        step.result === true ? 'true âœ“' : 
                        step.result === false ? 'false âœ—' : '-';
                    document.getElementById('resultDisplay').style.color = 
                        step.result === true ? 'var(--viz-success)' : 
                        step.result === false ? 'var(--viz-error)' : 'var(--viz-text)';
                    document.getElementById('trieDisplay').innerHTML = renderTrie();
                }
            });
            
            viz.setSteps([{
                op: 'åˆå§‹åŒ–',
                highlightLines: [0, 1, 2],
                explanation: {
                    title: 'åˆå§‹åŒ– WordDictionary',
                    text: 'ä½¿ç”¨ Trie æ”¯æ´ "." è¬ç”¨å­—å…ƒæœå°‹<br>"." å¯åŒ¹é…ä»»æ„å–®å€‹å­—æ¯',
                    formula: 'support wildcard "."'
                }
            }]);
        }
        function resetVisualization() { init(); }
        window.addEventListener('load', init);
    </script>
</body>
</html>
