<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implement Trie - D3 Dynamic Viz</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 500px;
            position: relative;
        }
        
        #viz-svg { width: 100%; height: 450px; cursor: grab; }
        #viz-svg:active { cursor: grabbing; }

        /* Nodes */
        .node-circle { stroke-width: 2px; transition: all 0.3s; fill: #334155; stroke: #64748b; }
        .node-circle.root { fill: #475569; }
        .node-circle.active { stroke: #fbbf24; stroke-width: 3px; fill: rgba(251, 191, 36, 0.1); filter: drop-shadow(0 0 5px #fbbf24); }
        .node-circle.is-end { stroke: #22c55e; stroke-width: 4px; }
        .node-circle.match { fill: rgba(34, 197, 94, 0.2); }
        .node-circle.new { animation: popIn 0.4s ease; }

        @keyframes popIn { from { r: 0; } to { r: 18; } }

        .node-text { fill: white; font-weight: bold; font-family: monospace; font-size: 14px; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        .node-text.root { font-size: 10px; }

        /* Links */
        .link { fill: none; stroke: #64748b; stroke-width: 2px; transition: all 0.3s; opacity: 0.3; }
        .link.active { stroke: #fbbf24; opacity: 1; stroke-width: 3px; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; justify-content: center; }
        input[type=text] { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 150px; }
        button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; font-weight: 600; height: 38px; }
        button.sec { background: #475569; }
        button.danger { background: #ef4444; }

        .op-status {
            margin-bottom: 15px; padding: 6px 12px; border-radius: 4px;
            background: rgba(15, 23, 42, 0.5); border: 1px solid #334155;
            color: #e2e8f0; font-family: monospace; font-size: 0.9rem;
            min-height: 24px; display: flex; align-items: center; justify-content: center;
        }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; width: 100%; box-sizing: border-box; }
        
        .legend { display: flex; gap: 15px; font-size: 0.8rem; color: #cbd5e1; margin-bottom: 5px; justify-content: center; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Trie (Prefix Tree)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <input type="text" id="wordInput" value="apple" placeholder="Word...">
                        <button onclick="runOp('insert')">Insert</button>
                        <button class="sec" onclick="runOp('search')">Search</button>
                        <button class="sec" onclick="runOp('startsWith')">StartsWith</button>
                        <button class="danger" onclick="resetTrie()">Reset</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <div class="op-status" id="opStatus">Trie Initialized.</div>
                    
                    <div class="legend">
                       <div class="legend-item"><div class="legend-color" style="background:#fbbf24"></div>Active</div>
                       <div class="legend-item"><div class="legend-color" style="border:2px solid #22c55e"></div>End of Word</div>
                       <div class="legend-item"><div class="legend-color" style="background:#475569"></div>Root</div>
                    </div>

                    <svg id="viz-svg">
                        <g id="main-group" transform="translate(0, 40)"></g>
                    </svg>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn" onclick="runOp('replay')">‚Üª ÈáçÊîæ</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">2x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card logic-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'class Trie {', id: 0 },
            { line: '    // TrieNode { children[26], isEnd }', id: 1 },
            { line: '    void insert(string word) {', id: 2 },
            { line: '        TrieNode* curr = root;', id: 3 },
            { line: '        for (char c : word) {', id: 4 },
            { line: '            if (!curr->children[c])', id: 5 },
            { line: '                curr->children[c] = new TrieNode();', id: 6 },
            { line: '            curr = curr->children[c];', id: 7 },
            { line: '        }', id: 8 },
            { line: '        curr->isEnd = true;', id: 9 },
            { line: '    }', id: 10 },
            { line: '    bool search(string word) { /*...*/ }', id: 11 },
            { line: '    bool startsWith(string prefix) { /*...*/ }', id: 12 }
        ];

        let viz;
        let globalTrie = { id: 0, char: 'root', children: {}, isEnd: false };
        let nextNodeId = 1;
        
        // Persistent Trie Logic outside of visualizer simulation steps, 
        // because we want state to persist between ops.
        // Actually, for AlgorithmVisualizer pattern, we usually generate steps from scratch.
        // To support "interactive persistent state", we maintain `globalTrie` and when user clicks Insert,
        // we simulate THAT insert operation on the current globalTrie, update globalTrie, and generate steps.
        
        function resetTrie() {
            globalTrie = { id: 0, char: 'root', children: {}, isEnd: false };
            nextNodeId = 1;
            runOp('init');
        }

        // Layout helper
        function getTreeLayout(root) {
            // Convert to D3 hierarchy format
            // We need a helper to traverse our trie object and build hierarchy
            const buildH = (node) => {
                const children = Object.keys(node.children).sort().map(k => buildH(node.children[k]));
                return { 
                    id: node.id, 
                    char: node.char, 
                    isEnd: node.isEnd,
                    children: children.length ? children : null
                };
            };
            
            const hData = buildH(root);
            const h = d3.hierarchy(hData);
            const treeLayout = d3.tree().nodeSize([40, 60]); // Fixed spacing
            treeLayout(h);
            return h; // Returns hierarchy with x,y
        }

        function runOp(type) {
            const word = document.getElementById('wordInput').value.toLowerCase().trim();
            if (type !== 'init' && type !== 'replay' && !word) return;

            let steps = [];
            // Clone Trie for simulation to not mutate global state mid-step physically?
            // Actually we WANT to mutate global state, but capture snapshots.
            
            if (type === 'init') {
                const layout = getTreeLayout(globalTrie);
                steps.push({
                    layout, activeId: null, msg: "Trie Reset.", 
                    hl: [], info: { title: "ÈáçÁΩÆ", text: "Trie Â∑≤Ê∏ÖÁ©∫„ÄÇ", formula: "root = new TrieNode()" } 
                });
                viz = new AlgorithmVisualizer({ codeLines: codeStructure, onStepChange: render });
                viz.setSteps(steps);
                render(steps[0]);
                return;
            }

            // For replay of last op? We don't store history yet. Just ignore replay for now.
            if(type === 'replay') return;

            // Perform Op
            let curr = globalTrie;
            let layout = getTreeLayout(globalTrie); // Initial layout
            
            const snap = (activeId, msg, lines, info, forceLayoutUpdate) => {
                if(forceLayoutUpdate) layout = getTreeLayout(globalTrie);
                return {
                    layout, // capture current layout state
                    activeId,
                    msg, highlightLines: lines, explanation: info
                };
            };

            if (type === 'insert') {
                steps.push(snap(curr.id, `Insert "${word}" start`, [2, 3], { title: "ÊèíÂÖ•", text: `ÈñãÂßãÊèíÂÖ•ÂñÆË©û "${word}"„ÄÇÂæûÊ†πÁØÄÈªûÈñãÂßã„ÄÇ`, formula: "curr = root" }));
                
                for(let i=0; i<word.length; i++) {
                    const char = word[i];
                    steps.push(snap(curr.id, `Process char '${char}'`, [4], { title: "ËôïÁêÜÂ≠óÁ¨¶", text: `Ê™¢Êü•Áï∂ÂâçÁØÄÈªûÊòØÂê¶ÊúâÂ≠êÁØÄÈªû '${char}'„ÄÇ`, formula: `check children['${char}']` }));
                    
                    if(!curr.children[char]) {
                        curr.children[char] = { id: nextNodeId++, char: char, children: {}, isEnd: false };
                        steps.push(snap(curr.id, `Create new node '${char}'`, [5, 6], { title: "ÂâµÂª∫ÁØÄÈªû", text: `Â≠êÁØÄÈªû '${char}' ‰∏çÂ≠òÂú®ÔºåÂâµÂª∫Êñ∞ÁØÄÈªû„ÄÇ`, formula: "new TrieNode()" }, true)); // Layout update
                        // after update, we need to locate the NEW node ID for highlighting?
                        // curr.children[char] is the new node.
                    }
                    curr = curr.children[char];
                    steps.push(snap(curr.id, `Move to node '${char}'`, [7], { title: "ÁßªÂãï", text: `ÁßªÂãïÊåáÈáùÂà∞Â≠êÁØÄÈªû '${char}'„ÄÇ`, formula: "curr = curr->next" }));
                }
                curr.isEnd = true;
                steps.push(snap(curr.id, `Mark end of word "${word}"`, [9], { title: "Ê®ôË®òÁµêÂ∞æ", text: `Ê®ôË®òÁï∂ÂâçÁØÄÈªûÁÇ∫ÂñÆË©ûÁµêÂ∞æ (isEnd = true)„ÄÇ`, formula: "curr->isEnd = true" }, true));
                
                document.getElementById('opStatus').textContent = `Inserted: ${word}`;
            } 
            else if (type === 'search' || type === 'startsWith') {
                const isSearch = type === 'search';
                const opName = isSearch ? "Search" : "StartsWith";
                steps.push(snap(curr.id, `${opName} "${word}" start`, [11], { title: opName, text: `ÂæûÊ†πÁØÄÈªûÈñãÂßãÊü•Êâæ„ÄÇ`, formula: "curr = root" }));
                
                let found = true;
                for(let i=0; i<word.length; i++) {
                    const char = word[i];
                    if(!curr.children[char]) {
                        steps.push(snap(curr.id, `Missing char '${char}' -> False`, [11], { title: "Êü•ÊâæÂ§±Êïó", text: `Êâæ‰∏çÂà∞Â≠óÁ¨¶ '${char}'ÔºåË∑ØÂæëÊñ∑Ë£Ç„ÄÇ`, formula: "return false" }));
                        found = false;
                        break;
                    }
                    curr = curr.children[char];
                    steps.push(snap(curr.id, `Found '${char}', move next`, [11], { title: "ÂåπÈÖç", text: `ÊâæÂà∞Â≠óÁ¨¶ '${char}'ÔºåÁπºÁ∫å‰∏ã‰∏ÄÂ±§„ÄÇ`, formula: "curr = curr->next" }));
                }
                
                if(found) {
                    if (isSearch && !curr.isEnd) {
                         steps.push(snap(curr.id, `Path exists but not EndOfWord -> False`, [11], { title: "ÈùûÂÆåÊï¥ÂñÆË©û", text: "Ë∑ØÂæëÂ≠òÂú®Ôºå‰ΩÜÊ≠§ÁØÄÈªûÊú™Ê®ôË®òÁÇ∫ÂñÆË©ûÁµêÂ∞æ„ÄÇ", formula: "return curr->isEnd" }));
                         document.getElementById('opStatus').textContent = `Search "${word}": False (Prefix only)`;
                    } else {
                         steps.push(snap(curr.id, `${opName} Success -> True`, [11], { title: "Êü•ÊâæÊàêÂäü", text: isSearch ? "ÊâæÂà∞ÂÆåÊï¥ÂñÆË©û„ÄÇ" : "ÊâæÂà∞ÂâçÁ∂¥„ÄÇ", formula: "return true" }));
                         document.getElementById('opStatus').textContent = `${opName} "${word}": True`;
                    }
                } else {
                    document.getElementById('opStatus').textContent = `${opName} "${word}": False`;
                }
            }

            // Init Visualizer if fresh (or update steps)
            // Ideally we re-instantiate or reset steps
            viz = new AlgorithmVisualizer({ codeLines: codeStructure, onStepChange: render });
            viz.setSteps(steps);
        }

        const svg = d3.select("#viz-svg");
        const mainG = svg.select("#main-group");

        // Zoom/Pan
        const zoom = d3.zoom().on("zoom", (e) => {
            mainG.attr("transform", e.transform);
        });
        svg.call(zoom);
        
        // Initial center
        const initialTransform = d3.zoomIdentity.translate(svg.node().getBoundingClientRect().width/2, 40);
        svg.call(zoom.transform, initialTransform);

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;
            if (step.explanation) {
                document.getElementById('explanation').innerHTML = `
                    <div class="expl-title">${step.explanation.title}</div>
                    <div class="expl-text">${step.explanation.text}</div>
                    <div class="expl-formula">${step.explanation.formula}</div>
                `;
            }

            const root = step.layout;
            const nodes = root.descendants();
            const links = root.links();
            
            // Links
            const linkSel = mainG.selectAll(".link").data(links, d => d.target.data.id);
            linkSel.enter().append("path").attr("class", "link")
                .merge(linkSel).transition().duration(300)
                .attr("d", d3.linkVertical().x(d => d.x).y(d => d.y))
                .attr("class", d => {
                    // Highlight path if target is active or ancestor of active?
                    // Simple logic: if target id is active, highlight edge to it?
                    // Not trivial without path tracking.
                    // For now simple static style. 
                    return "link";
                });
            linkSel.exit().remove();

            // Nodes
            const nodeSel = mainG.selectAll(".node").data(nodes, d => d.data.id);
            const nodeEnter = nodeSel.enter().append("g").attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`);
            
            nodeEnter.append("circle").attr("r", 18).attr("class", "node-circle");
            nodeEnter.append("text").attr("dy", 1).attr("class", "node-text");
            
            const nodeMerge = nodeSel.merge(nodeEnter).transition().duration(300)
                .attr("transform", d => `translate(${d.x},${d.y})`);
            
            nodeMerge.select("circle").attr("class", d => {
                let c = "node-circle";
                if(d.data.char === 'root') c += " root";
                if(d.data.isEnd) c += " is-end";
                if(d.data.id === step.activeId) c += " active";
                return c;
            });
            
            nodeMerge.select("text")
                .text(d => d.data.char === 'root' ? 'R' : d.data.char)
                .attr("class", d => d.data.char === 'root' ? "node-text root" : "node-text");

            nodeSel.exit().remove();
        }

        window.addEventListener('load', () => {
             resetTrie();
        });
    </script>
</body>
</html>
