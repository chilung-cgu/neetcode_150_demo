<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implement Trie å¯¦ä½œå‰ç¶´æ¨¹ - è¦–è¦ºåŒ–</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .trie-viz { display: flex; flex-direction: column; align-items: center; gap: 10px; margin: 20px 0; min-height: 150px; }
        .trie-level { display: flex; gap: 15px; justify-content: center; }
        .trie-node { width: 35px; height: 35px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; background: var(--viz-primary); color: white; transition: all 0.3s; font-size: 0.9rem; }
        .trie-node.root { background: var(--viz-warning); color: #0f172a; }
        .trie-node.end { border: 3px solid var(--viz-success); }
        .trie-node.current { background: var(--viz-secondary); color: #0f172a; }
        .op-display { text-align: center; font-size: 1.1rem; color: var(--viz-secondary); margin: 10px 0; font-weight: bold; }
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid var(--viz-border); }
        .input-title { font-weight: bold; margin-bottom: 10px; color: var(--viz-text); }
        .input-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
        .input-row input { padding: 8px 12px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }
        .words-list { display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0; }
        .word-tag { padding: 4px 10px; background: var(--viz-success); color: #0f172a; border-radius: 4px; font-size: 0.85rem; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="åˆ‡æ›ä¸»é¡Œ">ğŸŒ“</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">å‰ç¶´æ¨¹ Trie</div>
                <div class="custom-input-section">
                    <div class="input-title">ğŸ® è‡ªè¨‚æ¸¬è©¦</div>
                    <div class="input-row">
                        <input type="text" id="wordInput" placeholder="è¼¸å…¥å–®è©" value="apple" style="width: 120px;">
                        <button onclick="insertWord()">Insert</button>
                        <button onclick="searchWord()">Search</button>
                        <button onclick="startsWithWord()">StartsWith</button>
                    </div>
                    <div style="text-align: center; color: var(--text-muted); margin-top: 10px;">å·²æ’å…¥å–®è©</div>
                    <div class="words-list" id="wordsList"></div>
                </div>
                <div class="op-display" id="opDisplay">-</div>
                <div class="trie-viz" id="trieViz"></div>
                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">â† ä¸Šä¸€æ­¥</button>
                    <div class="step-indicator">æ­¥é©Ÿ <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">ä¸‹ä¸€æ­¥ â†’</button>
                    <button class="viz-btn" onclick="resetVisualization()">â†» é‡ç½®</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">â–¶ è‡ªå‹•æ’­æ”¾</button>
                    <div class="speed-control">
                        <label>é€Ÿåº¦:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="2000">0.5x</option>
                            <option value="1500" selected>1x</option>
                            <option value="1000">1.5x</option>
                            <option value="500">2x</option>
                        </select>
                    </div>
                </div>
                
                <div class="complexity-badge">
                    <span class="label">Time:</span> O(m) per op
                    <span class="label" style="margin-left: 12px;">Space:</span> O(nÃ—m)
                </div>
                <div class="state-grid">
                    <div class="state-item"><div class="state-label">æ“ä½œçµæœ</div><div class="state-value" id="resultDisplay" style="color: var(--viz-success);">-</div></div>
                </div>
                <div class="legend">
                    <div class="legend-item"><div class="legend-color current"></div>æ ¹ç¯€é»</div>
                    <div class="legend-item"><div class="legend-color normal"></div>ä¸€èˆ¬ç¯€é»</div>
                    <div class="legend-item"><div class="legend-color in-stack"></div>å–®è©çµå°¾</div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">æ¼”ç®—æ³•èªªæ˜</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">Trie (C++)</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'class TrieNode {', id: 0 },
            { line: '    TrieNode* children[26];', id: 1 },
            { line: '    bool isEnd = false;', id: 2 },
            { line: '};', id: 3 },
            { line: 'void insert(string word) {', id: 4 },
            { line: '    TrieNode* node = root;', id: 5 },
            { line: '    for (char c : word) {', id: 6 },
            { line: '        if (!node->children[c-\'a\'])', id: 7 },
            { line: '            node->children[c-\'a\'] = new TrieNode();', id: 8 },
            { line: '        node = node->children[c-\'a\'];', id: 9 },
            { line: '    }', id: 10 },
            { line: '    node->isEnd = true;', id: 11 },
            { line: '}', id: 12 },
        ];

        let trie = {};
        let insertedWords = [];

        function insertWordToTrie(word) {
            let node = trie;
            for (const c of word) {
                if (!node[c]) node[c] = {};
                node = node[c];
            }
            node.isEnd = true;
        }

        function generateInsertSteps(word) {
            const steps = [];
            let path = [];
            
            steps.push({
                op: `insert("${word}")`,
                path: [],
                trie: JSON.parse(JSON.stringify(trie)),
                highlightLines: [4, 5],
                explanation: {
                    title: `æ’å…¥ "${word}"`,
                    text: `å¾æ ¹ç¯€é»é–‹å§‹éæ­·<br>ç‚ºæ¯å€‹å­—ç¬¦å»ºç«‹ç¯€é»ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰`,
                    formula: 'node = root'
                }
            });

            let node = trie;
            for (let i = 0; i < word.length; i++) {
                const c = word[i];
                path.push(c);
                const isNew = !node[c];
                if (!node[c]) node[c] = {};
                node = node[c];

                steps.push({
                    op: `insert("${word}")`,
                    path: [...path],
                    currentChar: c,
                    trie: JSON.parse(JSON.stringify(trie)),
                    highlightLines: isNew ? [7, 8, 9] : [9],
                    explanation: {
                        title: `éæ­· '${c}'`,
                        text: `${isNew ? 'å»ºç«‹æ–°ç¯€é»' : 'ç¯€é»å·²å­˜åœ¨'}`,
                        formula: `node = node->children['${c}']`
                    }
                });
            }
            node.isEnd = true;

            steps.push({
                op: `insert("${word}") âœ“`,
                path: [...path],
                trie: JSON.parse(JSON.stringify(trie)),
                result: true,
                highlightLines: [11],
                explanation: {
                    title: `å®Œæˆæ’å…¥`,
                    text: `æ¨™è¨˜ '${word[word.length-1]}' ç‚ºå–®è©çµå°¾`,
                    formula: 'node->isEnd = true'
                }
            });

            return steps;
        }

        function generateSearchSteps(word, prefixOnly = false) {
            const steps = [];
            let node = trie;
            let path = [];
            const opName = prefixOnly ? 'startsWith' : 'search';

            steps.push({
                op: `${opName}("${word}")`,
                path: [],
                trie: JSON.parse(JSON.stringify(trie)),
                highlightLines: [5, 6],
                explanation: {
                    title: `${prefixOnly ? 'å‰ç¶´æœå°‹' : 'æœå°‹'} "${word}"`,
                    text: `å¾æ ¹ç¯€é»é–‹å§‹éæ­·`,
                    formula: 'node = root'
                }
            });

            for (let i = 0; i < word.length; i++) {
                const c = word[i];
                if (!node[c]) {
                    steps.push({
                        op: `${opName}("${word}") âœ—`,
                        path: [...path],
                        notFound: c,
                        trie: JSON.parse(JSON.stringify(trie)),
                        result: false,
                        highlightLines: [7],
                        explanation: {
                            title: `æœªæ‰¾åˆ° '${c}'`,
                            text: `ç¯€é» '${c}' ä¸å­˜åœ¨<br>å›å‚³ false`,
                            formula: `node->children['${c}'] == nullptr`
                        }
                    });
                    return steps;
                }
                path.push(c);
                node = node[c];
            }

            const found = prefixOnly || node.isEnd;
            steps.push({
                op: `${opName}("${word}") ${found ? 'âœ“' : 'âœ—'}`,
                path: [...path],
                trie: JSON.parse(JSON.stringify(trie)),
                result: found,
                highlightLines: [11],
                explanation: {
                    title: found ? 'æ‰¾åˆ°ï¼' : 'æœªæ‰¾åˆ°',
                    text: prefixOnly 
                        ? `å‰ç¶´ "${word}" å­˜åœ¨` 
                        : (found ? `"${word}" æ˜¯å®Œæ•´å–®è©` : `"${word}" åªæ˜¯å‰ç¶´ï¼Œä¸æ˜¯å®Œæ•´å–®è©`),
                    formula: prefixOnly ? 'return true' : `node->isEnd = ${node.isEnd}`
                }
            });

            return steps;
        }

        function insertWord() {
            const word = document.getElementById('wordInput').value.toLowerCase();
            if (!word) return;
            insertedWords.push(word);
            updateWordsList();
            viz.setSteps(generateInsertSteps(word));
        }

        function searchWord() {
            const word = document.getElementById('wordInput').value.toLowerCase();
            if (!word) return;
            viz.setSteps(generateSearchSteps(word, false));
        }

        function startsWithWord() {
            const word = document.getElementById('wordInput').value.toLowerCase();
            if (!word) return;
            viz.setSteps(generateSearchSteps(word, true));
        }

        function updateWordsList() {
            document.getElementById('wordsList').innerHTML = 
                insertedWords.map(w => `<span class="word-tag">${w}</span>`).join('') || 
                '<span style="color: var(--text-muted)">ç„¡</span>';
        }

        function renderTrie(trieData, path = []) {
            let html = '<div class="trie-level"><div class="trie-node root">â˜†</div></div>';
            
            function getNodes(obj, depth, currentPath) {
                const nodes = [];
                for (const [char, child] of Object.entries(obj)) {
                    if (char === 'isEnd') continue;
                    const nodePath = [...currentPath, char];
                    const isOnPath = path.length >= nodePath.length && 
                        nodePath.every((c, i) => c === path[i]);
                    nodes.push({
                        char,
                        isEnd: child.isEnd,
                        isOnPath,
                        children: child
                    });
                }
                return nodes;
            }

            function buildLevel(obj, depth, currentPath) {
                const nodes = getNodes(obj, depth, currentPath);
                if (nodes.length === 0) return '';
                
                let levelHtml = '<div class="trie-level">';
                for (const node of nodes) {
                    let cls = 'trie-node';
                    if (node.isEnd) cls += ' end';
                    if (node.isOnPath) cls += ' current';
                    levelHtml += `<div class="${cls}">${node.char}</div>`;
                }
                levelHtml += '</div>';
                
                // Recursively build children
                for (const node of nodes) {
                    levelHtml += buildLevel(node.children, depth + 1, [...currentPath, node.char]);
                }
                
                return levelHtml;
            }

            html += buildLevel(trieData, 0, []);
            return html || '<div class="trie-level"><div class="trie-node root">â˜†</div></div>';
        }

        let viz;
        function init() {
            trie = {};
            insertedWords = [];
            updateWordsList();
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: (step) => {
                    document.getElementById('opDisplay').textContent = step.op || '-';
                    document.getElementById('resultDisplay').textContent = 
                        step.result === true ? 'true âœ“' : 
                        step.result === false ? 'false âœ—' : '-';
                    document.getElementById('resultDisplay').style.color = 
                        step.result === true ? 'var(--viz-success)' : 
                        step.result === false ? 'var(--viz-error)' : 'var(--viz-text)';
                    
                    document.getElementById('trieViz').innerHTML = renderTrie(step.trie || {}, step.path || []);
                }
            });
            
            // Demo steps
            const demoSteps = [
                { op: 'åˆå§‹åŒ– Trie', trie: {}, path: [], highlightLines: [0,1,2,3], explanation: { title: 'åˆå§‹åŒ– Trie', text: 'æ¯å€‹ç¯€é»æœ‰ 26 å€‹å­ç¯€é»æŒ‡æ¨™ï¼ˆa-zï¼‰<br>isEnd æ¨™è¨˜å–®è©çµå°¾', formula: 'children[26], isEnd' } }
            ];
            viz.setSteps(demoSteps);
        }
        function resetVisualization() { init(); }
        window.addEventListener('load', init);
    </script>
</body>
</html>
