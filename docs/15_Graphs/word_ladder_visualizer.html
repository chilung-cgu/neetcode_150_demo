<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Ladder - è¦–è¦ºåŒ–</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }

        .word-graph { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin: 15px 0; }
        .word-node { 
            padding: 10px 16px; border-radius: 8px; background: var(--viz-bg-secondary); 
            border: 2px solid var(--viz-border); font-family: monospace; font-weight: bold; 
            transition: all 0.3s; font-size: 1rem;
        }
        .word-node.start { border-color: var(--viz-success); background: var(--viz-success); color: #0f172a; }
        .word-node.end { border-color: var(--viz-error); background: rgba(239, 68, 68, 0.2); color: var(--viz-error); }
        .word-node.current { border-color: var(--viz-warning); background: var(--viz-warning); color: #0f172a; transform: scale(1.05); }
        .word-node.visited { opacity: 0.5; }
        .word-node.path { border-color: var(--viz-success); background: var(--viz-success); color: #0f172a; }
        .word-node.found { border-color: var(--viz-success); background: var(--viz-success); color: #0f172a; animation: pulse 0.5s; }
        @keyframes pulse { 0%,100% { transform: scale(1); } 50% { transform: scale(1.1); } }

        .queue-container { 
            display: flex; gap: 6px; flex-wrap: wrap; justify-content: center; 
            margin: 10px 0; padding: 10px; background: var(--viz-bg-secondary); border-radius: 8px;
        }
        .queue-label { color: var(--viz-text-muted); font-size: 0.85rem; width: 100%; text-align: center; margin-bottom: 5px; }
        .queue-item { background: var(--viz-primary); color: white; padding: 5px 10px; border-radius: 4px; font-family: monospace; font-size: 0.85rem; }

        .path-display { 
            text-align: center; margin: 15px 0; padding: 12px; 
            background: var(--viz-bg-secondary); border-radius: 8px; font-size: 1rem;
        }
        .path-arrow { color: var(--viz-text-muted); margin: 0 5px; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="åˆ‡æ›ä¸»é¡Œ">ğŸŒ“</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">å–®è©æ¥é¾ (Word Ladder)</div>
                <div class="custom-input-section">
                    <div style="font-weight:bold; margin-bottom:5px;">ğŸ® è‡ªè¨‚æ¸¬è©¦</div>
                    <div class="input-row">
                        <button onclick="setExample(1)">hit â†’ cog</button>
                        <button onclick="setExample(2)">cat â†’ dog</button>
                        <button onclick="resetVisualization()">â†» é‡ç½®</button>
                    </div>
                </div>
                
                <div class="word-graph" id="wordGraph"></div>
                <div class="path-display" id="pathDisplay">å°‹æ‰¾æœ€çŸ­è½‰æ›è·¯å¾‘...</div>
                
                <div class="queue-container">
                    <div class="queue-label">BFS Queue:</div>
                    <div id="queueDisplay" style="display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;"></div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">â† ä¸Šä¸€æ­¥</button>
                    <div class="step-indicator">æ­¥é©Ÿ <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">ä¸‹ä¸€æ­¥ â†’</button>
                    <div class="speed-control">
                        <label>é€Ÿåº¦:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">1x</option>
                            <option value="800">2x</option>
                        </select>
                    </div>
                </div>
                
                <div class="complexity-badge">
                    <span class="label">Time:</span> O(nÂ·mÂ·26)
                    <span class="label" style="margin-left: 12px;">Space:</span> O(nÂ·m)
                </div>
                <div class="state-grid">
                    <div class="state-item"><div class="state-label">BFS å±¤æ•¸</div><div class="state-value" id="levelDisplay">0</div></div>
                    <div class="state-item"><div class="state-label">æœ€çŸ­è·¯å¾‘</div><div class="state-value" id="answerDisplay">?</div></div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">æ¼”ç®—æ³•èªªæ˜</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">æ¼”ç®—æ³• (C++)</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'int ladderLength(string begin, string end, vector<string>& list) {', id: 0 },
            { line: '    unordered_set<string> words(list.begin(), list.end());', id: 1 },
            { line: '    if (words.find(end) == words.end()) return 0;', id: 2 },
            { line: '    queue<string> q; q.push(begin);', id: 3 },
            { line: '    int level = 1;', id: 4 },
            { line: '    while (!q.empty()) {', id: 5 },
            { line: '        int size = q.size();', id: 6 },
            { line: '        for (int i = 0; i < size; i++) {', id: 7 },
            { line: '            string word = q.front(); q.pop();', id: 8 },
            { line: '            for (int j = 0; j < word.size(); j++) {', id: 9 },
            { line: '                char original = word[j];', id: 10 },
            { line: '                for (char c = \'a\'; c <= \'z\'; c++) {', id: 11 },
            { line: '                    word[j] = c;', id: 12 },
            { line: '                    if (word == end) return level + 1;', id: 13 },
            { line: '                    if (words.count(word)) {', id: 14 },
            { line: '                        q.push(word); words.erase(word);', id: 15 },
            { line: '                    }', id: 16 },
            { line: '                }', id: 17 },
            { line: '                word[j] = original;', id: 18 },
            { line: '            }', id: 19 },
            { line: '        }', id: 20 },
            { line: '        level++;', id: 21 },
            { line: '    }', id: 22 },
            { line: '    return 0;', id: 23 },
            { line: '}', id: 24 },
        ];
        
        const examples = {
            1: { begin: 'hit', end: 'cog', words: ['hot', 'dot', 'dog', 'lot', 'log', 'cog'] },
            2: { begin: 'cat', end: 'dog', words: ['cot', 'cog', 'dog', 'dat', 'dag'] }
        };
        
        let currentExample = examples[1];

        function setExample(n) {
            currentExample = examples[n];
            init();
        }

        function oneCharDiff(a, b) {
            if (a.length !== b.length) return false;
            let diff = 0;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) diff++;
                if (diff > 1) return false;
            }
            return diff === 1;
        }

        function generateAlgorithmSteps(begin, end, wordList) {
            const steps = [];
            const words = new Set(wordList);
            const visited = new Set([begin]);
            const allWords = [begin, ...wordList];
            
            steps.push({
                queue: [begin], visited: new Set([begin]), current: null, level: 1,
                highlightLines: [0, 1, 2, 3, 4],
                explanation: { 
                    title: 'åˆå§‹åŒ–', 
                    text: `èµ·é»: "${begin}"<br>çµ‚é»: "${end}"<br>å­—å…¸: [${wordList.join(', ')}]<br><br>BFS æ‰¾æœ€çŸ­è·¯å¾‘`,
                    formula: 'setup'
                }
            });

            let queue = [begin];
            let level = 1;
            const parent = { [begin]: null };

            while (queue.length > 0) {
                const nextQueue = [];
                
                for (const word of queue) {
                    // Try all one-char transformations
                    for (const nextWord of words) {
                        if (!visited.has(nextWord) && oneCharDiff(word, nextWord)) {
                            visited.add(nextWord);
                            parent[nextWord] = word;
                            nextQueue.push(nextWord);
                            
                            // Check if found
                            if (nextWord === end) {
                                // Build path
                                const path = [end];
                                let curr = end;
                                while (parent[curr]) {
                                    path.unshift(parent[curr]);
                                    curr = parent[curr];
                                }
                                
                                steps.push({
                                    queue: [], visited: new Set(visited), current: nextWord,
                                    path, answer: level + 1, level: level + 1, found: true,
                                    highlightLines: [13],
                                    explanation: { 
                                        title: 'æ‰¾åˆ°!', 
                                        text: `"${word}" â†’ "${nextWord}"<br><br>è·¯å¾‘: ${path.join(' â†’ ')}<br>é•·åº¦: ${level + 1}`,
                                        formula: `return ${level + 1}`
                                    }
                                });
                                return steps;
                            }
                        }
                    }
                    
                    if (nextQueue.length > 0 && nextQueue[nextQueue.length - 1] !== end) {
                        steps.push({
                            queue: [...nextQueue], visited: new Set(visited), current: word, level,
                            highlightLines: [8, 9, 10, 11, 12, 14, 15],
                            explanation: { 
                                title: `è™•ç† "${word}"`, 
                                text: `å˜—è©¦æ‰€æœ‰ä¸€å­—ä¹‹å·®çš„è½‰æ›<br>ç™¼ç¾: ${nextQueue.slice(-3).join(', ')}`,
                                formula: `level = ${level}`
                            }
                        });
                    }
                }
                
                queue = nextQueue;
                level++;
            }

            // Not found
            steps.push({
                queue: [], visited, current: null, answer: 0, level,
                highlightLines: [23],
                explanation: { title: 'ç„¡æ³•åˆ°é”', text: `å¾ "${begin}" åˆ° "${end}" æ²’æœ‰è·¯å¾‘`, formula: 'return 0' }
            });

            return steps;
        }

        let viz;
        function init() {
            const { begin, end, words } = currentExample;
            const allWords = [begin, ...words];
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: (step) => {
                    document.getElementById('wordGraph').innerHTML = allWords.map(w => {
                        let cls = 'word-node';
                        if (w === begin) cls += ' start';
                        else if (w === end) cls += step.found ? ' found' : ' end';
                        
                        if (step.current === w) cls += ' current';
                        else if (step.path?.includes(w)) cls += ' path';
                        else if (step.visited?.has(w)) cls += ' visited';
                        
                        return `<div class="${cls}">${w}</div>`;
                    }).join('');
                    
                    document.getElementById('queueDisplay').innerHTML = (step.queue || []).map(w => 
                        `<span class="queue-item">${w}</span>`
                    ).join('') || '<span style="color:var(--viz-text-muted)">ç©º</span>';
                    
                    if (step.path) {
                        document.getElementById('pathDisplay').innerHTML = 
                            `<span style="color: var(--viz-success)">è·¯å¾‘: ${step.path.join('<span class="path-arrow">â†’</span>')}</span>`;
                    } else {
                        document.getElementById('pathDisplay').textContent = 'å°‹æ‰¾ä¸­...';
                    }
                    
                    document.getElementById('levelDisplay').textContent = step.level || 0;
                    document.getElementById('answerDisplay').textContent = step.answer ?? '?';
                    document.getElementById('answerDisplay').style.color = step.answer ? 'var(--viz-success)' : 'inherit';
                }
            });
            viz.setSteps(generateAlgorithmSteps(begin, end, words));
        }
        
        function resetVisualization() { init(); }
        window.addEventListener('load', init);
    </script>
</body>
</html>
