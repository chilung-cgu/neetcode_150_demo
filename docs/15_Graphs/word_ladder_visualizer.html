<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Ladder - D3 Á≤æÁ∑ªË¶ñË¶∫Âåñ</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            min-height: 600px;
        }

        /* SVG */
        .graph-viewport {
            width: 100%; height: 450px;
            background: rgba(30, 41, 59, 0.4);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }
        #viz-svg { width: 100%; height: 100%; cursor: grab; }
        #viz-svg:active { cursor: grabbing; }

        .node-rect { fill: #475569; stroke: #fff; stroke-width: 2px; rx: 8; ry: 8; transition: fill 0.3s; }
        .node-rect.start { fill: #3b82f6; }
        .node-rect.end { fill: #ef4444; }
        .node-rect.visited { fill: #f59e0b; }
        .node-rect.path { fill: #22c55e; stroke: #86efac; stroke-width: 3px; }
        .node-rect.current { stroke: #fbbf24; stroke-width: 4px; filter: drop-shadow(0 0 5px #fbbf24); }

        .node-text { pointer-events: none; font-size: 14px; font-weight: bold; text-anchor: middle; dominant-baseline: middle; fill: white; font-family: monospace; }

        .link { stroke: #94a3b8; stroke-width: 1px; opacity: 0.2; }
        .link.path { stroke: #22c55e; stroke-width: 3px; opacity: 1; }

        /* Stats */
        .stats-panel {
            display: flex; gap: 30px; justify-content: center; width: 100%;
            background: rgba(15, 23, 42, 0.6); padding: 10px; border-radius: 12px;
        }
        .stat-val { font-size: 1.5rem; font-weight: bold; color: #22c55e; }
        .stat-label { font-size: 0.8rem; color: #94a3b8; text-transform: uppercase; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: start; justify-content: center; }
        textarea { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 300px; height: 60px; resize: none; }
        button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; font-weight: 600; height: 40px; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; width: 100%; box-sizing: border-box; }
        
        .legend { display: flex; gap: 15px; font-size: 0.8rem; color: #cbd5e1; margin-bottom: 5px; justify-content: center; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; border: 1px solid #fff; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Word Ladder (BFS Shortest Path)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <div>
                            <label style="font-size:0.8rem; color:#94a3b8;">Input JSON {begin, end, words}:</label>
                            <textarea id="gridInput">{"begin":"hit","end":"cog","words":["hot","dot","dog","lot","log","cog"]}</textarea>
                        </div>
                        <div style="display:flex; flex-direction:column; gap:5px;">
                            <button onclick="runVisualizer()">Transform</button>
                            <div style="display:flex; gap:5px;">
                                <button onclick="loadExample(1)" style="background:#475569; font-size:0.8rem; padding:5px;">Hit-Cog</button>
                                <button onclick="loadExample(2)" style="background:#475569; font-size:0.8rem; padding:5px;">Cat-Dog</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="visualization-area">
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background:#3b82f6"></div>Start</div>
                        <div class="legend-item"><div class="legend-color" style="background:#ef4444"></div>End</div>
                        <div class="legend-item"><div class="legend-color" style="background:#f59e0b"></div>Visited</div>
                        <div class="legend-item"><div class="legend-color" style="background:#22c55e"></div>Path</div>
                    </div>
                    
                    <div class="graph-viewport">
                        <svg id="viz-svg"><g id="zoom-group"></g></svg>
                    </div>
                    
                    <div class="stats-panel">
                        <div class="stat-box">
                            <div class="stat-label">Level</div>
                            <div class="stat-val" id="levelDisplay">0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Shortest Path</div>
                            <div class="stat-val" id="answerDisplay">0</div>
                        </div>
                    </div>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn" onclick="runVisualizer()">‚Üª ÈáçÁΩÆ</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">2x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'int ladderLength(string beginWord, string endWord, vector<string>& wordList) {', id: 0 },
            { line: '    unordered_set<string> dict(wordList.begin(), wordList.end());', id: 1 },
            { line: '    if (!dict.count(endWord)) return 0;', id: 2 },
            { line: '    queue<string> q; q.push(beginWord);', id: 3 },
            { line: '    int level = 1;', id: 4 },
            { line: '    while (!q.empty()) {', id: 5 },
            { line: '        int size = q.size();', id: 6 },
            { line: '        while(size--) {', id: 7 },
            { line: '            string curr = q.front(); q.pop();', id: 8 },
            { line: '            if (curr == endWord) return level;', id: 9 },
            { line: '            for (int i = 0; i < curr.size(); ++i) {', id: 10 },
            { line: '               // Try changing char', id: 11 },
            { line: '               if (dict.count(next)) {', id: 12 },
            { line: '                   dict.erase(next); q.push(next);', id: 13 },
            { line: '               }', id: 14 },
            { line: '            }', id: 15 },
            { line: '        }', id: 16 },
            { line: '        level++;', id: 17 },
            { line: '    }', id: 18 },
            { line: '    return 0;', id: 19 },
            { line: '}', id: 20 }
        ];

        let viz;

        function oneCharDiff(a, b) {
            if (a.length !== b.length) return false;
            let diff = 0;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) diff++;
                if (diff > 1) return false;
            }
            return diff === 1;
        }

        function simulate(input) {
            const steps = [];
            const { begin, end, words } = input;
            
            // Build visual graph first
            // Note: In real BFS we don't build full graph, but implicitly traverse.
            // For visualization, seeing connections is helpful.
            // Nodes: begin + words
            const allWords = Array.from(new Set([begin, ...words]));
            const wordMap = {};
            allWords.forEach((w,i) => wordMap[w] = i);
            
            const nodes = allWords.map((w,i) => ({id: i, label: w}));
            const links = [];
            for(let i=0; i<allWords.length; i++) {
                for(let j=i+1; j<allWords.length; j++) {
                    if(oneCharDiff(allWords[i], allWords[j])) {
                        links.push({source: i, target: j});
                    }
                }
            }

            const pushState = (msg, hl, activeWord, visitedSet, pathSet, level, result) => {
                steps.push({
                    graph: {nodes, links}, // Static structure
                    visited: new Set(visitedSet),
                    path: new Set(pathSet),
                    activeWord,
                    level,
                    result,
                    msg, highlightLines: hl
                });
            };

            // BFS
            const dict = new Set(words);
            if(!dict.has(end)) {
                pushState(`End word "${end}" not in list! Impossible.`, [2], null, [], [], 0, 0);
                return steps;
            }
            
            const q = [begin];
            const visited = new Set([begin]); // standard bfs tracks visited
            const parent = {}; // to reconstruct path
            let level = 1;
            
            pushState(`Start BFS from "${begin}"`, [3], begin, [begin], [], 1, 0);

            let found = false;
            
            while(q.length > 0) {
                const size = q.length;
                const currentLevelNodes = [];
                
                // Process level
                for(let k=0; k<size; k++) {
                    const curr = q.shift();
                    currentLevelNodes.push(curr);
                    
                    if(curr === end) {
                        found = true;
                        break;
                    }
                    
                    //Neighbors
                    for(let w of allWords) {
                        if(oneCharDiff(curr, w) && dict.has(w) && !visited.has(w)) {
                            visited.add(w);
                            q.push(w);
                            parent[w] = curr;
                        } else if (oneCharDiff(curr, w) && w === end && !visited.has(w)) {
                             // Special case if end is in dict (checked above)
                             // If end reached
                             visited.add(w);
                             q.push(w);
                             parent[w] = curr;
                        }
                    }
                }
                
                if(found) break;
                
                pushState(`Level ${level} processed. Next Queue Size: ${q.length}`, [17], null, Array.from(visited), [], level, 0);
                level++;
            }
            
            if(found) {
                // Reconstruct path
                const path = [];
                let curr = end;
                while(curr) {
                    path.push(curr);
                    curr = parent[curr];
                }
                const pathSet = new Set(path);
                pushState(`Found "${end}" at Level ${level}! Path reconstruction.`, [9], end, Array.from(visited), path, level, level);
            } else {
                pushState(`Queue empty. "${end}" unreachable.`, [19], null, Array.from(visited), [], level, 0);
            }

            return steps;
        }

        // --- Render ---
        const svg = d3.select("#viz-svg");
        const gZoom = d3.select("#zoom-group");
        const zoom = d3.zoom().on("zoom", (e) => gZoom.attr("transform", e.transform));
        svg.call(zoom);

        // Force Sim
        let simulation = d3.forceSimulation()
            .force("charge", d3.forceManyBody().strength(-300))
            .force("link", d3.forceLink().id(d => d.id).distance(100))
            .force("center", d3.forceCenter(400, 225));

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;
            document.getElementById('levelDisplay').textContent = step.level;
            document.getElementById('answerDisplay').textContent = step.result;

            // Nodes
            const { begin, end } = JSON.parse(document.getElementById('gridInput').value); // Crude access to current config
            
            gZoom.selectAll(".node-rect")
                .attr("class", d => {
                    let c = "node-rect";
                    if (d.label === begin) c += " start";
                    else if (d.label === end) c += " end";
                    else if (step.path.has(d.label)) c += " path"; // Path overrides visited
                    else if (step.visited.has(d.label)) c += " visited";
                    
                    if (d.label === step.activeWord) c += " current";
                    return c;
                });
            
            // Links
            // Highlight links on path?
            // If both source/target in path, maybe?
            gZoom.selectAll(".link")
                .attr("class", d => {
                    if (step.path.has(d.source.label) && step.path.has(d.target.label)) return "link path";
                    return "link";
                });
        }

        function initGraph(nodes, links) {
            gZoom.selectAll("*").remove();
            
            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();

            const link = gZoom.append("g").selectAll(".link")
                .data(links).enter().append("line")
                .attr("class", "link");

            const node = gZoom.append("g").selectAll(".node-g")
                .data(nodes).enter().append("g")
                .attr("class", "node-g")
                .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));

            node.append("rect")
                .attr("width", 60).attr("height", 30)
                .attr("x", -30).attr("y", -15)
                .attr("class", "node-rect");

            node.append("text")
                .attr("class", "node-text")
                .attr("dy", 1)
                .text(d => d.label);

            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
                node
                    .attr("transform", d => `translate(${d.x},${d.y})`);
            });
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x; d.fy = d.y;
        }
        function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null; d.fy = null;
        }

        function runVisualizer() {
            try {
                const raw = document.getElementById('gridInput').value;
                const input = JSON.parse(raw);
                
                // Calc graph
                const allWords = Array.from(new Set([input.begin, ...input.words]));
                const nodes = allWords.map((w,i) => ({id: i, label: w}));
                const links = [];
                for(let i=0; i<allWords.length; i++) {
                    for(let j=i+1; j<allWords.length; j++) {
                        if(oneCharDiff(allWords[i], allWords[j])) {
                            links.push({source: i, target: j});
                        }
                    }
                }
                
                initGraph(nodes, links);
                
                viz = new AlgorithmVisualizer({
                    codeLines: codeStructure,
                    onStepChange: render
                });
                viz.setSteps(simulate(input));
            } catch(e) {
                alert("Invalid JSON");
                console.error(e);
            }
        }

        const examples = {
            1: '{"begin":"hit","end":"cog","words":["hot","dot","dog","lot","log","cog"]}',
            2: '{"begin":"cat","end":"dog","words":["cot","cog","dog","dat","dag"]}'
        };
        function loadExample(n) {
            document.getElementById('gridInput').value = examples[n];
            runVisualizer();
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
