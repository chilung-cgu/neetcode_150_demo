<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clone Graph - D3 Dynamic Viz</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            min-height: 500px;
        }

        .stage-viewport {
            width: 100%; height: 400px;
            background: rgba(30, 41, 59, 0.4);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(148, 163, 184, 0.2);
            position: relative;
        }
        #viz-svg { width: 100%; height: 100%; }

        /* Graph Nodes */
        .node-circle { fill: #334155; stroke: #475569; stroke-width: 2px; transition: all 0.3s; }
        .node-circle.original { }
        .node-circle.clone { fill: #22c55e; stroke: #10b981; }
        .node-circle.current { stroke: #fbbf24; stroke-width: 3px; filter: drop-shadow(0 0 5px #fbbf24); }
        .node-circle.visited { fill: #475569; }

        .node-text { fill: #fff; font-family: monospace; font-size: 14px; text-anchor: middle; dominant-baseline: middle; pointer-events: none; font-weight: bold; }
        
        .link-line { stroke: #64748b; stroke-width: 2px; }
        .link-line.clone { stroke: #22c55e; opacity: 0.6; }

        .stats-panel {
            display: flex; gap: 30px; justify-content: center; width: 95%;
            background: rgba(15, 23, 42, 0.6); padding: 15px; border-radius: 12px; border: 1px solid #475569;
        }
        .stat-box { text-align: center; }
        .stat-val { font-size: 1.2rem; font-weight: bold; color: #3b82f6; font-family: monospace; }
        .stat-label { font-size: 0.75rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px; }

        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; justify-content: center; }
        .input-group { display: flex; align-items: center; gap: 5px; }
        .input-row input { width: 300px; text-align: center; }
        
        .map-display {
             font-family: monospace; font-size: 0.8rem; color: #cbd5e1;
             max-height: 100px; overflow-y: auto; text-align: left;
             background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px; width: 200px;
        }
    </style>
</head>
<body>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Clone Graph (DFS/HashMap)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <div class="input-group">
                            <label>Adj List:</label>
                            <input type="text" id="adjInput" value="[[2,4],[1,3],[2,4],[1,3]]">
                        </div>
                        <button onclick="runVisualizer()">Clone</button>
                    </div>
                    <div style="font-size:0.8rem; color:#64748b; text-align:center; margin-top:5px;">1-indexed nodes. [[2,4]] means Node 1 connects to 2 and 4.</div>
                </div>

                <div class="visualization-area">
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background:#334155; border:1px solid #475569"></div>Original (Left)</div>
                        <div class="legend-item"><div class="legend-color" style="background:#22c55e; border:1px solid #10b981"></div>Cloned (Right)</div>
                        <div class="legend-item"><div class="legend-color" style="border:2px solid #fbbf24"></div>Current Process</div>
                    </div>

                    <div class="stage-viewport">
                        <svg id="viz-svg"></svg>
                        
                        <!-- Titles for Left/Right -->
                        <div style="position:absolute; top:10px; left:20%; color:#94a3b8; font-weight:bold;">Original</div>
                        <div style="position:absolute; top:10px; right:20%; color:#22c55e; font-weight:bold;">Clone</div>
                    </div>
                    
                    <div class="stats-panel">
                         <div class="stat-box">
                            <div class="stat-label">Nodes Created</div>
                            <div class="stat-val" id="nodesDisplay">0</div>
                        </div>
                         <div class="stat-box">
                            <div class="stat-label">HashMap Entries</div>
                            <div class="stat-val" id="mapDisplay">0</div>
                        </div>
                    </div>
                </div>

                <div class="step-breakdown">
                     <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">當前步驟</div>
                     <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">← 上一步</button>
                    <div class="step-indicator">步驟 <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">下一步 →</button>
                    <button class="viz-btn" onclick="runVisualizer()">↻ 重置</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">▶ 自動播放</button>
                    <div class="speed-control">
                        <label>速度:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                             <option value="1500">Slow</option>
                             <option value="1000" selected>Normal</option>
                             <option value="500">Fast</option>
                        </select>
                    </div>
                </div>
            </div>
             <div class="viz-card logic-card"><div class="viz-title">邏輯解釋</div><div class="explanation" id="explanation"></div></div>
        </div>
        
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'Node* cloneGraph(Node* node) {', id: 0 },
            { line: '    if (!node) return NULL;', id: 1 },
            { line: '    if (mp.count(node)) return mp[node];', id: 2 },
            { line: '    Node* copy = new Node(node->val);', id: 3 },
            { line: '    mp[node] = copy;', id: 4 },
            { line: '    for (Node* neighbor : node->neighbors) {', id: 5 },
            { line: '        copy->neighbors.push_back(cloneGraph(neighbor));', id: 6 },
            { line: '    }', id: 7 },
            { line: '    return copy;', id: 8 },
            { line: '}', id: 9 }
        ];

        let viz;

        function simulate(adjList) {
            const steps = [];
            // Reconstruct graph edges for Force Layout
            // Nodes are 1-indexed in input array (index 0 is Node 1's neighbors)
            const n = adjList.length;
            const nodes = [];
            for(let i=1; i<=n; i++) nodes.push({id: i});
            
            const links = [];
            const seenEdges = new Set();
            adjList.forEach((neighbors, i) => {
                const u = i+1;
                neighbors.forEach(v => {
                    const edgeId = u < v ? `${u}-${v}` : `${v}-${u}`;
                    if(!seenEdges.has(edgeId)) {
                         seenEdges.add(edgeId);
                         links.push({source: u, target: v});
                    }
                });
            });
            
            // Pre-calculate layout
            // We want simple static layout. Force simulation can run offline
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(60))
                .force("charge", d3.forceManyBody().strength(-200))
                .force("center", d3.forceCenter(0, 0)) // centered at 0,0 locally
                .stop();
                
            for (let i = 0; i < 300; ++i) simulation.tick();
            
            // Extract positions
            const layout = {};
            nodes.forEach(d => { layout[d.id] = {x: d.x, y: d.y}; });
            
            // Graph State
            // We track: Visited Nodes (Original), Cloned Nodes (Created), Cloned Edges
            const visited = new Set(); // original ids visited
            const map = {}; // oldId -> newId (just boolean existence effectively since id is same)
            // But visually we want to show 'Node 1 created'
            const clonedNodes = []; // ids
            const clonedLinks = []; // {source, target}
            
            steps.push({
                nodes, links, layout, clonedNodes: [], clonedLinks: [], map: {}, 
                cnt: 0, curr: null,
                msg: "Init. Graph Layout Calculated.", highlightLines: [0],
                explanation: {title: "初始化", text: "準備複製圖。左側為原圖，右側將建立複製圖。", formula: ""}
            });
            
            function dfs(u) {
                if (map[u]) {
                     steps.push({
                        nodes, links, layout, clonedNodes: [...clonedNodes], clonedLinks: [...clonedLinks], map: {...map},
                        cnt: Object.keys(map).length, curr: u,
                        msg: `Node ${u} already visited. Return Clone.`, highlightLines: [2],
                        explanation: {title: "已訪問", text: `節點 ${u} 已經複製過了，直接返回對應的複製節點。`, formula: "return mp[node]"}
                    });
                    return;
                }
                
                // Create clone
                map[u] = true;
                clonedNodes.push(u); // ID is same
                
                steps.push({
                    nodes, links, layout, clonedNodes: [...clonedNodes], clonedLinks: [...clonedLinks], map: {...map},
                    cnt: Object.keys(map).length, curr: u,
                    msg: `Visit ${u}. Create Clone ${u}'. Add to Map.`, highlightLines: [3, 4],
                    explanation: {title: "複製節點", text: `建立節點 ${u} 的副本，並存入 HashMap。`, formula: "mph[node] = new Node(val)"}
                });
                
                // Neighbors
                const neighbors = adjList[u-1];
                for(let v of neighbors) {
                    // Visual: Processing edge (u, v)
                    steps.push({
                        nodes, links, layout, clonedNodes: [...clonedNodes], clonedLinks: [...clonedLinks], map: {...map},
                        cnt: Object.keys(map).length, curr: u, processingNeighbor: v,
                        msg: `Processing neighbor ${v} of ${u}...`, highlightLines: [5],
                        explanation: {title: "遍歷鄰居", text: `處理鄰居 ${v}。遞迴呼叫 cloneGraph。`, formula: "cloneGraph(neighbor)"}
                    });

                    // Add edge to cloned graph if v exists (or after it returns)
                    // Actually DFS returns the clone. We add connection NOW in code logic: 
                    // copy -> neighbors.push_back( recursed );
                    // So we recurse first.
                    
                    const wasVisited = map[v];
                    dfs(v);
                    
                    // After return, link is established
                    // Check if link exists to avoid duplications in visual?
                    // Undirected graph: link 1-2 is same as 2-1.
                    // In code `neighbors.push_back`, so directed edge in data structure, effectively.
                    // Visual: add link u-v
                    const linkId = u < v ? `${u}-${v}` : `${v}-${u}`;
                    // Just push {source: u, target: v} for visual
                    // Filter duplicates in render if needed, or just allow double lines (directed)
                    // Let's check if we already added this undirected edge?
                    // Code adds directed edge u->v in v's list.
                    
                    // Let's just visualize the connection being made
                    clonedLinks.push({source: u, target: v});
                    
                    steps.push({
                        nodes, links, layout, clonedNodes: [...clonedNodes], clonedLinks: [...clonedLinks], map: {...map},
                        cnt: Object.keys(map).length, curr: u,
                        msg: `Connect Clone ${u}' to Clone ${v}'.`, highlightLines: [6],
                        explanation: {title: "建立連接", text: `將複製節點 ${u}' 與 ${v}' 連接。`, formula: "copy->neighbors.add(clone)"}
                    });
                }
            }
            
            if(nodes.length > 0) dfs(1);
            
            steps.push({
                nodes, links, layout, clonedNodes: [...clonedNodes], clonedLinks: [...clonedLinks], map: {...map},
                cnt: Object.keys(map).length, final: true,
                msg: "Deep Copy Completed.", highlightLines: [9],
                explanation: {title: "完成", text: "圖已深拷貝完成。", formula: "return copy"}
            });
            
            return steps;
        }

        // --- Render ---
        const svg = d3.select("#viz-svg");
        const width = 600;
        const height = 400;
        svg.attr("viewBox", `0 0 ${width} ${height}`);

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;
            if(step.cnt !== undefined) document.getElementById('mapDisplay').textContent = step.cnt;
            if(step.clonedNodes) document.getElementById('nodesDisplay').textContent = step.clonedNodes.length;
            
            if (step.explanation) {
                document.getElementById('explanation').innerHTML = `
                    <div class="expl-title">${step.explanation.title}</div>
                    <div class="expl-text">${step.explanation.text}</div>
                    <div class="expl-formula">${step.explanation.formula}</div>
                `;
            }
            
            // Clear
            svg.selectAll("*").remove(); // Bruteforce clear for Force layout static re-draw
            // Actually better to use update pattern but since layout is constant...
            
            // Offset for Left and Right Graphs
            const leftCenterX = width * 0.25;
            const rightCenterX = width * 0.75;
            const centerY = height / 2;
            
            const g = svg.append("g");
            
            // --- Draw Left Graph (Original) ---
            // Links
            step.links.forEach(l => {
                const s = step.layout[l.source];
                const t = step.layout[l.target];
                g.append("line").attr("class", "link-line")
                    .attr("x1", leftCenterX + s.x).attr("y1", centerY + s.y)
                    .attr("x2", leftCenterX + t.x).attr("y2", centerY + t.y);
            });
            
            // Nodes
            step.nodes.forEach(n => {
                const pos = step.layout[n.id];
                const isCurr = step.curr === n.id;
                
                const circle = g.append("circle").attr("class", `node-circle original ${isCurr ? 'current' : ''}`)
                    .attr("cx", leftCenterX + pos.x).attr("cy", centerY + pos.y)
                    .attr("r", 15);
                    
                g.append("text").attr("class", "node-text")
                    .attr("x", leftCenterX + pos.x).attr("y", centerY + pos.y)
                    .text(n.id);
            });
            
            // --- Draw Right Graph (Cloned) ---
            if(step.clonedLinks) {
                step.clonedLinks.forEach(l => {
                    const s = step.layout[l.source];
                    const t = step.layout[l.target];
                    // Verify both exist? Should exist by logic
                    if(s && t) {
                         g.append("line").attr("class", "link-line clone")
                        .attr("x1", rightCenterX + s.x).attr("y1", centerY + s.y)
                        .attr("x2", rightCenterX + t.x).attr("y2", centerY + t.y);
                    }
                });
            }
            
            if(step.clonedNodes) {
                step.clonedNodes.forEach(nid => {
                    const pos = step.layout[nid];
                    const isCurr = step.curr === nid;
                    
                    g.append("circle").attr("class", `node-circle clone ${isCurr ? 'current' : ''}`)
                        .attr("cx", rightCenterX + pos.x).attr("cy", centerY + pos.y)
                        .attr("r", 15);
                        
                    g.append("text").attr("class", "node-text")
                        .attr("x", rightCenterX + pos.x).attr("y", centerY + pos.y)
                        .text(nid + "'");
                });
            }
            
            // Divider
            g.append("line").attr("x1", width/2).attr("y1", 20).attr("x2", width/2).attr("y2", height-20)
                .attr("stroke", "#475569").attr("stroke-dasharray", "4,4").attr("opacity", 0.5);
        }

        function runVisualizer() {
            const raw = document.getElementById('adjInput').value;
            let adj;
            try {
                adj = JSON.parse(raw);
            } catch(e) { alert("Invalid JSON"); return; }
            
            if(!Array.isArray(adj)) return;

            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(adj));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
