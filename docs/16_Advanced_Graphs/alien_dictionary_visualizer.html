<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alien Dictionary - è¦–è¦ºåŒ–</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }

        .words-container { 
            display: flex; flex-direction: column; gap: 8px; align-items: center; 
            margin: 20px 0; padding: 15px; background: var(--viz-bg-secondary); border-radius: 8px;
        }
        .word { font-family: monospace; font-size: 1.2rem; font-weight: bold; transition: all 0.3s; }
        .word.highlight { color: var(--viz-warning); }
        .word .char { display: inline-block; padding: 2px 4px; }
        .word .char.diff { background: var(--viz-warning); color: #0f172a; border-radius: 3px; }

        .comparison-display {
            text-align: center; margin: 10px 0; padding: 12px;
            background: var(--viz-bg-secondary); border-radius: 8px;
            font-size: 0.95rem;
        }

        .edges-container { 
            display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; 
            margin: 10px 0; min-height: 40px; align-items: center;
        }
        .edge-item { 
            padding: 8px 15px; background: var(--viz-primary); color: white; 
            border-radius: 6px; font-family: monospace; font-size: 1rem;
        }
        .edge-item.new { animation: pulse 0.5s; }
        @keyframes pulse { 0%,100% { transform: scale(1); } 50% { transform: scale(1.1); } }

        .graph-container {
            display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin: 15px 0;
        }
        .letter-node {
            width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;
            border-radius: 50%; background: var(--viz-primary); color: white; font-weight: bold;
            font-size: 1.1rem; transition: all 0.3s;
        }
        .letter-node.processed { background: var(--viz-success); color: #0f172a; }

        .result-container { 
            text-align: center; margin: 15px 0; padding: 15px;
            background: var(--viz-bg-secondary); border-radius: 8px;
        }
        .result-value { font-size: 1.8rem; font-weight: bold; color: var(--viz-success); letter-spacing: 8px; font-family: monospace; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="åˆ‡æ›ä¸»é¡Œ">ğŸŒ“</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">å¤–æ˜Ÿå­—å…¸ (Alien Dictionary)</div>
                <div class="custom-input-section">
                    <div style="font-weight:bold; margin-bottom:5px;">ğŸ® è‡ªè¨‚æ¸¬è©¦</div>
                    <div class="input-row">
                        <button onclick="setExample(1)">ç¯„ä¾‹1 (æ¨™æº–)</button>
                        <button onclick="setExample(2)">ç¯„ä¾‹2 (ç°¡å–®)</button>
                        <button onclick="resetVisualization()">â†» é‡ç½®</button>
                    </div>
                </div>
                
                <div style="text-align: center; color: var(--viz-text-muted); font-size: 0.85rem;">å–®è©åˆ—è¡¨ï¼ˆæŒ‰å¤–æ˜Ÿèªé †åºæ’åˆ—ï¼‰</div>
                <div class="words-container" id="wordsDisplay"></div>
                
                <div class="comparison-display" id="comparisonDisplay"></div>
                
                <div style="text-align: center; color: var(--viz-text-muted); font-size: 0.85rem;">æ¨å°å‡ºçš„é †åºé—œä¿‚</div>
                <div class="edges-container" id="edgesDisplay"></div>
                
                <div style="text-align: center; color: var(--viz-text-muted); margin-top: 15px; font-size: 0.85rem;">å­—æ¯ç¯€é»ï¼ˆæ‹“æ’²æ’åºï¼‰</div>
                <div class="graph-container" id="graphDisplay"></div>
                
                <div class="result-container">
                    <div style="color: var(--viz-text-muted); font-size: 0.85rem; margin-bottom: 5px;">å¤–æ˜Ÿèªå­—æ¯é †åº</div>
                    <div class="result-value" id="resultDisplay">?</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">â† ä¸Šä¸€æ­¥</button>
                    <div class="step-indicator">æ­¥é©Ÿ <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">ä¸‹ä¸€æ­¥ â†’</button>
                    <div class="speed-control">
                        <label>é€Ÿåº¦:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">1x</option>
                            <option value="800">2x</option>
                        </select>
                    </div>
                </div>
                
                <div class="complexity-badge">
                    <span class="label">Time:</span> O(C) C=ç¸½å­—å…ƒæ•¸
                    <span class="label" style="margin-left: 12px;">Space:</span> O(1) æœ€å¤š26å­—æ¯
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">æ¼”ç®—æ³•èªªæ˜</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">æ‹“æ’²æ’åº (C++)</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'string alienOrder(vector<string>& words) {', id: 0 },
            { line: '    // 1. æ”¶é›†æ‰€æœ‰å­—æ¯ï¼Œå»ºåœ–', id: 1 },
            { line: '    unordered_map<char, set<char>> graph;', id: 2 },
            { line: '    unordered_map<char, int> inDegree;', id: 3 },
            { line: '    for (string& w : words) for (char c : w) inDegree[c] = 0;', id: 4 },
            { line: '    // 2. æ¯”è¼ƒç›¸é„°å–®è©ï¼Œæ¨å°é †åº', id: 5 },
            { line: '    for (int i = 0; i < words.size() - 1; i++) {', id: 6 },
            { line: '        æ‰¾ç¬¬ä¸€å€‹ä¸åŒå­—æ¯ c1, c2', id: 7 },
            { line: '        if (!graph[c1].count(c2)) {', id: 8 },
            { line: '            graph[c1].insert(c2); inDegree[c2]++;', id: 9 },
            { line: '        }', id: 10 },
            { line: '    }', id: 11 },
            { line: '    // 3. æ‹“æ’²æ’åº (BFS)', id: 12 },
            { line: '    queue<char> q;', id: 13 },
            { line: '    for (auto& [c, deg] : inDegree) if (deg == 0) q.push(c);', id: 14 },
            { line: '    string result;', id: 15 },
            { line: '    while (!q.empty()) { /* æ¨™æº–æ‹“æ’²æ’åº */ }', id: 16 },
            { line: '    return result.size() == inDegree.size() ? result : "";', id: 17 },
            { line: '}', id: 18 },
        ];
        
        const examples = {
            1: ['wrt', 'wrf', 'er', 'ett', 'rftt'],
            2: ['z', 'x', 'z']  // Invalid - cycle detected
        };
        
        let currentWords = examples[1];

        function setExample(n) {
            currentWords = examples[n];
            init();
        }

        function generateAlgorithmSteps(words) {
            const steps = [];
            
            // Collect all unique characters
            const allChars = new Set();
            for (const word of words) {
                for (const c of word) allChars.add(c);
            }
            const chars = [...allChars].sort();
            
            steps.push({
                words, chars, edges: [], processed: [], result: '',
                highlightLines: [0, 1, 2, 3, 4],
                explanation: { 
                    title: 'åˆå§‹åŒ–', 
                    text: `å–®è©: ${words.join(', ')}<br>å­—æ¯: ${chars.join(', ')}<br><br>æ¯”è¼ƒç›¸é„°å–®è©æ¨å°é †åº`,
                    formula: 'setup'
                }
            });

            // Build graph by comparing adjacent words
            const edges = [];
            const graph = {};
            const inDegree = {};
            for (const c of chars) {
                graph[c] = [];
                inDegree[c] = 0;
            }

            for (let i = 0; i < words.length - 1; i++) {
                const w1 = words[i], w2 = words[i + 1];
                let found = false;
                let diffIndex = -1;
                
                for (let j = 0; j < Math.min(w1.length, w2.length); j++) {
                    if (w1[j] !== w2[j]) {
                        const c1 = w1[j], c2 = w2[j];
                        if (!graph[c1].includes(c2)) {
                            graph[c1].push(c2);
                            inDegree[c2]++;
                            edges.push([c1, c2]);
                        }
                        found = true;
                        diffIndex = j;
                        
                        steps.push({
                            words, chars, edges: [...edges], processed: [],
                            comparing: [i, i + 1], diffIndex,
                            highlightLines: [6, 7, 8, 9],
                            explanation: { 
                                title: `æ¯”è¼ƒ "${w1}" vs "${w2}"`, 
                                text: `ç¬¬ ${j} ä½ä¸åŒ: ${c1} â‰  ${c2}<br>æ¨å°: ${c1} åœ¨ ${c2} ä¹‹å‰`,
                                formula: `${c1} â†’ ${c2}`
                            }
                        });
                        break;
                    }
                }
                
                // Invalid case: w1 is prefix of w2 but longer
                if (!found && w1.length > w2.length) {
                    steps.push({
                        words, chars, edges, processed: [], result: '', invalid: true,
                        highlightLines: [17],
                        explanation: { 
                            title: 'ç„¡æ•ˆè¼¸å…¥!', 
                            text: `"${w1}" æ¯” "${w2}" é•·ä½†æ˜¯å‰ç¶´<br>é€™åœ¨ä»»ä½•å­—å…¸é †åºä¸­éƒ½ä¸å¯èƒ½`,
                            formula: 'return ""'
                        }
                    });
                    return steps;
                }
            }

            // Topological sort
            const queue = [];
            for (const c of chars) {
                if (inDegree[c] === 0) queue.push(c);
            }
            
            const result = [];
            const processed = [];

            steps.push({
                words, chars, edges, processed: [], result: '',
                highlightLines: [12, 13, 14, 15],
                explanation: { 
                    title: 'é–‹å§‹æ‹“æ’²æ’åº', 
                    text: `å…¥åº¦ç‚º 0 çš„å­—æ¯: ${queue.join(', ')}<br>é€™äº›å¯ä»¥å…ˆè¼¸å‡º`,
                    formula: 'BFS'
                }
            });

            while (queue.length > 0) {
                const c = queue.shift();
                result.push(c);
                processed.push(c);
                
                for (const next of graph[c]) {
                    inDegree[next]--;
                    if (inDegree[next] === 0) {
                        queue.push(next);
                    }
                }
                
                steps.push({
                    words, chars, edges, processed: [...processed], 
                    result: result.join(''), currentChar: c,
                    highlightLines: [16],
                    explanation: { 
                        title: `è¼¸å‡º '${c}'`, 
                        text: `åŠ å…¥çµæœ: ${result.join('')}`,
                        formula: `result += '${c}'`
                    }
                });
            }

            // Check if all characters are processed (detect cycle)
            const finalResult = result.length === chars.length ? result.join('') : '';
            steps.push({
                words, chars, edges, processed, 
                result: finalResult, final: true,
                highlightLines: [17],
                explanation: { 
                    title: finalResult ? 'å®Œæˆ!' : 'æª¢æ¸¬åˆ°ç’°!', 
                    text: finalResult 
                        ? `å¤–æ˜Ÿèªå­—æ¯é †åº: ${finalResult}`
                        : 'å­˜åœ¨å¾ªç’°ä¾è³´ï¼Œç„¡æœ‰æ•ˆé †åº',
                    formula: finalResult ? `return "${finalResult}"` : 'return ""'
                }
            });

            return steps;
        }

        let viz;
        function init() {
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: (step) => {
                    // Words
                    const words = step.words || currentWords;
                    document.getElementById('wordsDisplay').innerHTML = words.map((w, i) => {
                        let cls = 'word';
                        if (step.comparing && (step.comparing[0] === i || step.comparing[1] === i)) {
                            cls += ' highlight';
                        }
                        let html = '';
                        for (let j = 0; j < w.length; j++) {
                            const charCls = step.diffIndex === j && step.comparing && 
                                (step.comparing[0] === i || step.comparing[1] === i) ? 'char diff' : 'char';
                            html += `<span class="${charCls}">${w[j]}</span>`;
                        }
                        return `<div class="${cls}">${html}</div>`;
                    }).join('');
                    
                    // Comparison
                    if (step.comparing) {
                        document.getElementById('comparisonDisplay').innerHTML = 
                            `æ­£åœ¨æ¯”è¼ƒ: <strong>${words[step.comparing[0]]}</strong> vs <strong>${words[step.comparing[1]]}</strong>`;
                    } else {
                        document.getElementById('comparisonDisplay').innerHTML = '';
                    }
                    
                    // Edges
                    const edges = step.edges || [];
                    document.getElementById('edgesDisplay').innerHTML = 
                        edges.length > 0 
                            ? edges.map(e => `<span class="edge-item">${e[0]} â†’ ${e[1]}</span>`).join('')
                            : '<span style="color: var(--viz-text-muted)">ç„¡</span>';
                    
                    // Graph nodes
                    const chars = step.chars || [];
                    const processed = step.processed || [];
                    document.getElementById('graphDisplay').innerHTML = 
                        chars.map(c => {
                            const cls = processed.includes(c) ? 'letter-node processed' : 'letter-node';
                            return `<div class="${cls}">${c}</div>`;
                        }).join('');
                    
                    // Result
                    document.getElementById('resultDisplay').textContent = step.result || '?';
                    document.getElementById('resultDisplay').style.color = 
                        step.invalid ? 'var(--viz-error)' : 'var(--viz-success)';
                }
            });
            viz.setSteps(generateAlgorithmSteps(currentWords));
        }
        
        function resetVisualization() { init(); }
        window.addEventListener('load', init);
    </script>
</body>
</html>
