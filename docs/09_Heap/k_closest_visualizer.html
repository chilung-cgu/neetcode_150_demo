<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K Closest Points to Origin - è¦–è¦ºåŒ–</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .canvas-container { position: relative; width: 100%; max-width: 320px; height: 320px; margin: 0 auto; background: #1e293b; border-radius: 12px; border: 2px solid var(--viz-border); overflow: hidden; }
        .grid-lines { position: absolute; inset: 0; background-image: linear-gradient(#334155 1px, transparent 1px), linear-gradient(90deg, #334155 1px, transparent 1px); background-size: 40px 40px; opacity: 0.3; }
        .axis { position: absolute; background: #64748b; opacity: 0.5; }
        .axis-x { top: 50%; left: 0; right: 0; height: 1px; }
        .axis-y { left: 50%; top: 0; bottom: 0; width: 1px; }
        .origin-point { position: absolute; top: 50%; left: 50%; width: 8px; height: 8px; background: var(--viz-error); border-radius: 50%; transform: translate(-50%, -50%); z-index: 10; box-shadow: 0 0 10px var(--viz-error); }
        .point { position: absolute; width: 12px; height: 12px; background: var(--viz-primary); border-radius: 50%; transform: translate(-50%, -50%); transition: all 0.3s; z-index: 5; cursor: default; }
        .point.visiting { border: 2px solid var(--viz-warning); width: 16px; height: 16px; z-index: 20; }
        .point.kept { background: var(--viz-success); box-shadow: 0 0 8px var(--viz-success); }
        .point.rejected { background: var(--viz-text-muted); opacity: 0.3; }
        
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
        .input-row input { padding: 8px 12px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }
        
        .heap-status { margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px; }
        .heap-bar { display: flex; gap: 4px; flex-wrap: wrap; justify-content: center; }
        .heap-item { padding: 4px 8px; background: var(--viz-success); border-radius: 4px; font-size: 0.8rem; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="åˆ‡æ›ä¸»é¡Œ">ğŸŒ“</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">K å€‹æœ€è¿‘çš„é»ï¼ˆMAX HEAPï¼‰</div>
                <div class="custom-input-section">
                    <div style="font-weight:bold; margin-bottom:5px;">ğŸ® è‡ªè¨‚æ¸¬è©¦</div>
                    <div class="input-row">
                        <label>é» (x,y):</label>
                        <input type="text" id="pointsInput" value="1,3; -2,2; 5,8; 0,1" style="width: 200px;" placeholder="x1,y1; x2,y2...">
                        <label>K:</label>
                        <input type="number" id="kInput" value="2" style="width: 50px;" min="1">
                        <button onclick="runCustomInput()">åŸ·è¡Œ</button>
                    </div>
                </div>
                
                <div class="canvas-container" id="canvas">
                    <div class="grid-lines"></div>
                    <div class="axis axis-x"></div>
                    <div class="axis axis-y"></div>
                    <div class="origin-point" title="åŸé» (0,0)"></div>
                </div>
                
                <div class="heap-status">
                    <div style="font-size: 0.9rem; margin-bottom: 5px;">Max Heap (Size â‰¤ K)</div>
                    <div class="heap-bar" id="heapDisplay"></div>
                </div>
                
                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">â† ä¸Šä¸€æ­¥</button>
                    <div class="step-indicator">æ­¥é©Ÿ <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">ä¸‹ä¸€æ­¥ â†’</button>
                    <button class="viz-btn" onclick="resetVisualization()">â†» é‡ç½®</button>
                    <div class="speed-control">
                        <label>é€Ÿåº¦:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">1x</option>
                            <option value="500">2x</option>
                        </select>
                    </div>
                </div>
                
                <div class="complexity-badge">
                    <span class="label">Time:</span> O(n log k)
                    <span class="label" style="margin-left: 12px;">Space:</span> O(k)
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">æ¼”ç®—æ³•èªªæ˜</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">æ¼”ç®—æ³• (C++)</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'vector<vector<int>> kClosest(points, k) {', id: 0 },
            { line: '    priority_queue<pair<int, int>> pq;', id: 1 },
            { line: '    for (auto& p : points) {', id: 2 },
            { line: '        int dist = p[0]*p[0] + p[1]*p[1];', id: 3 },
            { line: '        pq.push({dist, i});', id: 4 },
            { line: '        if (pq.size() > k) {', id: 5 },
            { line: '            pq.pop(); // ç§»é™¤æœ€é çš„', id: 6 },
            { line: '        }', id: 7 },
            { line: '    }', id: 8 },
            { line: '    return getAllItems(pq);', id: 9 },
            { line: '}', id: 10 },
        ];

        let currentPoints = [[1,3], [-2,2], [5,8], [0,1]];
        let currentK = 2;

        function parsePoints(str) {
            return str.split(';').map(s => {
                const parts = s.trim().split(',');
                if (parts.length !== 2) return null;
                const x = parseInt(parts[0]);
                const y = parseInt(parts[1]);
                return isNaN(x) || isNaN(y) ? null : [x, y];
            }).filter(p => p !== null);
        }

        function distSq(p) { return p[0]*p[0] + p[1]*p[1]; }

        function generateAlgorithmSteps(points, k) {
            const steps = [];
            const heap = []; // {dist, index}

            steps.push({
                points: points,
                heap: [],
                visitingIdx: null,
                rejectedIdxs: [],
                highlightLines: [0, 1],
                explanation: {
                    title: 'åˆå§‹åŒ– Max Heap',
                    text: `ç›®æ¨™ï¼šæ‰¾å‡ºé›¢åŸé»æœ€è¿‘çš„ ${k} å€‹é»<br>ç­–ç•¥ï¼šç¶­è­·å¤§å°ç‚º K çš„ Max Heap<br>å¦‚æœ Heap > Kï¼Œå½ˆå‡ºæœ€å¤§çš„ï¼ˆæœ€é çš„ï¼‰ï¼Œç•™ä¸‹çš„å°±æ˜¯æœ€è¿‘çš„ã€‚`,
                    formula: 'priority_queue (Max Heap)'
                }
            });

            const rejected = new Set();

            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const d = distSq(p);
                
                // Add to heap
                heap.push({d, i});
                heap.sort((a, b) => b.d - a.d); // Max heap: largest first

                let popped = null;
                if (heap.length > k) {
                    popped = heap.shift(); // Remove largest
                    rejected.add(popped.i);
                }

                steps.push({
                    points: points,
                    heap: [...heap],
                    visitingIdx: i,
                    rejectedIdxs: [...rejected],
                    poppedIdx: popped ? popped.i : null,
                    highlightLines: popped ? [3, 4, 5, 6] : [3, 4],
                    explanation: {
                        title: `è™•ç†é» [${p[0]}, ${p[1]}]`,
                        text: `è·é›¢å¹³æ–¹ = ${d}<br>${popped ? `Heap > Kï¼Œç§»é™¤æœ€é é» [${points[popped.i]}] (dist=${popped.d})` : `åŠ å…¥ Heap (ç›®å‰å¤§å° ${heap.length})`}`,
                        formula: `dist = ${p[0]}Â² + ${p[1]}Â² = ${d}`
                    }
                });
            }

            steps.push({
                points: points,
                heap: [...heap],
                visitingIdx: null,
                rejectedIdxs: [...rejected],
                final: true,
                highlightLines: [9],
                explanation: {
                    title: 'å®Œæˆ',
                    text: `Heap ä¸­å‰©ä¸‹çš„ ${heap.length} å€‹é»å³ç‚ºæœ€è¿‘çš„ K å€‹é»ã€‚<br>çµæœ: ${heap.map(h => `[${points[h.i]}]`).join(', ')}`,
                    formula: 'return heap'
                }
            });

            return steps;
        }

        function runCustomInput() {
            const pStr = document.getElementById('pointsInput').value;
            const kVal = parseInt(document.getElementById('kInput').value);
            const pts = parsePoints(pStr);
            if (pts.length === 0 || isNaN(kVal) || kVal < 1) {
                alert('è¼¸å…¥æ ¼å¼éŒ¯èª¤ (ç¯„ä¾‹: "1,2; 3,4") æˆ– K å€¼ç„¡æ•ˆ');
                return;
            }
            currentPoints = pts;
            currentK = kVal;
            init();
        }

        let viz;
        function init() {
            const maxVal = Math.max(...currentPoints.flat().map(Math.abs), 5);
            const scale = 140 / maxVal; // Map maxVal to ~140px (half canvas width)

            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: (step) => {
                    // Update Canvas
                    const canvas = document.getElementById('canvas');
                    // Remove existing points but keep grid/origin
                    const oldPoints = canvas.querySelectorAll('.point');
                    oldPoints.forEach(p => p.remove());

                    step.points.forEach((p, i) => {
                        const el = document.createElement('div');
                        el.className = 'point';
                        if (step.visitingIdx === i) el.classList.add('visiting');
                        else if (step.heap.some(h => h.i === i)) el.classList.add('kept');
                        else if (step.rejectedIdxs.includes(i)) el.classList.add('rejected');
                        
                        el.style.left = `calc(50% + ${p[0] * scale}px)`;
                        el.style.top = `calc(50% - ${p[1] * scale}px)`;
                        el.title = `[${p[0]},${p[1]}] dÂ²=${distSq(p)}`;
                        canvas.appendChild(el);
                    });

                    // Update Heap Display
                    document.getElementById('heapDisplay').innerHTML = step.heap.map(h => {
                        const p = step.points[h.i];
                        return `<div class="heap-item">[${p[0]},${p[1]}]<br>${h.d}</div>`;
                    }).join('');
                }
            });
            viz.setSteps(generateAlgorithmSteps(currentPoints, currentK));
        }

        function resetVisualization() { init(); }
        window.addEventListener('load', init);
    </script>
</body>
</html>
