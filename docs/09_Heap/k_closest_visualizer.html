<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>K Closest Points (Max Heap) - Á≤æÁ∑ªË¶ñË¶∫Âåñ</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .dual-view {
            display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;
        }

        .panel {
            background: rgba(30, 41, 59, 0.4); border-radius: 12px; padding: 10px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            display: flex; flex-direction: column; align-items: center;
        }
        .panel-title { font-size: 0.9rem; color: #94a3b8; font-weight: bold; margin-bottom: 10px; }

        /* Chart View */
        #chart-svg { width: 300px; height: 300px; background: rgba(0,0,0,0.2); border-radius: 8px; }
        .point { fill: #94a3b8; transition: all 0.3s; }
        .point.active { fill: #fbbf24; r: 6; }
        .point.kept { fill: #22c55e; }
        .grid-line { stroke: #475569; stroke-width: 1; opacity: 0.3; }
        .axis { stroke: #cbd5e1; stroke-width: 2; }

        /* Heap View */
        #heap-svg { width: 300px; height: 300px; }
        .node-circle { fill: #3b82f6; stroke: none; transition: all 0.3s; }
        .node-circle.root { stroke: #ef4444; stroke-width: 3px; } /* Max Heap Root is largest dist */
        .node-text { fill: white; font-family: monospace; font-size: 10px; pointer-events: none; text-anchor: middle; dominant-baseline: middle; }
        .link { stroke: #64748b; stroke-width: 2px; opacity: 0.5; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 150px; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }

        .step-breakdown {
            background: rgba(30, 41, 59, 0.6);
            border-radius: 12px; border-left: 4px solid #3b82f6;
            padding: 15px 20px;
        }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">K Closest Points (Max Heap)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label>Points (x,y;...):</label>
                        <input type="text" id="pointsInput" value="1,3; -2,2; 5,8; 0,1">
                        <label>K:</label>
                        <input type="number" id="kInput" value="2" style="width:50px">
                        <button onclick="runVisualizer()">Âü∑Ë°å</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <div class="dual-view">
                        <div class="panel">
                            <div class="panel-title">2D Plane (Ë∑ùÈõ¢ÂéüÈªû)</div>
                            <svg id="chart-svg">
                                <!-- Grid -->
                                <line x1="0" y1="150" x2="300" y2="150" class="axis" />
                                <line x1="150" y1="0" x2="150" y2="300" class="axis" />
                                <g id="points-g"></g>
                            </svg>
                        </div>
                        <div class="panel">
                            <div class="panel-title">Max Heap (Size K)</div>
                            <svg id="heap-svg"><g id="heap-g"></g></svg>
                        </div>
                    </div>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn" onclick="runVisualizer()">‚Üª ÈáçÁΩÆ</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'vector<vector<int>> kClosest(points, k) {', id: 0 },
            { line: '    priority_queue<pair<int, int>> maxHeap;', id: 1 },
            { line: '    for (auto& p : points) {', id: 2 },
            { line: '        int dist = p[0]*p[0] + p[1]*p[1];', id: 3 },
            { line: '        maxHeap.push({dist, i});', id: 4 },
            { line: '        if (maxHeap.size() > k) {', id: 5 },
            { line: '            maxHeap.pop(); // Remove farthest', id: 6 },
            { line: '        }', id: 7 },
            { line: '    }', id: 8 },
            { line: '    return all in heap;', id: 9 },
            { line: '}', id: 10 }
        ];

        let viz;

        function simulate(points, k) {
            const steps = [];
            // Heap stores {dist, index}
            // Max Heap logic: parent > children
            let heap = []; 
            
            const swap = (i, j) => [heap[i], heap[j]] = [heap[j], heap[i]];
            const siftUp = (i) => {
                while(i > 0) {
                    let p = Math.floor((i-1)/2);
                    if(heap[i].dist > heap[p].dist) { swap(i, p); i=p; } else break;
                }
            };
            const siftDown = (i) => {
                while(true) {
                    let l=2*i+1, r=2*i+2, large=i;
                    if(l<heap.length && heap[l].dist > heap[large].dist) large=l;
                    if(r<heap.length && heap[r].dist > heap[large].dist) large=r;
                    if(large!==i) { swap(i, large); i=large; } else break;
                }
            };
            const push = (item) => { heap.push(item); siftUp(heap.length-1); };
            const pop = () => {
                if(heap.length===0) return;
                const top = heap[0];
                const last = heap.pop();
                if(heap.length > 0) { heap[0] = last; siftDown(0); }
                return top;
            };

            steps.push({
                heap: [], allPoints: points, activeP: null,
                msg: `ÂàùÂßãÂåñ K=${k}, Ê∫ñÂÇôËôïÁêÜ ${points.length} ÂÄãÈªû`,
                highlightLines: [1]
            });

            for(let i=0; i<points.length; i++) {
                const p = points[i];
                const dist = p[0]*p[0] + p[1]*p[1];
                
                steps.push({
                    heap: JSON.parse(JSON.stringify(heap)), allPoints: points, activeP: i,
                    msg: `ËôïÁêÜÈªû [${p[0]}, ${p[1]}]ÔºåË∑ùÈõ¢Âπ≥Êñπ=${dist}`,
                    highlightLines: [2, 3]
                });

                push({dist, i, p});
                steps.push({
                    heap: JSON.parse(JSON.stringify(heap)), allPoints: points, activeP: i,
                    msg: `Push Âà∞ Heap`,
                    highlightLines: [4]
                });

                if (heap.length > k) {
                    const removed = pop();
                    steps.push({
                        heap: JSON.parse(JSON.stringify(heap)), allPoints: points, activeP: i,
                        msg: `Heap size > KÔºåÁßªÈô§ÊúÄÈÅ†Èªû [${removed.p[0]}, ${removed.p[1]}] (Dist=${removed.dist})`,
                        highlightLines: [6]
                    });
                }
            }

            steps.push({
                heap: JSON.parse(JSON.stringify(heap)), allPoints: points, activeP: null,
                msg: `ÂÆåÊàêÔºÅHeap ‰∏≠Ââ©‰∏ãÁöÑ ${heap.length} ÂÄãÈªûÂç≥ÁÇ∫ÊúÄËøëÈªû`,
                highlightLines: [9],
                final: true
            });

            return steps;
        }

        const gPoints = d3.select("#points-g");
        const gHeap = d3.select("#heap-g").attr("transform", "translate(0, 40)");

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;

            // Render Chart
            gPoints.selectAll("*").remove();
            // Scale logic simple: fixed 300x300, center at 150,150. range -10 to 10 mapped to 0-300
            const scale = (v) => 150 + v * 15;
            
            step.allPoints.forEach((p, idx) => {
                const isActive = step.activeP === idx;
                const isInHeap = step.heap.some(h => h.i === idx);
                
                gPoints.append("circle")
                    .attr("cx", scale(p[0]))
                    .attr("cy", scale(-p[1])) // y inverted in svg
                    .attr("r", 4)
                    .attr("class", `point ${isActive?'active':''} ${isInHeap?'kept':''}`);
            });

            // Render Heap
            if(step.heap.length === 0) {
                gHeap.selectAll("*").remove(); return;
            }
            
            const stratify = (idx) => {
                if(idx >= step.heap.length) return null;
                const node = { id: idx, val: step.heap[idx], children: [] };
                const l = stratify(2*idx+1);
                const r = stratify(2*idx+2);
                if(l) node.children.push(l);
                if(r) node.children.push(r);
                return node;
            };
            const root = d3.hierarchy(stratify(0));
            const treeLayout = d3.tree().size([280, 220]);
            treeLayout(root);

            // Links
            const links = gHeap.selectAll(".link").data(root.links());
            links.enter().append("path").attr("class", "link")
                .merge(links).attr("d", d3.linkVertical().x(d=>d.x).y(d=>d.y));
            links.exit().remove();

            // Nodes
            const nodes = gHeap.selectAll(".node").data(root.descendants());
            const nEnter = nodes.enter().append("g").attr("class", "node");
            nEnter.append("circle").attr("r", 15).attr("class", "node-circle");
            nEnter.append("text").attr("class", "node-text").attr("dy", 1);
            
            const nUpdate = nodes.merge(nEnter).attr("transform", d=>`translate(${d.x},${d.y})`);
            nUpdate.select(".node-circle").attr("class", d => {
                let s = "node-circle";
                if(d.data.id === 0) s += " root";
                return s;
            });
            nUpdate.select(".node-text").text(d => d.data.val.dist);
            
            nodes.exit().remove();
        }

        function runVisualizer() {
            const pStr = document.getElementById('pointsInput').value;
            const k = parseInt(document.getElementById('kInput').value);
            
            const points = pStr.split(';').map(s => {
                const parts = s.split(',').map(x=>parseInt(x.trim()));
                return (parts.length===2 && !isNaN(parts[0])) ? parts : null;
            }).filter(x=>x);
            
            if(points.length===0 || isNaN(k)) return;

            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(points, k));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
