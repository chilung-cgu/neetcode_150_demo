<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Find Median from Data Stream - è¦–è¦ºåŒ–</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .heap-container { display: flex; gap: 20px; justify-content: center; margin: 20px 0; }
        .heap-wrapper { text-align: center; }
        .heap-title { font-size: 0.9rem; margin-bottom: 8px; font-weight: bold; }
        .heap-items { display: flex; flex-direction: column-reverse; gap: 4px; align-items: center; min-height: 120px; width: 120px; padding: 10px; background: rgba(0,0,0,0.1); border-radius: 8px; border: 2px dashed var(--viz-border); }
        .heap-item { 
            padding: 8px 14px; border-radius: 4px; font-family: monospace; font-weight: bold; 
            min-width: 40px; text-align: center; transition: all 0.3s;
        }
        .max-heap .heap-title { color: var(--viz-primary); }
        .max-heap .heap-items { border-color: var(--viz-primary); }
        .max-heap .heap-item { background: var(--viz-primary); color: white; }
        
        .min-heap .heap-title { color: var(--viz-secondary); }
        .min-heap .heap-items { border-color: var(--viz-secondary); }
        .min-heap .heap-item { background: var(--viz-secondary); color: #0f172a; }
        
        .heap-item.new { box-shadow: 0 0 10px var(--viz-warning); transform: scale(1.1); }
        
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
        .input-row input { padding: 8px 12px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="åˆ‡æ›ä¸»é¡Œ">ğŸŒ“</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">æ•¸æ“šæµä¸­çš„ä¸­ä½æ•¸ (Two Heaps)</div>
                <div class="custom-input-section">
                    <div style="font-weight:bold; margin-bottom:5px;">ğŸ® è‡ªè¨‚æ¸¬è©¦</div>
                    <div class="input-row">
                        <label>åˆå§‹æ•¸å­—:</label>
                        <input type="text" id="initNums" value="1, 2, 3" style="width: 120px;" placeholder="1, 2, 3">
                        <button onclick="resetWithCustom()">è¨­ç½®åˆå§‹</button>
                    </div>
                    <div class="input-row">
                        <label>åŠ å…¥æ•¸å­—:</label>
                        <input type="number" id="addNumInput" value="4" style="width: 60px;">
                        <button onclick="addSingleNum()">Add Num</button>
                    </div>
                </div>
                
                <div class="heap-container">
                    <div class="heap-wrapper max-heap">
                        <div class="heap-title">Smaller Half (Max Heap)</div>
                        <div class="heap-items" id="maxHeapDisplay"></div>
                    </div>
                    <div class="heap-wrapper min-heap">
                        <div class="heap-title">Larger Half (Min Heap)</div>
                        <div class="heap-items" id="minHeapDisplay"></div>
                    </div>
                </div>
                
                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">â† ä¸Šä¸€æ­¥</button>
                    <div class="step-indicator">æ­¥é©Ÿ <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">ä¸‹ä¸€æ­¥ â†’</button>
                    <button class="viz-btn" onclick="resetVisualization()">â†» é‡ç½®</button>
                    <div class="speed-control">
                        <label>é€Ÿåº¦:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">1x</option>
                            <option value="500">2x</option>
                        </select>
                    </div>
                </div>
                
                <div class="complexity-badge">
                    <span class="label">Time:</span> O(log n) add
                    <span class="label" style="margin-left: 12px;">Space:</span> O(n)
                </div>
                <div class="state-grid">
                    <div class="state-item"><div class="state-label">ç¸½æ•¸ n</div><div class="state-value" id="countDisplay">0</div></div>
                    <div class="state-item"><div class="state-label">ä¸­ä½æ•¸</div><div class="state-value" id="medianDisplay" style="color: var(--viz-success);">?</div></div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">æ¼”ç®—æ³•èªªæ˜</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">æ¼”ç®—æ³• (C++)</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'class MedianFinder {', id: 0 },
            { line: '    priority_queue<int> maxHeap; // å·¦åŠéƒ¨ (Smaller)', id: 1 },
            { line: '    priority_queue<int, vector<int>, greater<int>> minHeap; // å³åŠéƒ¨ (Larger)', id: 2 },
            { line: '    void addNum(int num) {', id: 3 },
            { line: '        maxHeap.push(num);', id: 4 },
            { line: '        minHeap.push(maxHeap.top()); maxHeap.pop();', id: 5 },
            { line: '        if (minHeap.size() > maxHeap.size()) {', id: 6 },
            { line: '            maxHeap.push(minHeap.top()); minHeap.pop();', id: 7 },
            { line: '        }', id: 8 },
            { line: '    }', id: 9 },
            { line: '    double findMedian() {', id: 10 },
            { line: '        if (maxHeap.size() > minHeap.size()) return maxHeap.top();', id: 11 },
            { line: '        return (maxHeap.top() + minHeap.top()) / 2.0;', id: 12 },
            { line: '    }', id: 13 },
            { line: '};', id: 14 },
        ];

        let initialNums = [1, 2, 3];
        let addedNums = []; // To track added numbers interactively

        function parseNums(str) {
            return str.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
        }

        function generateAlgorithmSteps(initList, addList) {
            const steps = [];
            const maxH = [], minH = []; // Simulating heaps with arrays
            
            // Helper to maintain heap property conceptually (array sort)
            const rebalance = () => {
                maxH.sort((a,b) => b-a);
                minH.sort((a,b) => a-b);
            };

            const allNums = [...initList];
            
            steps.push({
                maxH: [], minH: [], median: null, count: 0,
                explanation: { title: 'åˆå§‹åŒ–', text: 'å»ºç«‹å…©å€‹ Heapï¼š<br>Max Heap (å·¦åŠéƒ¨, å„²å­˜è¼ƒå°çš„ä¸€åŠ)<br>Min Heap (å³åŠéƒ¨, å„²å­˜è¼ƒå¤§çš„ä¸€åŠ)' }
            });

            // Replay all inputs
            let currentCount = 0;
            const processNum = (num, isNewAdd) => {
                currentCount++;
                
                // 1. push to maxHeap
                maxH.push(num);
                rebalance();
                steps.push({
                    maxH: [...maxH], minH: [...minH], count: currentCount,
                    newNum: isNewAdd ? num : undefined,
                    highlightLines: [4],
                    explanation: { 
                        title: `åŠ å…¥ ${num}`, 
                        text: `æ¨å…¥ Max Heap`,
                        formula: `maxHeap.push(${num})`
                    }
                });

                // 2. move max of maxHeap to minHeap
                const topMax = maxH.shift();
                minH.push(topMax);
                rebalance();
                steps.push({
                    maxH: [...maxH], minH: [...minH], count: currentCount,
                    highlightLines: [5],
                    explanation: { 
                        title: `å¹³è¡¡: ç§»è‡³ Min Heap`, 
                        text: `å°‡ Max Heap æœ€å¤§å€¼ (${topMax}) ç§»è‡³ Min Heap<br>ç¢ºä¿å³åŠéƒ¨éƒ½å¤§æ–¼å·¦åŠéƒ¨`,
                        formula: `minHeap.push(${topMax})`
                    }
                });

                // 3. balance sizes
                if (minH.length > maxH.length) {
                    const topMin = minH.shift();
                    maxH.push(topMin);
                    rebalance();
                    steps.push({
                        maxH: [...maxH], minH: [...minH], count: currentCount,
                        highlightLines: [6, 7],
                        explanation: { 
                            title: `å¹³è¡¡: èª¿æ•´å¤§å°`, 
                            text: `Min Heap æ¯” Max Heap å¤šï¼Œç§»å›ä¸€å€‹ (${topMin})<br>ä¿æŒ Max Heap å¤§å° >= Min Heap (å·®æœ€å¤š 1)`,
                            formula: `size(min) > size(max) -> move back`
                        }
                    });
                }
                
                // Calculate Median
                let med;
                let formulaStr;
                if (maxH.length > minH.length) {
                    med = maxH[0];
                    formulaStr = 'maxHeap.top()';
                } else {
                    med = (maxH[0] + minH[0]) / 2.0;
                    formulaStr = `(${maxH[0]} + ${minH[0]}) / 2.0`;
                }

                steps.push({
                    maxH: [...maxH], minH: [...minH], count: currentCount,
                    median: med,
                    highlightLines: [11, 12],
                    explanation: { 
                        title: `è¨ˆç®—ä¸­ä½æ•¸`, 
                        text: `Max: ${maxH.length}, Min: ${minH.length}<br>ä¸­ä½æ•¸ = ${med}`,
                        formula: formulaStr
                    }
                });
            };

            for (const n of initList) processNum(n, false);
            for (const n of addList) {
                // For "added" numbers, we process them as part of the flow
                // But visualized as "Add" action
                 processNum(n, true);
            }

            return steps;
        }

        function resetWithCustom() {
            const str = document.getElementById('initNums').value;
            initialNums = parseNums(str);
            addedNums = []; // clear added
            init();
        }

        function addSingleNum() {
            const val = parseInt(document.getElementById('addNumInput').value);
            if (isNaN(val)) return;
            addedNums.push(val);
            init();
            // Auto jump to end to show the new addition
            setTimeout(() => {
                viz.setStep(viz.steps.length - 1); // Not exact, but close
            }, 100);
        }

        let viz;
        function init() {
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: (step) => {
                    // Render Heaps
                    document.getElementById('maxHeapDisplay').innerHTML = (step.maxH || []).map(n => 
                        `<div class="heap-item ${n === step.newNum ? 'new' : ''}">${n}</div>`
                    ).join('');
                    document.getElementById('minHeapDisplay').innerHTML = (step.minH || []).map(n => 
                        `<div class="heap-item ${n === step.newNum ? 'new' : ''}">${n}</div>`
                    ).join('');
                    
                    document.getElementById('countDisplay').textContent = step.count || 0;
                    document.getElementById('medianDisplay').textContent = step.median !== undefined && step.median !== null ? step.median : '?';
                }
            });
            viz.setSteps(generateAlgorithmSteps(initialNums, addedNums));
        }
        
        function resetVisualization() { 
            addedNums = [];
            init(); 
        }
        window.addEventListener('load', init);
    </script>
</body>
</html>
