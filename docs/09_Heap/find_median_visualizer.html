<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Find Median (Two Heaps) - Á≤æÁ∑ªË¶ñË¶∫Âåñ</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        /* Scale Visual */
        .scale-container {
            width: 500px; height: 300px; position: relative; margin-top: 30px;
        }
        
        .scale-bar {
            width: 400px; height: 8px; background: #64748b; border-radius: 4px;
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .scale-pivot {
            width: 0; height: 0; 
            border-left: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 40px solid #94a3b8;
            position: absolute; top: 56px; left: 50%; transform: translateX(-50%);
        }

        .heap-bucket {
            width: 140px; min-height: 120px;
            background: rgba(30, 41, 59, 0.6); border: 2px solid #475569;
            border-radius: 0 0 50px 50px;
            position: absolute; top: 18px; /* hang from bar */
            display: flex; flex-direction: column-reverse; align-items: center; padding: 10px; gap: 5px;
            transition: all 0.5s;
        }
        .bucket-left { left: 0; border-top: 4px solid #3b82f6; } /* Max Heap */
        .bucket-right { right: 0; border-top: 4px solid #a855f7; } /* Min Heap */
        
        .bucket-rope {
            width: 2px; height: 50px; background: #94a3b8; position: absolute; top: -50px; left: 50%;
        }

        .element {
            width: 36px; height: 36px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            animation: dropIn 0.4s;
        }
        .element.small { background: #3b82f6; }
        .element.large { background: #a855f7; }
        .element.top { border: 2px solid #fbbf24; z-index: 10; transform: scale(1.1); }

        @keyframes dropIn { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        .scale-label {
            position: absolute; top: -30px; width: 100%; text-align: center; color: #cbd5e1; font-weight: bold; font-size: 0.9rem;
        }

        /* Stats */
        .median-display {
            font-size: 2rem; font-weight: bold; color: #22c55e;
            text-shadow: 0 0 20px rgba(34, 197, 94, 0.4);
            margin-bottom: 10px;
        }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 80px; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; margin-top: 15px; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Find Median (Two Heaps)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label>Ê∑ªÂä†Êï∏Â≠ó:</label>
                        <input type="number" id="numInput" value="5">
                        <button onclick="handleAdd()">Add</button>
                        <button onclick="resetViz()" style="background:var(--viz-error)">Reset</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <div>Áï∂Ââç‰∏≠‰ΩçÊï∏ (Median)</div>
                    <div class="median-display" id="medianText">-</div>

                    <div class="scale-container">
                        <div class="scale-bar" id="scaleBar">
                            <div class="heap-bucket bucket-left" id="maxHeap">
                                <div class="bucket-rope"></div>
                                <div class="scale-label">Max Heap (Smaller Half)</div>
                            </div>
                            <div class="heap-bucket bucket-right" id="minHeap">
                                <div class="bucket-rope"></div>
                                <div class="scale-label">Min Heap (Larger Half)</div>
                            </div>
                        </div>
                        <div class="scale-pivot"></div>
                    </div>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'priority_queue<int> maxHeap; // Left', id: 0 },
            { line: 'priority_queue<int, ..., greater> minHeap; // Right', id: 1 },
            { line: 'void addNum(int num) {', id: 2 },
            { line: '    maxHeap.push(num);', id: 3 },
            { line: '    minHeap.push(maxHeap.top()); maxHeap.pop();', id: 4 },
            { line: '    if (maxHeap.size() < minHeap.size()) {', id: 5 },
            { line: '        maxHeap.push(minHeap.top()); minHeap.pop();', id: 6 },
            { line: '    }', id: 7 },
            { line: '}', id: 8 },
            { line: 'double findMedian() {', id: 9 },
            { line: '    return maxHeap.size() > minHeap.size()', id: 10 },
            { line: '       ? maxHeap.top()', id: 11 },
            { line: '       : (maxHeap.top() + minHeap.top()) / 2.0;', id: 12 },
            { line: '}', id: 13 }
        ];

        let viz;
        let leftHeap = []; // Max Heap (simulate sort for viz simplicity? No, heap order matters for 'top')
        // Actually, for visualization "bucket" view, sorted order or just pile is fine. 
        // But logic relies on TOP.
        // We will maintain sorted arrays for the simulator to easily get min/max
        let rightHeap = []; // Min Heap

        // Need proper heap Logic?
        // Let's just use array and sort for simulation simplicity since N is small
        // Left: Descending (Top is index 0)
        // Right: Ascending (Top is index 0)

        function simulateAdd(num) {
            const steps = [];
            
            // 1. Always push to MaxHeap first
            const lClone = [...leftHeap];
            const rClone = [...rightHeap];
            
            lClone.push(num);
            lClone.sort((a,b)=>b-a); // maintain max heap property simulate
            
            steps.push({
                left: [...lClone], right: [...rClone],
                msg: `Âä†ÂÖ• ${num} Âà∞ Max Heap (Â∑¶)`,
                highlightLines: [3]
            });

            // 2. Move Max of Left to Right
            const maxVal = lClone.shift(); // Top
            rClone.push(maxVal);
            rClone.sort((a,b)=>a-b); // maintain min heap
            
            steps.push({
                left: [...lClone], right: [...rClone],
                msg: `Âπ≥Ë°°: Â∞áÂ∑¶ÈÇäÊúÄÂ§ßÂÄº ${maxVal} ÁßªËá≥Âè≥ÈÇä`,
                highlightLines: [4]
            });

            // 3. Balance Sizes
            if (lClone.length < rClone.length) {
                const minVal = rClone.shift(); // Top of right
                lClone.push(minVal);
                lClone.sort((a,b)=>b-a);
                
                steps.push({
                    left: [...lClone], right: [...rClone],
                    msg: `Âπ≥Ë°°Â§ßÂ∞è: Â∑¶ < Âè≥ÔºåÂ∞áÂè≥ÈÇäÊúÄÂ∞èÂÄº ${minVal} ÁßªÂõûÂ∑¶ÈÇä`,
                    highlightLines: [5, 6]
                });
            }

            // Calculate Median
            let median;
            if (lClone.length > rClone.length) median = lClone[0];
            else median = (lClone[0] + rClone[0]) / 2.0;

            steps.push({
                left: [...lClone], right: [...rClone],
                median: median,
                msg: `Ë®àÁÆó‰∏≠‰ΩçÊï∏: ${median}`,
                highlightLines: [10, 11, 12]
            });

            return { steps, resLeft: lClone, resRight: rClone };
        }

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;
            if (step.median !== undefined) document.getElementById('medianText').textContent = step.median;
            
            // Render Buckets
            const renderBucket = (id, items, cls) => {
                const el = document.getElementById(id);
                // Keep the rope and label, clear elements
                // Actually easier to just append elements
                const old = el.querySelectorAll('.element');
                old.forEach(e => e.remove());
                
                items.forEach((val, idx) => {
                    const d = document.createElement('div');
                    let c = `element ${cls}`;
                    if(idx===0) c += ' top'; // visualize top
                    d.className = c;
                    d.textContent = val;
                    el.appendChild(d);
                });
            };

            renderBucket('maxHeap', step.left, 'small'); // small numbers
            renderBucket('minHeap', step.right, 'large'); // large numbers

            // Scale Animation
            const bar = document.getElementById('scaleBar');
            const diff = step.left.length - step.right.length;
            // if diff > 0 (Left heavier), rotate left down (-deg)
            // if diff < 0 (Right heavier), rotate right down (+deg)
            // Actually usually |diff| <= 1.
            
            let deg = 0;
            if (diff > 0) deg = -5;
            else if (diff < 0) deg = 5;
            
            bar.style.transform = `translateX(-50%) rotate(${deg}deg)`;
        }

        function handleAdd() {
            const val = parseInt(document.getElementById('numInput').value);
            if(isNaN(val)) return;
            
            const { steps, resLeft, resRight } = simulateAdd(val);
            leftHeap = resLeft;
            rightHeap = resRight;
            
            viz.setSteps(steps);
            viz.startAutoPlay();
        }

        function resetViz() {
            leftHeap = []; rightHeap = [];
            viz.setSteps([{left:[], right:[], median:'-', msg:"Â∑≤ÈáçÁΩÆ", highlightLines:[]}]);
            document.getElementById('medianText').textContent = '-';
        }

        window.addEventListener('load', () => {
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            // Initial state
            viz.setSteps([{left:[], right:[], msg:"Ê∫ñÂÇôÂ∞±Á∑í", highlightLines:[]}]);
        });
    </script>
</body>
</html>
