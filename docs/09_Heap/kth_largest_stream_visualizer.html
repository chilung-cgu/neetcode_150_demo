<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kth Largest Element in a Stream - Á≤æÁ∑ªË¶ñË¶∫Âåñ</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .dual-view {
            display: flex; flex-direction: column; align-items: center; gap: 20px;
        }

        /* Tree View */
        .tree-panel {
            width: 100%; height: 300px;
            background: rgba(30, 41, 59, 0.3);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }
        #tree-svg { width: 100%; height: 100%; }

        /* Array View */
        .array-view {
            display: flex; gap: 6px; padding: 15px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
            flex-wrap: wrap; justify-content: center;
        }
        .array-item {
            width: 40px; height: 40px;
            display: flex; align-items: center; justify-content: center;
            background: rgba(59, 130, 246, 0.2);
            color: #e2e8f0; font-family: monospace; font-weight: bold;
            border-radius: 6px;
            position: relative;
            transition: all 0.3s;
        }
        .array-item .idx {
            position: absolute; top: -18px; font-size: 0.6rem; color: #64748b;
        }
        .array-item.active { background: #fbbf24; color: #0f172a; transform: scale(1.1); z-index: 10; box-shadow: 0 0 10px #fbbf24; }
        .array-item.compare { background: #a855f7; color: white; }
        .array-item.root { border: 2px solid #22c55e; }

        /* D3 Styles */
        .node-circle { fill: #3b82f6; transition: fill 0.3s; stroke: #1e293b; stroke-width: 2px; }
        .node-circle.active { fill: #fbbf24; filter: drop-shadow(0 0 5px #fbbf24); }
        .node-circle.compare { fill: #a855f7; }
        .node-circle.root { stroke: #22c55e; stroke-width: 3px; }
        .node-text { fill: white; font-family: monospace; font-weight: bold; font-size: 14px; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        .link { stroke: #64748b; stroke-width: 2px; opacity: 0.5; fill: none; }

        /* Stats & Stream */
        .stats-panel {
            display: flex; gap: 20px; justify-content: center;
            background: rgba(15, 23, 42, 0.6); padding: 10px; border-radius: 8px;
        }
        .stat-item { text-align: center; }
        .stat-val { font-size: 1.2rem; font-weight: bold; color: #fbbf24; }
        .stat-label { font-size: 0.7rem; color: #94a3b8; text-transform: uppercase; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 80px; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; font-weight: 600; }

        .step-breakdown {
            background: rgba(30, 41, 59, 0.6);
            border-radius: 12px;
            padding: 15px 20px;
            border-left: 4px solid #3b82f6;
            margin-top: 15px;
            width: 100%; box-sizing: border-box;
        }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Kth Largest Element in a Stream (Min Heap)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label>K:</label>
                        <input type="number" id="kInput" value="3" min="1" style="width:50px">
                        <label>ÂàùÂßãÊµÅ (CSV):</label>
                        <input type="text" id="streamInput" value="4, 5, 8, 2" style="flex:1">
                        <button onclick="initViz()">ÂàùÂßãÂåñ</button>
                    </div>
                    <div class="input-row" style="margin-top:10px; border-top:1px solid rgba(255,255,255,0.1); paddingTop:10px;">
                        <label>Ê∑ªÂä†Êï∏Â≠ó:</label>
                        <input type="number" id="addInput" value="3" style="width:60px">
                        <button onclick="handleAdd()" style="background:#22c55e;">Add()</button>
                        <button onclick="resetViz()" style="background:var(--viz-error);">ÈáçÁΩÆ</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <div class="stats-panel">
                        <div class="stat-item"><div class="stat-val" id="kDisplay">3</div><div class="stat-label">K (Capacity)</div></div>
                        <div class="stat-item"><div class="stat-val" id="sizeDisplay">0</div><div class="stat-label">Heap Size</div></div>
                        <div class="stat-item"><div class="stat-val" id="kthDisplay">-</div><div class="stat-label">Kth Largest</div></div>
                    </div>
                    
                    <div class="dual-view">
                        <div class="array-view" id="arrayDisplay"></div>
                        <div class="tree-panel">
                            <svg id="tree-svg">
                                <g id="tree-g"></g>
                            </svg>
                        </div>
                    </div>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="800" selected>1x</option>
                            <option value="300">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="viz-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'class KthLargest {', id: 0 },
            { line: '    priority_queue<int, ..., greater<int>> minHeap;', id: 1 },
            { line: '    int k;', id: 2 },
            { line: '    int add(int val) {', id: 3 },
            { line: '        minHeap.push(val);', id: 4 },
            { line: '        if (minHeap.size() > k) {', id: 5 },
            { line: '            minHeap.pop();', id: 6 },
            { line: '        }', id: 7 },
            { line: '        return minHeap.top();', id: 8 },
            { line: '    }', id: 9 },
            { line: '};', id: 10 }
        ];

        let viz;
        // Global simulation state
        let k = 3;
        let heap = []; // Representing minHeap array

        // Helper to clone heap for steps
        const snap = () => JSON.parse(JSON.stringify(heap));

        function generateAddSteps(val, currentHeap, capacity) {
            const steps = [];
            let h = [...currentHeap];
            
            // 1. Push
            h.push(val);
            steps.push({
                heap: [...h],
                activeIdx: h.length - 1,
                highlightLines: [4],
                msg: `Âä†ÂÖ•ÂÄº ${val} Âà∞Â†ÜÂ∞æ`,
                kth: h[0]
            });

            // Sift Up
            let idx = h.length - 1;
            while (idx > 0) {
                let parentIdx = Math.floor((idx - 1) / 2);
                steps.push({
                    heap: [...h],
                    activeIdx: idx,
                    compareIdx: parentIdx,
                    highlightLines: [4], // Still processing push
                    msg: `ÊØîËºÉ: ${h[idx]} < ${h[parentIdx]} (Parent)?`,
                    kth: h[0]
                });

                if (h[idx] < h[parentIdx]) {
                    // Swap
                    [h[idx], h[parentIdx]] = [h[parentIdx], h[idx]];
                    steps.push({
                        heap: [...h],
                        activeIdx: parentIdx,
                        highlightLines: [4],
                        msg: `‰∫§Êèõ: ${h[parentIdx]} Ëàá ${h[idx]}`,
                        kth: h[0]
                    });
                    idx = parentIdx;
                } else {
                    break;
                }
            }

            // 2. Check Size
            steps.push({
                heap: [...h],
                highlightLines: [5],
                msg: `Ê™¢Êü•Â§ßÂ∞è: ${h.length} > ${capacity}?`,
                kth: h[0]
            });

            if (h.length > capacity) {
                // Pop Min (Root)
                const removed = h[0];
                h[0] = h[h.length - 1];
                h.pop();
                
                steps.push({
                    heap: [...h],
                    activeIdx: 0,
                    highlightLines: [6],
                    msg: `Â§ßÂ∞èË∂ÖÈÅé KÔºåÁßªÈô§Â†ÜÈ†Ç (ÊúÄÂ∞èÂÄº ${removed})ÔºåÂ∞áÂ∞æÈÉ® ${h[0]} ÁßªËá≥Â†ÜÈ†Ç`,
                    kth: h[0]
                });

                // Sift Down
                let i = 0;
                while (true) {
                    let left = 2 * i + 1;
                    let right = 2 * i + 2;
                    let smallest = i;

                    if (left < h.length) {
                        steps.push({
                            heap: [...h],
                            activeIdx: smallest,
                            compareIdx: left,
                            highlightLines: [6],
                            msg: `ÊØîËºÉ: ${h[smallest]} > ${h[left]} (Left)?`,
                            kth: h[0]
                        });
                        if (h[left] < h[smallest]) smallest = left;
                    }
                    
                    if (right < h.length) {
                        steps.push({
                            heap: [...h],
                            activeIdx: smallest,
                            compareIdx: right,
                            highlightLines: [6],
                            msg: `ÊØîËºÉ: ${h[smallest]} > ${h[right]} (Right)?`,
                            kth: h[0]
                        });
                        if (h[right] < h[smallest]) smallest = right;
                    }

                    if (smallest !== i) {
                        [h[i], h[smallest]] = [h[smallest], h[i]];
                        steps.push({
                            heap: [...h],
                            activeIdx: smallest,
                            highlightLines: [6],
                            msg: `‰∫§Êèõ: ${h[smallest]} Ëàá ${h[i]}`,
                            kth: h[0]
                        });
                        i = smallest;
                    } else {
                        break;
                    }
                }
            }

            // 3. Result
            steps.push({
                heap: [...h],
                activeIdx: 0,
                highlightLines: [8],
                msg: `ËøîÂõûÂ†ÜÈ†Ç (Á¨¨ K Â§ß): ${h[0]}`,
                kth: h[0]
            });

            return { steps, finalHeap: h };
        }

        // --- Render ---
        const svg = d3.select("#tree-svg");
        const gTree = d3.select("#tree-g");
        // Center tree g
        gTree.attr("transform", "translate(0, 40)");

        let width = 600, height = 300;

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;
            document.getElementById('sizeDisplay').textContent = step.heap.length;
            document.getElementById('kthDisplay').textContent = step.kth !== undefined ? step.kth : '-';

            // 1. Array View
            const arrC = document.getElementById('arrayDisplay');
            arrC.innerHTML = step.heap.map((val, i) => {
                let cls = 'array-item';
                if (i === 0) cls += ' root';
                if (i === step.activeIdx) cls += ' active';
                if (i === step.compareIdx) cls += ' compare';
                return `<div class="${cls}"><span class="idx">${i}</span>${val}</div>`;
            }).join('');

            // 2. Tree View
            // D3 Hierarchy from Array
            if (step.heap.length === 0) {
                gTree.selectAll("*").remove();
                return;
            }

            const stratify = (idx) => {
                if (idx >= step.heap.length) return null;
                const node = { id: idx, val: step.heap[idx], children: [] };
                const left = stratify(2 * idx + 1);
                const right = stratify(2 * idx + 2);
                if(left) node.children.push(left);
                if(right) node.children.push(right);
                return node;
            }
            
            const rootData = stratify(0);
            const hierarchy = d3.hierarchy(rootData);
            const treeLayout = d3.tree().size([document.querySelector('.tree-panel').clientWidth, 220]);
            treeLayout(hierarchy);

            // Links
            const links = gTree.selectAll(".link").data(hierarchy.links(), d => d.target.data.id);
            links.enter().append("path").attr("class", "link")
                .merge(links)
                .transition().duration(200)
                .attr("d", d3.linkVertical().x(d=>d.x).y(d=>d.y));
            links.exit().remove();

            // Nodes
            const nodes = gTree.selectAll(".node").data(hierarchy.descendants(), d => d.data.id);
            const nEnter = nodes.enter().append("g").attr("class", "node");
            nEnter.append("circle").attr("r", 18).attr("class", "node-circle");
            nEnter.append("text").attr("class", "node-text").attr("dy", 1);

            const nUpdate = nodes.merge(nEnter)
                .transition().duration(200)
                .attr("transform", d => `translate(${d.x},${d.y})`);
            
            nUpdate.select(".node-circle").attr("class", d => {
                let cls = "node-circle";
                if (d.data.id === 0) cls += " root";
                if (d.data.id === step.activeIdx) cls += " active";
                if (d.data.id === step.compareIdx) cls += " compare";
                return cls;
            });
            nUpdate.select(".node-text").text(d => d.data.val);
            
            nodes.exit().remove();
        }

        // Init
        function initViz() {
            k = parseInt(document.getElementById('kInput').value);
            const str = document.getElementById('streamInput').value;
            const nums = str.split(',').map(x=>parseInt(x.trim())).filter(x=>!isNaN(x));
            
            document.getElementById('kDisplay').textContent = k;
            
            // Build initial heap
            heap = [];
            // We can simulate add one by one, but for init let's just do it fast or reset
            // For now, let's treat init as empty then adding one by one internally without animation for initial state?
            // User likely wants to see initialization.
            // Let's just set heap empty and let user add or pre-populate logically.
            // Actually, problem says "initial stream".
            
            // Let's just fill it properly without detailed steps for init, just final state
            const pq = new MinPriorityQueue(); // Simple simulation
            for(let n of nums) {
                pq.enqueue(n);
                if(pq.size() > k) pq.dequeue();
            }
            heap = pq.values(); // Assuming we use a helper or manual array
            
            // Actually, let's implement array logic
            heap = [];
            for(let n of nums) {
               // push
               heap.push(n);
               // sift up
               let c = heap.length-1;
               while(c > 0) {
                   let p = Math.floor((c-1)/2);
                   if(heap[c] < heap[p]) { [heap[c],heap[p]] = [heap[p],heap[c]]; c = p; } else break;
               }
               // pop if needed
               if(heap.length > k) {
                   heap[0] = heap.pop();
                   // sift down
                   let i = 0;
                   while(true) {
                       let l=2*i+1, r=2*i+2, s=i;
                       if(l<heap.length && heap[l]<heap[s]) s=l;
                       if(r<heap.length && heap[r]<heap[s]) s=r;
                       if(s!==i) { [heap[i],heap[s]] = [heap[s],heap[i]]; i=s; } else break;
                   }
               }
            }

            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps([{
                heap: [...heap], activeIdx: null, msg: "ÂàùÂßãÂåñÂÆåÊàê", kth: heap.length>=k ? heap[0] : null, highlightLines: [1]
            }]);
        }

        function handleAdd() {
            const val = parseInt(document.getElementById('addInput').value);
            if(isNaN(val)) return;
            
            const { steps, finalHeap } = generateAddSteps(val, heap, k);
            heap = finalHeap;
            viz.setSteps(steps);
            viz.startAutoPlay();
        }

        function resetViz() {
            heap = [];
            viz.setSteps([{heap:[], msg:"Â∑≤ÈáçÁΩÆ", highlightLines:[]}]);
        }

        window.addEventListener('load', () => {
            initViz();
        });
    </script>
</body>
</html>
