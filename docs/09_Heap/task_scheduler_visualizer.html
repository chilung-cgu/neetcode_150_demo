<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Scheduler - è¦–è¦ºåŒ–</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
        .input-row input { padding: 8px 12px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }

        .timeline { display: flex; flex-wrap: wrap; gap: 4px; padding: 10px; background: rgba(0,0,0,0.1); border-radius: 8px; min-height: 50px; }
        .time-slot { width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border-radius: 4px; font-weight: bold; background: var(--viz-bg-secondary); border: 1px solid var(--viz-border); }
        .time-slot.task { background: var(--viz-primary); color: white; border-color: transparent; }
        .time-slot.idle { background: var(--viz-error); color: white; opacity: 0.5; }
        
        .freq-info { margin-top: 10px; display: flex; gap: 10px; justify-content: center; }
        .freq-badge { padding: 4px 8px; background: var(--viz-bg-secondary); border-radius: 4px; font-size: 0.9rem; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="åˆ‡æ›ä¸»é¡Œ">ğŸŒ“</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">ä»»å‹™èª¿åº¦å™¨ (Task Scheduler)</div>
                <div class="custom-input-section">
                    <div style="font-weight:bold; margin-bottom:5px;">ğŸ® è‡ªè¨‚æ¸¬è©¦</div>
                    <div class="input-row">
                        <label>ä»»å‹™:</label>
                        <input type="text" id="tasksInput" value="A,A,A,B,B,B" style="width: 150px;" placeholder="A,B,C...">
                        <label>å†·å»æ™‚é–“ n:</label>
                        <input type="number" id="nInput" value="2" style="width: 50px;" min="0">
                        <button onclick="runCustomInput()">åŸ·è¡Œ</button>
                    </div>
                </div>
                
                <div style="text-align: center; color: var(--text-muted); margin-top: 10px;">é »ç‡çµ±è¨ˆ</div>
                <div class="freq-info" id="freqDisplay"></div>
                
                <div style="text-align: center; color: var(--text-muted); margin-top: 20px;">åŸ·è¡Œæ™‚é–“ç·š (Greedy å¡«å……)</div>
                <div class="timeline" id="timelineDisplay"></div>
                
                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">â† ä¸Šä¸€æ­¥</button>
                    <div class="step-indicator">æ­¥é©Ÿ <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">ä¸‹ä¸€æ­¥ â†’</button>
                    <button class="viz-btn" onclick="resetVisualization()">â†» é‡ç½®</button>
                    <div class="speed-control">
                        <label>é€Ÿåº¦:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">1x</option>
                            <option value="500">2x</option>
                        </select>
                    </div>
                </div>
                
                <div class="complexity-badge">
                    <span class="label">Time:</span> O(n)
                    <span class="label" style="margin-left: 12px;">Space:</span> O(1)
                </div>
                <div class="state-grid">
                    <div class="state-item"><div class="state-label">maxFreq</div><div class="state-value" id="maxFreq">-</div></div>
                    <div class="state-item"><div class="state-label">maxCount</div><div class="state-value" id="maxCount">-</div></div>
                    <div class="state-item"><div class="state-label">æœ€å°‘æ™‚é–“</div><div class="state-value" id="resultDisplay" style="color: var(--viz-success);">?</div></div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">æ¼”ç®—æ³•èªªæ˜</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">æ¼”ç®—æ³• (C++)</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'int leastInterval(vector<char>& tasks, int n) {', id: 0 },
            { line: '    vector<int> freq(26);', id: 1 },
            { line: '    int maxFreq = 0;', id: 2 },
            { line: '    for (char t : tasks) {', id: 3 },
            { line: '        freq[t-\'A\']++;', id: 4 },
            { line: '        maxFreq = max(maxFreq, freq[t-\'A\']);', id: 5 },
            { line: '    }', id: 6 },
            { line: '    int maxCount = 0;', id: 7 },
            { line: '    for (int f : freq) if (f == maxFreq) maxCount++;', id: 8 },
            { line: '    ', id: 9 },
            { line: '    int partCount = maxFreq - 1;', id: 10 },
            { line: '    int partLength = n - (maxCount - 1);', id: 11 },
            { line: '    int emptySlots = partCount * partLength;', id: 12 },
            { line: '    int availableTasks = tasks.size() - maxFreq * maxCount;', id: 13 },
            { line: '    int idles = max(0, emptySlots - availableTasks);', id: 14 },
            { line: '    ', id: 15 },
            { line: '    return tasks.size() + idles;', id: 16 },
            { line: '}', id: 17 },
        ];

        let currentTasks = ['A','A','A','B','B','B'];
        let currentN = 2;

        function runCustomInput() {
            const tStr = document.getElementById('tasksInput').value.toUpperCase();
            const nVal = parseInt(document.getElementById('nInput').value);
            
            const tasks = tStr.split(/[^A-Z]/).filter(c => c && c.length === 1);
            if (tasks.length === 0 || isNaN(nVal) || nVal < 0) {
                alert('è¼¸å…¥ç„¡æ•ˆ');
                return;
            }
            currentTasks = tasks;
            currentN = nVal;
            init();
        }

        function generateAlgorithmSteps(tasks, n) {
            const steps = [];
            const freq = {};
            tasks.forEach(t => freq[t] = (freq[t] || 0) + 1);
            
            const maxFreq = Math.max(...Object.values(freq));
            const maxCount = Object.values(freq).filter(f => f === maxFreq).length;
            const totalTasks = tasks.length;
            
            // Step 1: Count Freq
            steps.push({
                timeline: [], freq, maxFreq, maxCount, n,
                highlightLines: [1,2,3,4,5,6],
                explanation: {
                    title: 'çµ±è¨ˆé »ç‡',
                    text: `ç¸½ä»»å‹™æ•¸: ${tasks.length}, n = ${n}<br>èˆ‡æœ€é«˜é »ç‡ä»»å‹™æ•¸é‡ç›¸åŒçš„æœ‰ ${maxCount} å€‹`,
                    formula: `maxFreq = ${maxFreq}, maxCount = ${maxCount}`
                }
            });

            // Step 2: Ideal frame calculation
            // Maximize visualization: Draw the chunks
            const timeline = [];
            const chunkCount = maxFreq - 1;
            const chunkLen = n + 1;
            
            steps.push({
                timeline: [], freq, maxFreq, maxCount, n,
                highlightLines: [10, 11, 12],
                explanation: {
                    title: 'å»ºç«‹éª¨æ¶',
                    text: `ä»¥æœ€é«˜é »ç‡ ${maxFreq} å»ºç«‹æ¡†æ¶ã€‚<br>éœ€è¦ ${maxFreq - 1} å€‹é–“éš”å€åŸŸï¼Œæ¯å€‹å€åŸŸé•·åº¦è‡³å°‘ ${n}ã€‚<br>æœ€å¾ŒåŠ ä¸Šçµå°¾çš„ ${maxCount} å€‹ä»»å‹™ã€‚`,
                    formula: `partCount = ${maxFreq} - 1 = ${maxFreq - 1}`
                }
            });

            // Formula calculation details
            // Formula: (maxFreq - 1) * (n + 1) + maxCount
            // OR max(tasks.size(), calculated)
            
            // Let's visualize the "filling" conceptually
            // We can construct a visual representation string
            // Frame: A _ _ A _ _ A
            // With n=2, maxFreq=3 (A)
            
            const simpleFormulaResult = (maxFreq - 1) * (n + 1) + maxCount;
            const finalResult = Math.max(totalTasks, simpleFormulaResult);

            // Construct a visual "timeline" for demonstration
            // This is a simplified simulation for visualization purposes
            // Actual element placement
            const sortedTasks = Object.keys(freq).sort((a,b) => freq[b] - freq[a]);
            const matrixHeight = maxFreq; // Rows
            // Actually the "rows" approach is better for visualization
            // But let's stick to the timeline array approach
            
            let simulatedTimeline = [];
            const cols = (maxFreq - 1) * (n + 1) + maxCount;
             // Just use the formula value for "slots"
             // if result > tasks.size(), we have idles
             
            steps.push({
                 timeline: [], freq, maxFreq, maxCount, n,
                 highlightLines: [13, 14, 15, 16],
                 explanation: {
                     title: 'è¨ˆç®—çµæœ',
                     text: `å…¬å¼è¨ˆç®—ï¼š(maxFreq - 1) * (n + 1) + maxCount<br>= (${maxFreq}-1) * (${n}+1) + ${maxCount} = ${simpleFormulaResult}<br><br>æœ€çµ‚çµæœå– max(ç¸½ä»»å‹™æ•¸, å…¬å¼å€¼)`,
                     formula: `max(${totalTasks}, ${simpleFormulaResult}) = ${finalResult}`
                 }
            });
            
            // Generate a visual fill
            // This is "greedy" filling for visualization
            const resultTimeline = new Array(finalResult).fill('idle');
            let idx = 0;
            // Fill MaxFreq tasks first
            // A . . A . . A
            // B . . B . . B
            
            // A more accurate greedy simulation for visualization:
            // Priority Queue simulation
            
            let simStepsString = [];
            let counts = {...freq};
            let time = 0;
            // Simple simulation to generate timeline
            // Since we already have the formula result, we can just show "Idles" if any
            
            // Let's just create a schematic timeline based on formula
            // Group 1: A B ... (n idle)
            // Group 2: A B ...
            // ...
            // Group Last: A B
            
            let displayTimeline = [];
            for(let i=0; i<maxFreq-1; i++) {
                // Add "maxCount" tasks
                // Then (n - maxCount + 1) idles... strictly this logic is complex to render perfectly 
                // Let's simplified render:
                // Just A, B, ... n idles, A, B...
                // Only if total tasks > formula result, we don't show idles.
                
                // If formula > tasks, we have idles
            }
            
            if (finalResult > totalTasks) {
                // Must simulate idles
                // Simply: fill columns
                // Col 0: A A A
                // Col 1: B B B
                // ...
                // But visualized as linear time
                
                // Let's run a micro-simulation to get the exact timeline for visualization
                // It makes it much better
                
                let q = []; // [count, char]
                for(let k in freq) q.push([freq[k], k]);
                q.sort((a,b) => b[0] - a[0]); // Sort by freq desc
                
                let t = 0;
                let history = [];
                
                while(q.length > 0) {
                    let k_cycle = n + 1;
                    let temp = [];
                    while (k_cycle > 0 && q.length > 0) {
                        let top = q.shift(); // remove max freq
                        top[0]--;
                        history.push(top[1]);
                        temp.push(top);
                        k_cycle--;
                        t++;
                    }
                    
                    for(let item of temp) {
                        if (item[0] > 0) q.push(item);
                    }
                    q.sort((a,b) => b[0] - a[0]); // re-sort
                    
                    if (q.length === 0) break; // done
                    
                    // IF there are still tasks, we must fill the rest of cycle with idle
                    while (k_cycle > 0) {
                        history.push('idle');
                        k_cycle--;
                        t++;
                    }
                }
                displayTimeline = history;
            } else {
                 // No idles, just packed
                  displayTimeline = tasks.sort(); // naive packing visual
                  // Actually if no idles, order doesn't impact total time, just show packed
                  
                  // For better visual, show interleaved
                   let q = [];
                    for(let k in freq) q.push([freq[k], k]);
                    q.sort((a,b) => b[0] - a[0]);
                    
                    // Simple interleaved string
                    // This is hard to get perfect without full simulation, but full simulation is O(N) which is fine
                    // Re-use logic above
                     let q2 = []; // [count, char]
                    for(let k in freq) q2.push([freq[k], k]);
                    q2.sort((a,b) => b[0] - a[0]); 
                    let history = [];
                    while(q2.length > 0) {
                        let k_cycle = n + 1;
                        let temp = [];
                        while (k_cycle > 0 && q2.length > 0) {
                             let top = q2.shift(); 
                             top[0]--;
                             history.push(top[1]);
                             temp.push(top);
                             k_cycle--;
                        }
                        for(let item of temp) if (item[0] > 0) q2.push(item);
                        q2.sort((a,b) => b[0] - a[0]);
                        // Don't add idles if finished
                    }
                    displayTimeline = history;
            }

            steps.push({
                timeline: displayTimeline,
                freq, maxFreq, maxCount, n,
                final: true,
                result: finalResult,
                highlightLines: [16, 17],
                explanation: {
                    title: 'å®Œæˆ',
                    text: `æ¨¡æ“¬åŸ·è¡Œåºåˆ—å¦‚ä¸Šåœ–ã€‚<br>ç¸½é•·åº¦: ${finalResult} (ç´…è‰²ç‚º IDLE)`,
                    formula: `return ${finalResult}`
                }
            });

            return steps;
        }

        let viz;
        function init() {
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: (step) => {
                    // Update Freq
                    document.getElementById('freqDisplay').innerHTML = Object.entries(step.freq || {}).map(([k,v]) => 
                        `<div class="freq-badge">${k}: ${v}</div>`
                    ).join('');
                    
                    document.getElementById('maxFreq').textContent = step.maxFreq ?? '-';
                    document.getElementById('maxCount').textContent = step.maxCount ?? '-';
                    document.getElementById('resultDisplay').textContent = step.result ?? '?';
                    
                    // Update Timeline
                    document.getElementById('timelineDisplay').innerHTML = (step.timeline || []).map(t => {
                        let cls = 'time-slot';
                        if (t === 'idle') cls += ' idle';
                        else cls += ' task';
                        return `<div class="${cls}">${t === 'idle' ? 'ğŸ›‘' : t}</div>`;
                    }).join('');
                }
            });
            viz.setSteps(generateAlgorithmSteps(currentTasks, currentN));
        }

        function resetVisualization() { init(); }
        window.addEventListener('load', init);
    </script>
</body>
</html>
