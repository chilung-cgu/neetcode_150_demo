<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Task Scheduler - Á≤æÁ∑ªË¶ñË¶∫Âåñ</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .dashboard {
            display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;
        }

        /* Heap / Queue Panel */
        .queue-panel {
            background: rgba(30, 41, 59, 0.4); border-radius: 12px; padding: 10px;
            border: 1px solid rgba(148, 163, 184, 0.2); width: 250px;
        }
        .panel-title { font-size: 0.9rem; color: #94a3b8; margin-bottom: 8px; font-weight: bold; }
        
        .task-list { display: flex; flex-direction: column; gap: 5px; }
        .task-item {
            display: flex; justify-content: space-between; padding: 6px 10px;
            background: rgba(59, 130, 246, 0.2); border-radius: 6px;
            color: #e2e8f0; font-family: monospace;
        }
        .task-item.cooldown { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }

        /* Timeline Grid */
        .timeline-panel {
            flex: 1; min-width: 300px;
            background: rgba(15, 23, 42, 0.5); border-radius: 12px; padding: 15px;
            overflow-x: auto;
        }
        .timeline-grid {
            display: grid; grid-template-columns: repeat(auto-fill, 40px); gap: 5px;
        }
        .time-slot {
            width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;
            background: #334155; border-radius: 6px; font-weight: bold;
            color: #94a3b8; transition: all 0.3s;
        }
        .time-slot.active { background: #3b82f6; color: white; transform: scale(1.1); }
        .time-slot.idle { background: #475569; color: #cbd5e1; opacity: 0.5; border: 1px dashed #94a3b8; }
        .time-slot.new { animation: popIn 0.3s; }

        @keyframes popIn { 0% { transform: scale(0); } 100% { transform: scale(1); } }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 120px; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Task Scheduler (CPU Timeline)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label>Tasks (e.g. AAABBC):</label>
                        <input type="text" id="tasksInput" value="AAABBB">
                        <label>N (Cooldown):</label>
                        <input type="number" id="nInput" value="2" style="width:50px">
                        <button onclick="runVisualizer()">ÊéíÁ®ã (Schedule)</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <div class="dashboard">
                        <div class="queue-panel">
                            <div class="panel-title">Ready Queue (Max Heap)</div>
                            <div class="task-list" id="heapList"></div>
                        </div>
                        <div class="queue-panel">
                            <div class="panel-title">Cooldown Queue (Wait)</div>
                            <div class="task-list" id="waitList"></div>
                        </div>
                    </div>
                    
                    <div class="timeline-panel">
                        <div class="panel-title">CPU Timeline (Total Time: <span id="timeCount">0</span>)</div>
                        <div class="timeline-grid" id="timelineGrid"></div>
                    </div>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn" onclick="runVisualizer()">‚Üª ÈáçÁΩÆ</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="800" selected>1x</option>
                            <option value="300">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'int leastInterval(tasks, n) {', id: 0 },
            { line: '    // Frequency Map & Max Heap', id: 1 },
            { line: '    priority_queue<int> maxHeap;', id: 2 },
            { line: '    queue<pair<int, int>> waitQueue; // {rem, time}', id: 3 },
            { line: '    int time = 0;', id: 4 },
            { line: '    while (!maxHeap.empty() || !waitQueue.empty()) {', id: 5 },
            { line: '        time++;', id: 6 },
            { line: '        if (!maxHeap.empty()) {', id: 7 },
            { line: '            int rem = maxHeap.top() - 1;', id: 8 },
            { line: '            maxHeap.pop();', id: 9 },
            { line: '            if (rem > 0) waitQueue.push({rem, time + n});', id: 10 },
            { line: '        }', id: 11 },
            { line: '        if (!waitQueue.empty() && waitQueue.front().time == time) {', id: 12 },
            { line: '            maxHeap.push(waitQueue.front().cnt);', id: 13 },
            { line: '            waitQueue.pop();', id: 14 },
            { line: '        }', id: 15 },
            { line: '    }', id: 16 },
            { line: '    return time;', id: 17 },
            { line: '}', id: 18 }
        ];

        let viz;

        function simulate(tasksStr, n) {
            const steps = [];
            const counts = {};
            for(let c of tasksStr) counts[c] = (counts[c]||0)+1;
            
            // Simulation logic
            // We need to track actual Task Names for clearer visualization
            // So heap stores {char, count}
            
            let heap = Object.entries(counts).map(([k,v]) => ({char:k, cnt:v}));
            heap.sort((a,b) => b.cnt - a.cnt); // simulate max heap
            
            let waitQ = []; // {char, cnt, readyTime}
            let time = 0;
            let timeline = [];

            // Helper to sort heap
            const reorderHeap = () => heap.sort((a,b) => b.cnt - a.cnt);

            steps.push({
                heap: JSON.parse(JSON.stringify(heap)),
                waitQ: [], timeline: [], time: 0,
                msg: "ÂàùÂßãÂåñ: Ë®àÁÆóÈ†ªÁéáÔºåÂª∫Á´ã Max Heap",
                highlightLines: [1, 2]
            });

            while(heap.length > 0 || waitQ.length > 0) {
                time++;
                let currentTask = null;
                
                // Check Wait Queue -> Heap
                // Logic: In loop, we process task then check if waitQ is ready for NEXT time
                // Or: check waitQ for CURRENT time first?
                // Standard problem: push to waitQ with `time + n`. It becomes available at `time + n + 1`? 
                // Wait, if time=1, n=2. Push {rem, 1+2=3}. At time=3, it is NOT ready? Or ready?
                // Cooldown is n. So interval is n+1. 
                // e.g. A at 1. Next A at 1 + 2 + 1 = 4. 
                // WaitQ condition: `waitQ.front().time <= time`? Actually usually we process waitQ first
                
                // Let's follow standard simulation:
                // 1. Check Heap. Pick top.
                // 2. Put into WaitQ with readyTime
                // 3. Check WaitQ if anything ready now?
                
                // But WaitQ items become ready basically.
                
                let processed = false;
                
                if (heap.length > 0) {
                    const task = heap.shift(); // Pop max
                    currentTask = task.char;
                    task.cnt--;
                    timeline.push({val: task.char, t: time});
                    
                    steps.push({
                        heap: JSON.parse(JSON.stringify(heap)),
                        waitQ: JSON.parse(JSON.stringify(waitQ)),
                        timeline: [...timeline], time,
                        msg: `ÊôÇÈñì ${time}: Âü∑Ë°å‰ªªÂãô ${task.char} (Ââ©È§ò ${task.cnt})`,
                        highlightLines: [7, 8, 9]
                    });

                    if (task.cnt > 0) {
                        waitQ.push({ ...task, readyTime: time + n + 1 });
                        steps.push({
                            heap: JSON.parse(JSON.stringify(heap)),
                            waitQ: JSON.parse(JSON.stringify(waitQ)),
                            timeline: [...timeline], time,
                            msg: `‰ªªÂãô ${task.char} ÈÄ≤ÂÖ•ÂÜ∑Âçª (Ready at ${time + n + 1})`,
                            highlightLines: [10]
                        });
                    }
                    processed = true;
                } else {
                    // IDLE
                    timeline.push({val: 'IDLE', t: time});
                    steps.push({
                        heap: JSON.parse(JSON.stringify(heap)),
                        waitQ: JSON.parse(JSON.stringify(waitQ)),
                        timeline: [...timeline], time,
                        msg: `ÊôÇÈñì ${time}: Heap Á©∫ÔºåÂü∑Ë°å IDLE`,
                        highlightLines: [6] // implicit else
                    });
                }

                // Check WaitQ readiness for NEXT cycle 
                // Actually if we simulate `time` increment at start of loop:
                // Check if any `readyTime == time + 1` ? 
                // The algo usually: check waitq.front().readyTime == time (if checking at start).
                // My logic: `waitQ.push({rem, time + n + 1})`. This means it can be picked at `time + n + 1`.
                
                // We check if waitQ has items ready for NEXT iteration.
                // But let's check Current logic:
                // If we check at end of loop, we check `readyTime <= time + 1`?
                
                if (waitQ.length > 0 && waitQ[0].readyTime === time + 1) {
                    const ready = waitQ.shift();
                    heap.push({char: ready.char, cnt: ready.cnt});
                    reorderHeap();
                    steps.push({
                        heap: JSON.parse(JSON.stringify(heap)),
                        waitQ: JSON.parse(JSON.stringify(waitQ)),
                        timeline: [...timeline], time,
                        msg: `‰ªªÂãô ${ready.char} ÂÜ∑ÂçªÁµêÊùüÔºåÂõûÂà∞ Heap`,
                        highlightLines: [12, 13]
                    });
                }
            }
            
            steps.push({
                heap: [], waitQ: [], timeline: [...timeline], time,
                msg: `ÂÆåÊàêÔºÅÁ∏ΩÊôÇÈñì: ${time}`,
                highlightLines: [17],
                final: true
            });

            return steps;
        }

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;
            document.getElementById('timeCount').textContent = step.time || 0;

            // Heap
            document.getElementById('heapList').innerHTML = (step.heap||[]).map(t => 
                `<div class="task-item"><span>${t.char}</span><span>${t.cnt}</span></div>`
            ).join('');

            // WaitQ
            document.getElementById('waitList').innerHTML = (step.waitQ||[]).map(t => 
                `<div class="task-item cooldown"><span>${t.char}</span><span>@ ${t.readyTime}</span></div>`
            ).join('');

            // Timeline
            const tl = document.getElementById('timelineGrid');
            tl.innerHTML = (step.timeline||[]).map(slot => {
                let cls = 'time-slot';
                if(slot.val === 'IDLE') cls += ' idle';
                else cls += ' active';
                return `<div class="${cls}">${slot.val === 'IDLE' ? '√ò' : slot.val}</div>`;
            }).join('');
            
            // Auto scroll timeline
            tl.scrollLeft = tl.scrollWidth;
        }

        function runVisualizer() {
            const raw = document.getElementById('tasksInput').value.toUpperCase();
            const tasks = raw.replace(/[^A-Z]/g, '');
            const n = parseInt(document.getElementById('nInput').value);
            
            if(!tasks || isNaN(n)) return alert("Ë´ãËº∏ÂÖ•‰ªªÂãô A-Z Âíå N");

            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(tasks, n));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
