<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Scheduler - D3 Á≤æÁ∑ªË¶ñË¶∫Âåñ</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-height: 500px;
        }

        .dashboard {
            display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; width: 100%;
        }

        /* Panels */
        .panel {
            background: rgba(30, 41, 59, 0.4); border-radius: 12px; padding: 15px;
            border: 1px solid rgba(148, 163, 184, 0.2); width: 250px;
            display: flex; flex-direction: column; gap: 10px;
        }
        .panel-title { font-size: 0.9rem; color: #94a3b8; font-weight: bold; text-transform: uppercase; border-bottom: 1px solid rgba(148, 163, 184, 0.2); padding-bottom: 5px; }
        
        /* Task List Items */
        .task-list { display: flex; flex-direction: column; gap: 5px; min-height: 150px; }
        .task-item {
            display: flex; justify-content: space-between; align-items: center; padding: 8px 12px;
            background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 6px;
            color: #e2e8f0; font-family: monospace; font-weight: bold;
            transition: all 0.3s;
        }
        .task-item.top { background: rgba(34, 197, 94, 0.2); border-color: rgba(34, 197, 94, 0.5); transform: scale(1.02); }
        .task-item.wait { background: rgba(251, 191, 36, 0.1); border-color: rgba(251, 191, 36, 0.3); color: #fbbf24; }
        
        .badge {
            background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px; font-size: 0.8rem; min-width: 20px; text-align: center;
        }

        /* Timeline */
        .timeline-panel {
            flex: 1; width: 100%; display: flex; flex-direction: column;
            background: rgba(15, 23, 42, 0.5); border-radius: 12px; padding: 15px;
            box-sizing: border-box;
        }
        .timeline-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); gap: 8px;
            max-height: 200px; overflow-y: auto;
        }
        .time-slot {
            height: 40px; display: flex; align-items: center; justify-content: center;
            background: #334155; border-radius: 6px; font-weight: bold; font-family: monospace;
            color: #cbd5e1; position: relative; border: 1px solid transparent;
        }
        .time-slot.task { background: #3b82f6; color: white; border-color: #60a5fa; }
        .time-slot.idle { background: #475569; opacity: 0.6; border: 1px dashed #94a3b8; color: #94a3b8; }
        .time-slot.current { box-shadow: 0 0 10px #fbbf24; z-index: 10; border-color: #fbbf24; }
        
        .time-idx { position: absolute; top: -5px; right: -5px; font-size: 0.6rem; color: #94a3b8; background: #0f172a; padding: 0 2px; border-radius: 4px; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; justify-content: center; flex-wrap: wrap; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 150px; }
        .input-row input[type=number] { width: 60px; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; font-weight: 600; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Task Scheduler (Max Heap + Queue)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label>Tasks:</label>
                        <input type="text" id="tasksInput" value="AAABBB">
                        <label>N (Chill):</label>
                        <input type="number" id="nInput" value="2" min="0">
                        <button onclick="runVisualizer()">Schedule</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <div class="dashboard">
                        <div class="panel">
                            <div class="panel-title">Ready Queue (Heap)</div>
                            <div class="task-list" id="heapList"></div>
                        </div>
                        <div class="panel">
                            <div class="panel-title">Cooldown Queue</div>
                            <div class="task-list" id="waitList"></div>
                        </div>
                    </div>
                    
                    <div class="timeline-panel">
                        <div class="panel-title">Time: <span id="timeVal" style="color:#fbbf24">0</span></div>
                        <div class="timeline-grid" id="timelineGrid"></div>
                    </div>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn" onclick="runVisualizer()">‚Üª ÈáçÁΩÆ</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'int leastInterval(tasks, n) {', id: 0 },
            { line: '    priority_queue<int> pq; // Max frequencies', id: 1 },
            { line: '    queue<pair<int, int>> waitQ; // {cnt, readyTime}', id: 2 },
            { line: '    int time = 0;', id: 3 },
            { line: '    while (!pq.empty() || !waitQ.empty()) {', id: 4 },
            { line: '        time++;', id: 5 },
            { line: '        if (!pq.empty()) {', id: 6 },
            { line: '            int cnt = pq.top() - 1; pq.pop();', id: 7 },
            { line: '            if (cnt > 0) waitQ.push({cnt, time + n});', id: 8 },
            { line: '        }', id: 9 },
            { line: '        if (!waitQ.empty() && waitQ.front().time == time)', id: 10 },
            { line: '            pq.push(waitQ.front()); waitQ.pop();', id: 11 },
            { line: '    }', id: 12 },
            { line: '    return time;', id: 13 },
            { line: '}', id: 14 }
        ];

        let viz;

        function simulate(tasks, n) {
            const steps = [];
            
            // Freq map
            const map = {};
            for(let t of tasks) map[t] = (map[t]||0) + 1;
            
            // Initial Heap: Array of {id, count}
            let pq = Object.entries(map).map(([k,v]) => ({id:k, count:v}));
            pq.sort((a,b) => b.count - a.count); // Max Heap Sim
            
            let waitQ = []; // {id, count, readyTime}
            let time = 0;
            const timeline = [];

            const pushState = (msg, hl, activeSlot=null) => {
                steps.push({
                    pq: [...pq.map(x=>({...x}))], // Deep-ish copy
                    waitQ: [...waitQ.map(x=>({...x}))],
                    time,
                    timeline: [...timeline],
                    activeSlot, // {type: 'task'|'idle', val: 'A'}
                    msg, highlightLines: hl
                });
            };

            pushState("Initial State: Build Freq Heap", [1], null);

            while (pq.length > 0 || waitQ.length > 0) {
                time++;
                let pushedToWait = null;
                let active = null;

                // Process Heap (Pick Task)
                if (pq.length > 0) {
                    // Pop max
                    const task = pq.shift(); // Remove first sorted (max)
                    active = {type: 'task', val: task.id};
                    timeline.push(active);
                    
                    const rem = task.count - 1;
                    if (rem > 0) {
                        pushedToWait = {id: task.id, count: rem, readyTime: time + n};
                    }
                    
                    pushState(`Time ${time}: Exec '${task.id}' (Remaining: ${rem})`, [6, 7], active);
                } else {
                    active = {type: 'idle', val: 'IDLE'};
                    timeline.push(active);
                    pushState(`Time ${time}: CPU Idle (Heap Empty)`, [4], active);
                }

                if (pushedToWait) {
                    waitQ.push(pushedToWait);
                    pushState(`Task '${pushedToWait.id}' needs cooldown. Wait until T=${pushedToWait.readyTime+1}`, [8], active);
                }

                // Check Wait Queue
                if (waitQ.length > 0 && waitQ[0].readyTime === time) { // Ready at END of 'time' interval or start of next? 
                    // Problem says cooldown n. If run at t=1, ready at t=1+n+1 = t+n+1?
                    // Example: A at t=1, n=2. Next valid A is t=4.
                    // Implementation usually checks strict equality if we increment time first?
                    // logic: if processed at T, ready at T+n+1.
                    // waitQ check usually logic: if `waitQ.front().readyTime <= time`. Wait, logic usually increments time first.
                    // Let's assume standard logic provided in C++ snippet: `if (waitQ.front().time == time)`.
                    
                    const ready = waitQ.shift();
                    pq.push({id: ready.id, count: ready.count});
                    pq.sort((a,b) => b.count - a.count); // Maintain Heap
                    
                    pushState(`Task '${ready.id}' cooldown finished. Push back to Ready Queue.`, [10, 11], active);
                }
            }
            
            pushState(`Finished at Time ${time}`, [13], null);

            return steps;
        }

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;
            document.getElementById('timeVal').textContent = step.time;

            // Heap
            const heapList = document.getElementById('heapList');
            heapList.innerHTML = '';
            step.pq.forEach((t, i) => {
               const div = document.createElement('div');
               div.className = i===0 ? 'task-item top' : 'task-item';
               div.innerHTML = `<span>${t.id}</span><span class="badge">${t.count}</span>`;
               heapList.appendChild(div);
            });

            // WaitQ
            const waitList = document.getElementById('waitList');
            waitList.innerHTML = '';
            step.waitQ.forEach(t => {
               const div = document.createElement('div');
               div.className = 'task-item wait';
               div.innerHTML = `<span>${t.id}</span><span class="badge">Wait T${t.readyTime+1}</span>`; 
               waitList.appendChild(div);
            });

            // Timeline
            const tlGrid = document.getElementById('timelineGrid');
            tlGrid.innerHTML = '';
            step.timeline.forEach((slot, i) => {
                const div = document.createElement('div');
                div.className = slot.type === 'task' ? 'time-slot task' : 'time-slot idle';
                if(i === step.timeline.length - 1) div.classList.add('current');
                div.innerHTML = `${slot.val}<div class="time-idx">${i+1}</div>`;
                tlGrid.appendChild(div);
            });
            // Scroll to end
            tlGrid.scrollTop = tlGrid.scrollHeight;
        }

        function runVisualizer() {
            const raw = document.getElementById('tasksInput').value.toUpperCase();
            const n = parseInt(document.getElementById('nInput').value);
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(raw.split(''), n));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
