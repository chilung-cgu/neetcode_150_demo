<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Design Twitter - D3 Á≤æÁ∑ªË¶ñË¶∫Âåñ</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-height: 600px;
        }

        .dashboard {
            display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; width: 100%;
        }

        /* Users Panel */
        .panel {
            background: rgba(30, 41, 59, 0.4); border-radius: 12px; padding: 15px;
            border: 1px solid rgba(148, 163, 184, 0.2); width: 320px;
            display: flex; flex-direction: column; gap: 10px;
        }
        .panel-title { font-size: 0.9rem; color: #94a3b8; font-weight: bold; text-transform: uppercase; text-align: center; }

        .user-list { display: flex; flex-direction: column; gap: 8px; }
        .user-row {
            display: flex; align-items: start; gap: 10px; padding: 8px;
            background: rgba(59, 130, 246, 0.1); border-radius: 8px;
        }
        .avatar {
            width: 30px; height: 30px; background: #3b82f6; border-radius: 50%;
            display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 0.8rem;
        }
        .tweets-preview { flex: 1; display: flex; flex-wrap: wrap; gap: 4px; }
        .mini-tweet {
            font-size: 0.7rem; padding: 2px 6px; background: rgba(30, 41, 59, 0.8); border: 1px solid #475569; border-radius: 4px; color: #cbd5e1;
            transition: all 0.3s;
        }
        .mini-tweet.active { background: #fbbf24; color: #0f172a; border-color: #fbbf24; transform: scale(1.1); }
        .mini-tweet.picked { opacity: 0.4; text-decoration: line-through; }

        /* Heap Panel */
        .heap-container { width: 100%; height: 250px; position: relative; }
        #heap-svg { width: 100%; height: 100%; }
        
        .node-rect { fill: #334155; stroke: #64748b; stroke-width: 2px; }
        .node-rect.max { fill: #fbbf24; stroke: #fff; } /* Current max */
        .node-text { fill: white; font-size: 10px; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        .link { stroke: #475569; stroke-width: 1px; }

        /* Feed */
        .feed-container {
            flex: 1; background: #0f172a; border-radius: 12px; padding: 10px;
            display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; border: 2px solid #334155;
        }
        .feed-item {
            display: flex; gap: 10px; padding: 8px; background: #1e293b; border-radius: 6px; border-left: 3px solid #22c55e;
            align-items: center; animation: slideIn 0.3s;
        }
        .feed-time { font-size: 0.7rem; color: #64748b; margin-left: auto; }
        @keyframes slideIn { from { transform: translateX(20px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: center; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 80px; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Design Twitter (Merge K Sorted Lists)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label>User ID:</label>
                        <input type="number" id="uidInput" value="1" min="1" max="3">
                        <label>Post ID:</label>
                        <input type="number" id="tidInput" value="101" style="width:60px">
                        <button onclick="doPost()">Post</button>
                    </div>
                    <div class="input-row" style="margin-top:10px;">
                        <label>Get Feed for User:</label>
                        <input type="number" id="feedUidInput" value="1" min="1" max="3">
                        <button onclick="doGetFeed()" style="background:#22c55e;">Get Feed</button>
                        <button onclick="resetViz()" style="background:#ef4444;">Reset</button>
                    </div>
                    <div style="text-align:center; font-size:0.8rem; color:#64748b; margin-top:5px;">Assuming User 1 follows User 2 & 3.</div>
                </div>

                <div class="visualization-area">
                    <div class="dashboard">
                        <div class="panel">
                            <div class="panel-title">User Tweets (Sorted by Time)</div>
                            <div class="user-list" id="usersList"></div>
                        </div>
                        
                        <div class="panel">
                            <div class="panel-title">Max Heap (Sorted by Time)</div>
                            <div class="heap-container">
                                <svg id="heap-svg"><g id="heap-g"></g></svg>
                            </div>
                        </div>
                        
                        <div class="panel">
                            <div class="panel-title">News Feed (Result)</div>
                            <div class="feed-container" id="feedList"></div>
                        </div>
                    </div>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        // Simplified Code for visualization focus
        const codeStructure = [
            { line: 'vector<int> getNewsFeed(userId) {', id: 0 },
            { line: '    priority_queue<Tweet> pq;', id: 1 },
            { line: '    // Push head of tweet list for self + followees', id: 2 },
            { line: '    for (int uid : followees[userId]) {', id: 3 },
            { line: '        if (!tweets[uid].empty())', id: 4 },
            { line: '            pq.push(tweets[uid].back()); // Newest', id: 5 },
            { line: '    }', id: 6 },
            { line: '    vector<int> feed;', id: 7 },
            { line: '    while (!pq.empty() && feed.size() < 10) {', id: 8 },
            { line: '        Tweet t = pq.top(); pq.pop();', id: 9 },
            { line: '        feed.push_back(t.id);', id: 10 },
            { line: '        if (t.next_index >= 0) ', id: 11 },
            { line: '            pq.push(tweets[t.uid][t.next_index]);', id: 12 },
            { line: '    }', id: 13 },
            { line: '    return feed;', id: 14 },
            { line: '}', id: 15 }
        ];

        let viz;
        let globalTime = 0;
        // Data Model
        // users: { id: 1, tweets: [{id, time}] }
        let users = {
            1: { id:1, tweets: [] },
            2: { id:2, tweets: [] },
            3: { id:3, tweets: [] }
        };
        // Hardcoded follow graph: 1 follows 2, 3. 2 follows none. 3 follows none.
        // So GetFeed(1) merges 1, 2, 3.
        const follows = { 1: [1, 2, 3], 2: [2], 3: [3] };

        // Helper: Convert Heap Array to Tree for D3
        function heapToHierarchy(arr) {
            if (arr.length === 0) return null;
            function build(idx) {
                if (idx >= arr.length) return null;
                const node = { ...arr[idx], children: [] };
                const left = build(2 * idx + 1);
                const right = build(2 * idx + 2);
                if (left) node.children.push(left);
                if (right) node.children.push(right);
                return node;
            }
            return build(0);
        }

        // --- Simulation ---
        function simulateGetFeed(userId) {
            const steps = [];
            const followees = follows[userId] || [userId];
            
            // Build Initial Heap
            // We need a Max Heap based on Time.
            // Items in heap: { tweetId, time, uid, nextIdx }
            
            const pq = []; // Local simplistic Max Heap array
            const feed = [];
            const processedTweets = new Set(); // To mark visually 'picked'

            // Initial Push
            followees.forEach(uid => {
                const uTweets = users[uid].tweets;
                if(uTweets.length > 0) {
                    const t = uTweets[uTweets.length - 1]; // Newest is at end (or push front? let's assume array push)
                    // Wait, usually tweets are stored chronological. So newest is last.
                    // But we traverse backwards? Or we store them reverse?
                    // Let's assume uTweets[length-1] is newest. Next is length-2.
                    pq.push({ ...t, uid, idx: uTweets.length - 1 });
                }
            });
            pq.sort((a,b) => b.time - a.time); // Initial sort

            const pushState = (msg, hl, activeTid=null) => {
                steps.push({
                    users: JSON.parse(JSON.stringify(users)),
                    pq: JSON.parse(JSON.stringify(pq)),
                    feed: [...feed],
                    processedTweets: new Set(processedTweets), // Set copy? JSON sucks for Set
                    activeTid,
                    msg, highlightLines: hl
                });
            };
            
            // Fix Set serialization for steps
            // Actually just store array of processed IDs
            
            steps.push({
                users: JSON.parse(JSON.stringify(users)),
                pq: [...pq], feed: [], processedTweets: [],
                activeTid: null,
                msg: `Init Heap with newest tweets from User ${userId} and followees ${followees.join(',')}`,
                highlightLines: [3, 4, 5]
            });

            while(pq.length > 0 && feed.length < 10) {
                // Pop Max
                const top = pq.shift(); // Remove first
                feed.push(top);
                const processedList = feed.map(f => f.id);
                
                pushState(`Pop Tweet ${top.id} (Time ${top.time}) from User ${top.uid}`, [9, 10], top.id);

                // Push Next
                if (top.idx > 0) {
                    const nextIdx = top.idx - 1;
                    const nextTweet = users[top.uid].tweets[nextIdx];
                    pq.push({ ...nextTweet, uid: top.uid, idx: nextIdx });
                    pq.sort((a,b) => b.time - a.time); // Re-sort (simulate heapify)
                    
                    // We need to update processed list in the state object properly
                    const currentStep = {
                        users: JSON.parse(JSON.stringify(users)),
                        pq: [...pq],
                        feed: [...feed],
                        processedTweets: processedList,
                        activeTid: nextTweet.id, // Highlight the one being pushed
                        msg: `Push next tweet ${nextTweet.id} from User ${top.uid}`,
                        highlightLines: [11, 12]
                    };
                    steps.push(currentStep);
                } else {
                    const currentStep = {
                        users: JSON.parse(JSON.stringify(users)),
                        pq: [...pq],
                        feed: [...feed],
                        processedTweets: processedList,
                        activeTid: null,
                        msg: `User ${top.uid} has no more tweets`,
                        highlightLines: [11]
                    };
                    steps.push(currentStep);
                }
            }
            
            // Final
            steps.push({
                users: JSON.parse(JSON.stringify(users)),
                pq: [...pq],
                feed: [...feed],
                processedTweets: feed.map(f=>f.id),
                activeTid: null,
                msg: "Feed Generation Complete",
                highlightLines: [14]
            });

            return steps;
        }

        // --- Render ---
        const width = 250, height = 250;
        const svg = d3.select("#heap-svg");
        const gMain = d3.select("#heap-g");
        
        // Zoom functionality
        const zoom = d3.zoom().on("zoom", (e) => gMain.attr("transform", e.transform));
        svg.call(zoom);
        svg.call(zoom.transform, d3.zoomIdentity.translate(width/2, 20).scale(0.9));

        const treeLayout = d3.tree().nodeSize([40, 50]);

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;

            // Render Users & Tweets
            const usersList = document.getElementById('usersList');
            usersList.innerHTML = '';
            Object.values(step.users).forEach(u => {
                const row = document.createElement('div');
                row.className = 'user-row';
                
                const avatar = document.createElement('div');
                avatar.className = 'avatar';
                avatar.textContent = u.id;
                
                const preview = document.createElement('div');
                preview.className = 'tweets-preview';
                
                u.tweets.forEach(t => {
                    const mini = document.createElement('div');
                    mini.className = 'mini-tweet';
                    mini.textContent = t.id;
                    if(t.id === step.activeTid) mini.classList.add('active');
                    // Check if processed
                    if(step.processedTweets && step.processedTweets.includes(t.id)) mini.classList.add('picked');
                    preview.appendChild(mini);
                });
                
                row.appendChild(avatar);
                row.appendChild(preview);
                usersList.appendChild(row);
            });

            // Render Feed
            const feedList = document.getElementById('feedList');
            feedList.innerHTML = '';
            step.feed.forEach(f => {
                const item = document.createElement('div');
                item.className = 'feed-item';
                item.innerHTML = `<div><b>U${f.uid}</b>: Tweet ${f.id}</div><div class="feed-time">T=${f.time}</div>`;
                feedList.appendChild(item);
            });

            // Render Heap Tree
            gMain.selectAll("*").remove();
            if(step.pq.length > 0) {
                const root = d3.hierarchy(heapToHierarchy(step.pq));
                treeLayout(root);

                const links = gMain.selectAll(".link").data(root.links());
                links.enter().append("path").attr("class", "link")
                    .attr("d", d3.linkVertical().x(d => d.x).y(d => d.y));

                const nodes = gMain.selectAll(".node-g").data(root.descendants());
                const nEnter = nodes.enter().append("g").attr("class", "node-g")
                    .attr("transform", d => `translate(${d.x}, ${d.y})`);
                
                nEnter.append("rect").attr("width", 36).attr("height", 24).attr("x", -18).attr("y", -12)
                    .attr("class", d => d.depth === 0 ? "node-rect max" : "node-rect");
                
                nEnter.append("text").attr("class", "node-text")
                    .text(d => `T${d.data.id}`);
            }
        }

        // --- Actions ---
        function doPost() {
            const uid = parseInt(document.getElementById('uidInput').value);
            const tid = parseInt(document.getElementById('tidInput').value);
            
            // Add to state
            users[uid].tweets.push({ id: tid, time: ++globalTime });
            document.getElementById('tidInput').value = tid + 1; // Auto increment
            
            // Dummy visual update (single step)
            // Or just re-render current static view?
            // Let's just create a quick 1-step logic
            viz = new AlgorithmVisualizer({ codeLines: codeStructure, onStepChange: render });
            viz.setSteps([{
                users: JSON.parse(JSON.stringify(users)),
                pq: [], feed: [], processedTweets: [], msg: `User ${uid} Posted ${tid}`, highlightLines:[]
            }]);
        }

        function doGetFeed() {
            const uid = parseInt(document.getElementById('feedUidInput').value);
            const steps = simulateGetFeed(uid);
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(steps);
        }

        function resetViz() {
            users = { 1: {id:1, tweets:[]}, 2: {id:2, tweets:[]}, 3: {id:3, tweets:[]} };
            globalTime = 0;
            // Pre-seed some tweets
            users[1].tweets.push({id:1, time:++globalTime});
            users[2].tweets.push({id:2, time:++globalTime});
            users[3].tweets.push({id:3, time:++globalTime});
            users[2].tweets.push({id:4, time:++globalTime});
            
            doGetFeed();
        }

        window.addEventListener('load', resetViz);
    </script>
</body>
</html>
