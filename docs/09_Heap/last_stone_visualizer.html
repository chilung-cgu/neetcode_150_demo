<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Last Stone Weight (Max Heap) - D3 Á≤æÁ∑ªË¶ñË¶∫Âåñ</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            min-height: 600px;
        }

        .dual-view {
            display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%;
        }

        /* Heap Tree */
        .tree-panel {
            width: 100%; height: 350px;
            background: rgba(30, 41, 59, 0.3);
            border-radius: 12px;
            position: relative;
        }
        #tree-svg { width: 100%; height: 100%; }

        /* Smash Zone */
        .smash-zone {
            height: 120px; width: 100%; display: flex; align-items: center; justify-content: center; gap: 60px;
            background: rgba(255,255,255,0.05); border-radius: 12px;
            position: relative;
        }
        .vs-label { font-size: 2rem; font-weight: 900; color: #ef4444; font-style: italic; }
        
        .stone-slot {
            width: 70px; height: 70px; border: 2px dashed #475569; border-radius: 50%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #64748b; font-size: 0.8rem; position: relative;
        }
        
        .stone-anim {
            width: 70px; height: 70px; background: #fbbf24; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-weight: 800; font-size: 1.5rem; color: #0f172a;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
            transition: all 0.3s;
        }
        .stone-anim.broken { opacity: 0.3; transform: scale(0.8); filter: grayscale(1); }
        .stone-anim.result { background: #22c55e; box-shadow: 0 0 20px #22c55e; color: white; }

        /* D3 Nodes */
        .node-circle { fill: #3b82f6; stroke: #1e293b; stroke-width: 3px; transition: fill 0.3s; }
        .node-circle.root { stroke: #fbbf24; stroke-width: 4px; }
        .node-text { fill: white; font-weight: bold; font-family: monospace; font-size: 14px; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        .link { stroke: #64748b; stroke-width: 2px; opacity: 0.4; fill: none; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; justify-content: center; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 250px; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; font-weight: 600; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; margin-top: 15px; width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Last Stone Weight (Max Heap)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label>Stones:</label>
                        <input type="text" id="stonesInput" value="2, 7, 4, 1, 8, 1">
                        <button onclick="runVisualizer()">Smash!</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <div class="smash-zone">
                        <div class="stone-slot" id="slotY"><span style="margin-bottom:5px;">Max (Y)</span></div>
                        <div class="vs-label">VS</div>
                        <div class="stone-slot" id="slotX"><span style="margin-bottom:5px;">2nd Max (X)</span></div>
                    </div>

                    <div class="tree-panel">
                        <svg id="tree-svg">
                            <g id="tree-main"></g>
                        </svg>
                    </div>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn" onclick="runVisualizer()">‚Üª ÈáçÁΩÆ</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'int lastStoneWeight(vector<int>& stones) {', id: 0 },
            { line: '    priority_queue<int> pq(stones.begin(), stones.end());', id: 1 },
            { line: '    while (pq.size() > 1) {', id: 2 },
            { line: '        int y = pq.top(); pq.pop();', id: 3 },
            { line: '        int x = pq.top(); pq.pop();', id: 4 },
            { line: '        if (x != y) {', id: 5 },
            { line: '            pq.push(y - x);', id: 6 },
            { line: '        }', id: 7 },
            { line: '    }', id: 8 },
            { line: '    return pq.empty() ? 0 : pq.top();', id: 9 },
            { line: '}', id: 10 }
        ];

        let viz;

        // --- Helper ---
        function heapToHierarchy(arr) {
            if (arr.length === 0) return null;
            function build(idx) {
                if (idx >= arr.length) return null;
                const node = { id: idx, val: arr[idx], children: [] };
                const left = build(2 * idx + 1);
                const right = build(2 * idx + 2);
                if (left) node.children.push(left);
                if (right) node.children.push(right);
                return node;
            }
            return build(0);
        }

        // --- Simulation ---
        // Basic Max Heap Implementation for Simulation
        class MaxHeap {
            constructor(arr) {
                this.heap = [];
                if(arr) arr.forEach(x => this.push(x));
            }
            push(val) {
                this.heap.push(val);
                this.bubbleUp(this.heap.length - 1);
            }
            pop() {
                if(this.heap.length === 0) return null;
                const max = this.heap[0];
                const last = this.heap.pop();
                if(this.heap.length > 0) {
                    this.heap[0] = last;
                    this.bubbleDown(0);
                }
                return max;
            }
            bubbleUp(idx) {
                while(idx > 0) {
                    let p = Math.floor((idx-1)/2);
                    if(this.heap[idx] > this.heap[p]) {
                        [this.heap[idx], this.heap[p]] = [this.heap[p], this.heap[idx]];
                        idx = p;
                    } else break;
                }
            }
            bubbleDown(idx) {
                while(true) {
                    let l = 2*idx+1, r = 2*idx+2, largest = idx;
                    if(l < this.heap.length && this.heap[l] > this.heap[largest]) largest = l;
                    if(r < this.heap.length && this.heap[r] > this.heap[largest]) largest = r;
                    if(largest !== idx) {
                        [this.heap[idx], this.heap[largest]] = [this.heap[largest], this.heap[idx]];
                        idx = largest;
                    } else break;
                }
            }
            toArray() { return [...this.heap]; }
            size() { return this.heap.length; }
        }

        function simulate(stones) {
            const steps = [];
            const pq = new MaxHeap(stones); // Init heap
            
            // For animation, we need intermediate heap states.
            // But implementing full heap visual steps (swap by swap) inside this loop is complex.
            // We will simplify: Show "Pop Y" -> Heap State Update -> "Pop X" -> Heap State Update.
            // We assume instant heapify for visual clarity unless we really want swap steps. 
            // "Instant heapify" is acceptable if we focus on the logic Y vs X.
            
            steps.push({
                heap: pq.toArray(),
                y: null, x: null, result: null,
                msg: "Init Max Heap",
                highlightLines: [1]
            });

            while(pq.size() > 1) {
                // Peek Y
                const y = pq.heap[0];
                steps.push({
                    heap: pq.toArray(),
                    y: y, x: null, result: null,
                    msg: `Pop Max (Y = ${y})`,
                    highlightLines: [3]
                });
                
                // Actual pop logic (simplified visual)
                pq.pop(); // Remove Y
                
                // Peek X
                const x = pq.heap[0]; // Next max
                steps.push({
                    heap: pq.toArray(),
                    y: y, x: x, result: null,
                    msg: `Pop 2nd Max (X = ${x})`,
                    highlightLines: [4]
                });
                
                pq.pop(); // Remove X
                
                // Clash
                let diff = y - x;
                steps.push({
                    heap: pq.toArray(), // Both removed
                    y: y, x: x, result: diff,
                    msg: `Clash! ${y} - ${x} = ${diff}`,
                    highlightLines: [5]
                });
                
                if (x !== y) {
                    pq.push(diff);
                    steps.push({
                        heap: pq.toArray(),
                        y: y, x: x, result: diff,
                        msg: `Push diff (${diff}) back`,
                        highlightLines: [6]
                    });
                } else {
                    steps.push({
                        heap: pq.toArray(),
                        y: y, x: x, result: 0,
                        msg: `Both destroyed (${y} == ${x})`,
                        highlightLines: [5] // else condition implied
                    });
                }
            }
            
            const final = pq.size() === 0 ? 0 : pq.heap[0];
            steps.push({
                heap: pq.toArray(),
                y: null, x: null, result: final,
                msg: `Final Result: ${final}`,
                highlightLines: [9]
            });

            return steps;
        }

        // --- Render ---
        const width = 600, height = 350;
        const svg = d3.select("#tree-svg");
        const gMain = d3.select("#tree-main");
        const zoom = d3.zoom().on("zoom", (e) => gMain.attr("transform", e.transform));
        svg.call(zoom);
        svg.call(zoom.transform, d3.zoomIdentity.translate(width/2, 40).scale(1));

        const treeLayout = d3.tree().nodeSize([50, 60]);

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;

            // Render Stones in Slot
            const slotY = document.getElementById('slotY');
            const slotX = document.getElementById('slotX');
            
            // Clear but keep labels
            slotY.innerHTML = '<span style="margin-bottom:5px; font-size:0.8rem; color:#94a3b8">Max (Y)</span>';
            slotX.innerHTML = '<span style="margin-bottom:5px; font-size:0.8rem; color:#94a3b8">2nd Max (X)</span>';
            
            if(step.y !== null) {
                const stone = document.createElement('div');
                stone.className = 'stone-anim';
                stone.textContent = step.y;
                slotY.appendChild(stone);
            }
            if(step.x !== null) {
                const stone = document.createElement('div');
                stone.className = 'stone-anim';
                stone.textContent = step.x;
                // If destroyed
                if(step.result === 0 && step.msg.includes('destroyed')) {
                    stone.classList.add('broken');
                    if(slotY.lastChild) slotY.lastChild.classList.add('broken');
                }
                slotX.appendChild(stone);
            }
            
            // Render Heap
            gMain.selectAll("*").remove();
            if(step.heap.length > 0) {
                const root = d3.hierarchy(heapToHierarchy(step.heap));
                treeLayout(root);

                const links = gMain.selectAll(".link").data(root.links());
                links.enter().append("path").attr("class", "link")
                    .attr("d", d3.linkVertical().x(d => d.x).y(d => d.y));

                const nodes = gMain.selectAll(".node-g").data(root.descendants());
                const nEnter = nodes.enter().append("g").attr("class", "node-g")
                    .attr("transform", d => `translate(${d.x}, ${d.y})`);
                
                nEnter.append("circle").attr("r", 20).attr("class", d => d.depth === 0 ? "node-circle root" : "node-circle");
                nEnter.append("text").attr("class", "node-text").attr("dy", 1).text(d => d.data.val);
            }
        }

        function runVisualizer() {
            const arr = document.getElementById('stonesInput').value.split(',').map(x => parseInt(x.trim()));
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(arr));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
