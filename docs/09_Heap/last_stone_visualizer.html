<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Last Stone Weight (Max Heap) - D3 Dynamic Viz</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            min-height: 600px;
        }

        .dual-view {
            display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%;
        }

        /* Heap Tree */
        .tree-panel {
            width: 100%; height: 350px;
            background: rgba(30, 41, 59, 0.3); border-radius: 12px;
            position: relative; overflow: hidden;
            border: 1px solid rgba(148, 163, 184, 0.1);
        }
        #tree-svg { width: 100%; height: 100%; cursor: grab; }
        #tree-svg:active { cursor: grabbing; }

        /* Smash Zone */
        .smash-zone {
            height: 140px; width: 95%; display: flex; align-items: center; justify-content: center; gap: 40px;
            background: rgba(15, 23, 42, 0.6); border-radius: 12px; border: 1px solid #475569;
            position: relative; overflow: hidden;
        }
        .vs-label { 
            font-size: 2.5rem; font-weight: 900; 
            background: linear-gradient(135deg, #ef4444, #f59e0b); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-style: italic; z-index: 5;
        }
        
        .stone-slot {
            width: 90px; height: 90px; border: 2px dashed #475569; border-radius: 50%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #64748b; font-size: 0.8rem; position: relative;
            background: rgba(0,0,0,0.2);
        }
        
        .stone-anim {
            width: 80px; height: 80px; background: #fbbf24; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-weight: 800; font-size: 1.8rem; color: #0f172a;
            box-shadow: inset -5px -5px 15px rgba(0,0,0,0.3), 0 0 20px rgba(251, 191, 36, 0.4);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 2px solid rgba(255,255,255,0.4);
        }
        .stone-anim.broken { 
            opacity: 0; transform: scale(0) rotate(180deg); filter: grayscale(1);
        }
        .stone-anim.result { 
            background: #22c55e; box-shadow: 0 0 20px #22c55e; color: white; border-color: #fff;
        }

        /* D3 Nodes */
        .node-circle { fill: #334155; stroke: #64748b; stroke-width: 2px; transition: all 0.3s; }
        .node-circle.root { stroke: #fbbf24; stroke-width: 4px; }
        .node-circle.active { fill: #fbbf24; stroke: #fff; filter: drop-shadow(0 0 5px #fbbf24); }
        
        .node-text { fill: white; font-weight: bold; font-family: monospace; font-size: 14px; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        .link { stroke: #64748b; stroke-width: 2px; opacity: 0.4; fill: none; transition: stroke 0.3s; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; justify-content: center; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 250px; }
        .input-row button { padding: 8px 20px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; font-weight: 600; height: 38px; }
        
        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; width: 100%; box-sizing: border-box; }
        
        .legend { display: flex; gap: 15px; font-size: 0.8rem; color: #cbd5e1; margin-bottom: 10px; justify-content: center; }
        .legend-item { display: flex; align-items: center; gap: 6px; }
        .legend-color { width: 12px; height: 12px; border-radius: 3px; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Last Stone Weight (Max Heap)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <label style="font-weight:bold; color:#94a3b8">Stones:</label>
                        <input type="text" id="stonesInput" value="2, 7, 4, 1, 8, 1">
                        <button onclick="runVisualizer()">Smash!</button>
                    </div>
                    <div style="text-align:center; font-size:0.85rem; color:#64748b; margin-top:8px;">Max-Heap pops two largest stones (Y, X). If Y > X, push (Y-X) back.</div>
                </div>

                <div class="visualization-area">
                    <div class="smash-zone">
                        <div class="stone-slot" id="slotY">
                            <span style="position:absolute; top:5px; font-size:0.75rem; color:#94a3b8; font-weight:bold;">MAX (Y)</span>
                        </div>
                        <div class="vs-label">VS</div>
                        <div class="stone-slot" id="slotX">
                            <span style="position:absolute; top:5px; font-size:0.75rem; color:#94a3b8; font-weight:bold;">2ND MAX (X)</span>
                        </div>
                    </div>

                    <div class="legend">
                       <div class="legend-item"><div class="legend-color" style="border:3px solid #fbbf24; background:transparent"></div>Root (Max)</div>
                       <div class="legend-item"><div class="legend-color" style="background:#fbbf24"></div>Popped Stone</div>
                       <div class="legend-item"><div class="legend-color" style="background:#22c55e"></div>Survivor/Result</div>
                    </div>

                    <div class="tree-panel">
                        <svg id="tree-svg">
                            <g id="tree-main"></g>
                        </svg>
                    </div>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn" onclick="runVisualizer()">‚Üª ÈáçÁΩÆ</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">2x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card logic-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'int lastStoneWeight(vector<int>& stones) {', id: 0 },
            { line: '    priority_queue<int> pq(stones.begin(), stones.end());', id: 1 },
            { line: '    while (pq.size() > 1) {', id: 2 },
            { line: '        int y = pq.top(); pq.pop();', id: 3 },
            { line: '        int x = pq.top(); pq.pop();', id: 4 },
            { line: '        if (x != y) {', id: 5 },
            { line: '            pq.push(y - x);', id: 6 },
            { line: '        }', id: 7 },
            { line: '    }', id: 8 },
            { line: '    return pq.empty() ? 0 : pq.top();', id: 9 },
            { line: '}', id: 10 }
        ];

        let viz;

        // --- Helper ---
        function heapToHierarchy(arr) {
            if (arr.length === 0) return null;
            function build(idx) {
                if (idx >= arr.length) return null;
                const node = { id: idx, val: arr[idx], children: [] };
                const left = build(2 * idx + 1);
                const right = build(2 * idx + 2);
                if (left) node.children.push(left);
                if (right) node.children.push(right);
                return node;
            }
            return build(0);
        }

        // Basic Max Heap Implementation
        class MaxHeap {
            constructor(arr) {
                this.heap = [];
                if(arr) arr.forEach(x => this.push(x));
            }
            push(val) {
                this.heap.push(val);
                this.bubbleUp(this.heap.length - 1);
            }
            pop() {
                if(this.heap.length === 0) return null;
                const max = this.heap[0];
                const last = this.heap.pop();
                if(this.heap.length > 0) {
                    this.heap[0] = last;
                    this.bubbleDown(0);
                }
                return max;
            }
            bubbleUp(idx) {
                while(idx > 0) {
                    let p = Math.floor((idx-1)/2);
                    if(this.heap[idx] > this.heap[p]) {
                        [this.heap[idx], this.heap[p]] = [this.heap[p], this.heap[idx]];
                        idx = p;
                    } else break;
                }
            }
            bubbleDown(idx) {
                while(true) {
                    let l = 2*idx+1, r = 2*idx+2, largest = idx;
                    if(l < this.heap.length && this.heap[l] > this.heap[largest]) largest = l;
                    if(r < this.heap.length && this.heap[r] > this.heap[largest]) largest = r;
                    if(largest !== idx) {
                        [this.heap[idx], this.heap[largest]] = [this.heap[largest], this.heap[idx]];
                        idx = largest;
                    } else break;
                }
            }
            toArray() { return [...this.heap]; }
            size() { return this.heap.length; }
        }

        function simulate(stones) {
            const steps = [];
            
            // Build Heap Visual Step
            // We'll skip heapify steps unless requested, just show initial state
            const pq = new MaxHeap(stones); 
            
            const snap = (msg, hl, y, x, res, info={}) => ({
                heap: pq.toArray(),
                y, x, result: res,
                msg, highlightLines: hl, explanation: info
            });

            steps.push(snap("Initialized Max Heap", [1], null, null, null, { title: "ÂàùÂßãÂåñ", text: "Â∞áÊâÄÊúâÁü≥È†≠ÊîæÂÖ• Max-Heap„ÄÇ", formula: "priority_queue<int> pq" }));

            while(pq.size() > 1) {
                // Peek Y
                const y = pq.heap[0];
                steps.push(snap(`Peek Max (Y = ${y})`, [3], null, null, null, { title: "ÂèñÂá∫ÊúÄÂ§ßÂÄº", text: `ÁõÆÂâçÊúÄÂ§ßÁü≥È†≠ÊòØ ${y}„ÄÇ`, formula: "y = pq.top()" }));
                
                // Pop Y
                pq.pop(); 
                
                steps.push(snap(`Pop Y (${y}), waiting for X`, [3], y, null, null, { title: "ÁßªÈô§ Y", text: `Âæû Heap ÁßªÈô§ ${y}„ÄÇ`, formula: "pq.pop()" }));
                
                // Peek X
                const x = pq.heap[0];
                steps.push(snap(`Peek 2nd Max (X = ${x})`, [4], y, null, null, { title: "ÂèñÂá∫Ê¨°Â§ßÂÄº", text: `ÁõÆÂâçÊúÄÂ§ß (ÂéüÊ¨°Â§ß) ÊòØ ${x}„ÄÇ`, formula: "x = pq.top()" }));
                
                // Pop X
                pq.pop();
                
                steps.push(snap(`Pop X (${x}) -> Smash!`, [4], y, x, null, { title: "ÁßªÈô§ X", text: `Âæû Heap ÁßªÈô§ ${x}„ÄÇÂÖ©Áü≥Áõ∏ÊíûÔºÅ`, formula: "pq.pop()" }));
                
                // Clash
                let diff = y - x;
                
                if (x !== y) {
                    steps.push(snap(`Result: ${y} - ${x} = ${diff}. Push back.`, [5, 6], y, x, diff, { title: "Á≤âÁ¢éÁµêÊûú", text: `ÂÖ©Áü≥ÈáçÈáè‰∏çÂêåÔºåÂâ©È§òÈáçÈáè ${diff} ÊîæÂõû Heap„ÄÇ`, formula: "pq.push(y-x)" }));
                    pq.push(diff);
                    steps.push(snap(`Heap Updated (Added ${diff})`, [6], null, null, null, { title: "Êõ¥Êñ∞ Heap", text: `${diff} Â∑≤Âä†ÂÖ•‰∏¶ Sift Up„ÄÇ`, formula: "push finished" }));
                } else {
                    steps.push(snap(`Result: ${y} - ${x} = 0. Both Destroyed.`, [5], y, x, 0, { title: "ÂÆåÂÖ®Á≤âÁ¢é", text: `ÂÖ©Áü≥ÈáçÈáèÁõ∏ÂêåÔºåÂÖ®ÈÉ®Á≤âÁ¢éÔºåÁÑ°Ââ©È§ò„ÄÇ`, formula: "diff == 0" }));
                }
            }
            
            const final = pq.size() === 0 ? 0 : pq.heap[0];
            steps.push(snap(`Final Survivor: ${final}`, [9], null, null, final === 0 ? 0 : final, { title: "ÈÅäÊà≤ÁµêÊùü", text: `ÊúÄÂæåÂâ©È§òÁü≥È†≠ÈáçÈáèÔºö${final}„ÄÇ`, formula: "return result" }));

            return steps;
        }

        // --- Render ---
        const width = 600, height = 350;
        const svg = d3.select("#tree-svg");
        const gMain = d3.select("#tree-main");
        const zoom = d3.zoom().on("zoom", (e) => gMain.attr("transform", e.transform));
        svg.call(zoom);
        svg.call(zoom.transform, d3.zoomIdentity.translate(width/2, 40).scale(1));

        const treeLayout = d3.tree().nodeSize([50, 60]);

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;
            if (step.explanation) {
                document.getElementById('explanation').innerHTML = `
                    <div class="expl-title">${step.explanation.title}</div>
                    <div class="expl-text">${step.explanation.text}</div>
                    <div class="expl-formula">${step.explanation.formula}</div>
                `;
            }

            // Render Stones in Slot
            const slotY = document.getElementById('slotY');
            const slotX = document.getElementById('slotX');
            
            // Clear content but keep label spans if possible, actually we rebuild
            slotY.innerHTML = '<span style="position:absolute; top:5px; font-size:0.75rem; color:#94a3b8; font-weight:bold;">MAX (Y)</span>';
            slotX.innerHTML = '<span style="position:absolute; top:5px; font-size:0.75rem; color:#94a3b8; font-weight:bold;">2ND MAX (X)</span>';
            
            if(step.y !== null) {
                const stone = document.createElement('div');
                stone.className = 'stone-anim';
                stone.textContent = step.y;
                slotY.appendChild(stone);
            }
            if(step.x !== null) {
                const stone = document.createElement('div');
                stone.className = 'stone-anim';
                stone.textContent = step.x;
                
                // Result animation logic
               if(step.msg.includes('Result')) {
                    if (step.result === 0) {
                        stone.classList.add('broken');
                        if(slotY.lastChild) slotY.lastChild.classList.add('broken');
                    } else {
                        // Assuming X is smaller, it's broken. Y becomes survivor.
                        // Actually logic is: Y-X. Y is reduced.
                        // Visual: Stone Y shrinks or is replaced.
                        // Simple visual: Green stone appears in slot Y or X? Or distinct result?
                        // Let's rely on text. But we can make stone green.
                        // If we pushed back, the NEW stone is likely conceptually from Y-X.
                        // We highlight the diff.
                    }
                }
                slotX.appendChild(stone);
            }
            
            // Render Heap
            gMain.selectAll("*").remove();
            if(step.heap.length > 0) {
                const root = d3.hierarchy(heapToHierarchy(step.heap));
                treeLayout(root);

                const links = gMain.selectAll(".link").data(root.links());
                links.enter().append("path").attr("class", "link")
                    .attr("d", d3.linkVertical().x(d => d.x).y(d => d.y));

                const nodes = gMain.selectAll(".node-g").data(root.descendants());
                const nEnter = nodes.enter().append("g").attr("class", "node-g")
                    .attr("transform", d => `translate(${d.x}, ${d.y})`);
                
                nEnter.append("circle").attr("r", 20).attr("class", d => d.depth === 0 ? "node-circle root" : "node-circle");
                nEnter.append("text").attr("class", "node-text").attr("dy", 1).text(d => d.data.val);
            }
        }

        function runVisualizer() {
            const val = document.getElementById('stonesInput').value;
            if(!val) return;
            const arr = val.split(',').map(x => parseInt(x.trim())).filter(n => !isNaN(n));
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(arr));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
