<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Search (Grid DFS) - D3 Á≤æÁ∑ªË¶ñË¶∫Âåñ</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            min-height: 600px;
        }

        /* Grid */
        .grid-container {
            display: grid; gap: 6px; padding: 20px;
            background: rgba(30, 41, 59, 0.4); border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.3s;
        }
        .cell {
            width: 50px; height: 50px; display: flex; align-items: center; justify-content: center;
            background: #334155; border-radius: 8px; font-weight: bold; color: #cbd5e1;
            font-size: 1.2rem; transition: all 0.3s; border: 2px solid transparent;
        }
        
        /* States */
        .cell.visiting { background: #fbbf24; color: #0f172a; transform: scale(1.1); box-shadow: 0 0 15px rgba(251, 191, 36, 0.5); z-index: 10; border-color: #f59e0b; }
        .cell.visited { background: rgba(59, 130, 246, 0.3); border-color: #3b82f6; color: #93c5fd; } /* Path history */
        .cell.backtrack { background: #ef4444; color: white; animation: shake 0.4s; }
        .cell.success { background: #22c55e; color: white; border-color: #16a34a; box-shadow: 0 0 15px rgba(34, 197, 94, 0.5); animation: pulse 1s infinite; }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* Word Progress */
        .word-progress {
            display: flex; gap: 5px; font-family: monospace; font-size: 1.5rem; color: #64748b;
            margin-bottom: 10px;
        }
        .char-box {
            padding: 5px 10px; border-bottom: 3px solid #64748b; transition: all 0.3s;
        }
        .char-box.matched { color: #22c55e; border-color: #22c55e; transform: translateY(-3px); text-shadow: 0 0 10px rgba(34, 197, 94, 0.4); }
        .char-box.active { color: #fbbf24; border-color: #fbbf24; transform: scale(1.2); }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: start; justify-content: center; flex-wrap: wrap; }
        .input-group { display: flex; flex-direction: column; gap: 5px; }
        .input-group label { font-size: 0.8rem; color: #94a3b8; font-weight: bold; }
        textarea { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 140px; height: 80px; resize: none; }
        input[type="text"] { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 150px; }
        button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; font-weight: 600; height: 40px; align-self: flex-end; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Word Search (Backtracking Grid)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <div class="input-group">
                            <label>Grid (CSV):</label>
                            <textarea id="boardInput">A,B,C,E
S,F,C,S
A,D,E,E</textarea>
                        </div>
                        <div class="input-group">
                            <label>Target Word:</label>
                            <input type="text" id="wordInput" value="ABCCED">
                        </div>
                        <button onclick="runVisualizer()">Search</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <div class="word-progress" id="progressDisplay"></div>
                    <div class="grid-container" id="gridDisplay"></div>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn" onclick="runVisualizer()">‚Üª ÈáçÁΩÆ</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'bool exist(board, word) {', id: 0 },
            { line: '    for(r=0..m) for(c=0..n) {', id: 1 },
            { line: '        if(board[r][c] == word[0] && dfs(r, c, 0))', id: 2 },
            { line: '            return true;', id: 3 },
            { line: '    }', id: 4 },
            { line: '    return false;', id: 5 },
            { line: '}', id: 6 },
            { line: 'bool dfs(r, c, i) {', id: 7 },
            { line: '    if(i == word.size()) return true;', id: 8 },
            { line: '    if(!valid(r, c) || board[r][c] != word[i]) return false;', id: 9 },
            { line: '    char temp = board[r][c];', id: 10 },
            { line: '    board[r][c] = \'#\'; // Visit', id: 11 },
            { line: '    for(dir : directions) {', id: 12 },
            { line: '        if(dfs(nr, nc, i+1)) return true;', id: 13 },
            { line: '    }', id: 14 },
            { line: '    board[r][c] = temp; // Backtrack', id: 15 },
            { line: '    return false;', id: 16 },
            { line: '}', id: 17 }
        ];

        let viz;

        function simulate(grid, word) {
            const steps = [];
            const rows = grid.length;
            const cols = grid[0].length;
            // Use set to track visited for easy cloning in steps
            // Or mutate a grid copy.
            
            const pushState = (msg, hl, activeCell, visitedPath=[], matchedIdx=0, status='normal') => {
                steps.push({
                    grid: grid.map(r => [...r]), // copy content
                    activeCell,
                    visitedPath: [...visitedPath], // array of "r,c"
                    matchedIdx,
                    status, // normal, success, fail
                    msg, highlightLines: hl
                });
            };

            const visited = new Set();

            function dfs(r, c, i) {
                if (i === word.length) return true;
                
                const cellKey = `${r},${c}`;
                
                // Check bounds & content
                if (r < 0 || r >= rows || c < 0 || c >= cols || visited.has(cellKey) || grid[r][c] !== word[i]) {
                    // We only visualize "fail" if it was a candidate we explicitly checked
                    // Logic usually checks before recursing, or at start of recursion
                    return false;
                }

                // Match found
                visited.add(cellKey);
                pushState(`Match '${word[i]}' at (${r},${c})`, [11], {r,c}, Array.from(visited), i+1);

                if (i + 1 === word.length) {
                    pushState(`Found complete word!`, [8], {r,c}, Array.from(visited), i+1, 'success');
                    return true;
                }

                const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                for (const [dr, dc] of dirs) {
                    const nr = r + dr;
                    const nc = c + dc;
                    
                    // Optimistic highlight of trying next
                    if (nr>=0 && nr<rows && nc>=0 && nc<cols && !visited.has(`${nr},${nc}`)) {
                        pushState(`Try neighbor (${nr},${nc}) for '${word[i+1]}'`, [12, 13], {r:nr, c:nc}, Array.from(visited), i+1);
                        if (dfs(nr, nc, i + 1)) return true;
                    }
                }

                // Backtrack
                visited.delete(cellKey);
                pushState(`Backtrack from (${r},${c})`, [15], {r,c}, Array.from(visited), i, 'fail');
                return false;
            }

            pushState("Start Search", [1], null, [], 0);

            let found = false;
            for(let r=0; r<rows; r++){
                for(let c=0; c<cols; c++){
                    if(grid[r][c] === word[0]) {
                        pushState(`Start DFS from (${r},${c})`, [2], {r,c}, [], 0);
                        if(dfs(r, c, 0)) {
                            found = true;
                            pushState("Word Found!", [3], null, Array.from(visited), word.length, 'success');
                            break;
                        }
                    }
                }
                if(found) break;
            }
            
            if(!found) pushState("Word Not Found", [5], null, [], 0, 'fail');

            return steps;
        }

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;

            // Render Progress Word
            const progressDiv = document.getElementById('progressDisplay');
            const word = document.getElementById('wordInput').value;
            progressDiv.innerHTML = '';
            for(let i=0; i<word.length; i++) {
                const charBox = document.createElement('div');
                charBox.className = 'char-box';
                charBox.textContent = word[i];
                if(i < step.matchedIdx) charBox.classList.add('matched');
                if(i === step.matchedIdx) charBox.classList.add('active'); // searching for this
                progressDiv.appendChild(charBox);
            }

            // Render Grid
            const gridContainer = document.getElementById('gridDisplay');
            gridContainer.innerHTML = '';
            const rows = step.grid.length;
            const cols = step.grid[0].length;
            gridContainer.style.gridTemplateColumns = `repeat(${cols}, 50px)`; // Fixed cell size

            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    const div = document.createElement('div');
                    div.className = 'cell';
                    div.textContent = step.grid[r][c];
                    
                    const cellKey = `${r},${c}`;
                    if(step.visitedPath.includes(cellKey)) {
                        div.classList.add('visited');
                    }
                    
                    // Active logic
                    if(step.activeCell && step.activeCell.r === r && step.activeCell.c === c) {
                        div.classList.remove('visited'); // Override
                        if(step.status === 'success') div.classList.add('success');
                        else if(step.status === 'fail') div.classList.add('backtrack');
                        else div.classList.add('visiting');
                    }
                    
                    gridContainer.appendChild(div);
                }
            }
        }

        function runVisualizer() {
            const boardStr = document.getElementById('boardInput').value;
            const word = document.getElementById('wordInput').value;
            const grid = boardStr.split('\n').map(line => line.split(',').map(c => c.trim()));
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(grid, word));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
