<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Search (Grid DFS) - D3 Dynamic Viz</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .visualization-area {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            min-height: 600px;
        }

        /* Grid */
        .grid-container {
            display: grid; gap: 6px; padding: 20px;
            background: rgba(30, 41, 59, 0.4); border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.3s;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }
        .cell {
            width: 50px; height: 50px; display: flex; align-items: center; justify-content: center;
            background: #334155; border-radius: 8px; font-weight: bold; color: #cbd5e1;
            font-size: 1.4rem; transition: all 0.3s; border: 2px solid transparent;
            font-family: 'Courier New', monospace;
        }
        
        /* States */
        .cell.visiting { background: #fbbf24; color: #0f172a; transform: scale(1.1); box-shadow: 0 0 15px rgba(251, 191, 36, 0.5); z-index: 10; border-color: #f59e0b; }
        .cell.visited { background: rgba(59, 130, 246, 0.2); border-color: #3b82f6; color: #93c5fd; } /* Path history */
        .cell.backtrack { background: #ef4444; color: white; animation: shake 0.4s; z-index: 10; }
        .cell.success { background: #22c55e; color: white; border-color: #16a34a; box-shadow: 0 0 15px rgba(34, 197, 94, 0.5); animation: pulse 1s infinite; z-index: 5; }
        
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* Word Progress */
        .word-progress {
            display: flex; gap: 8px; font-family: monospace; font-size: 1.5rem; color: #64748b;
            margin-bottom: 10px; background: rgba(15, 23, 42, 0.5); padding: 10px 20px; border-radius: 8px;
        }
        .char-box {
            padding: 5px 10px; border-bottom: 3px solid #475569; transition: all 0.3s; color: #94a3b8;
        }
        .char-box.matched { color: #22c55e; border-color: #22c55e; transform: translateY(-3px); text-shadow: 0 0 10px rgba(34, 197, 94, 0.4); font-weight: bold; }
        .char-box.active { color: #fbbf24; border-color: #fbbf24; transform: scale(1.1); font-weight: bold; }

        /* Controls */
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 15px; align-items: start; justify-content: center; flex-wrap: wrap; }
        .input-group { display: flex; flex-direction: column; gap: 5px; }
        .input-group label { font-size: 0.85rem; color: #94a3b8; font-weight: bold; }
        textarea { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 140px; height: 80px; resize: none; letter-spacing: 2px; }
        input[type="text"] { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 150px; text-transform: uppercase; letter-spacing: 2px; }
        button { padding: 8px 20px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; font-weight: 600; height: 40px; align-self: center; }

        .step-breakdown { background: rgba(30, 41, 59, 0.6); border-radius: 12px; border-left: 4px solid #3b82f6; padding: 15px 20px; width: 100%; box-sizing: border-box; }
        
        .legend { display: flex; gap: 15px; font-size: 0.8rem; color: #cbd5e1; margin-bottom: 15px; justify-content: center; width: 100%; }
        .legend-item { display: flex; align-items: center; gap: 6px; }
        .legend-color { width: 12px; height: 12px; border-radius: 3px; }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="ÂàáÊèõ‰∏ªÈ°å">üåì</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">Word Search (Backtracking Grid)</div>
                <div class="custom-input-section">
                    <div class="input-row">
                        <div class="input-group">
                            <label>Grid (CSV):</label>
                            <textarea id="boardInput">A,B,C,E
S,F,C,S
A,D,E,E</textarea>
                        </div>
                        <div class="input-group">
                            <label>Target Word:</label>
                            <input type="text" id="wordInput" value="ABCCED">
                        </div>
                        <button onclick="runVisualizer()">Search Path</button>
                    </div>
                    <div style="text-align:center; font-size:0.85rem; color:#64748b; margin-top:8px;">
                        Find sequential path in grid matching word. Cells cannot be reused in single path.
                    </div>
                </div>

                <div class="visualization-area">
                    <div class="legend">
                       <div class="legend-item"><div class="legend-color" style="background:#fbbf24"></div>Current</div>
                       <div class="legend-item"><div class="legend-color" style="background:#22c55e"></div>Found Path</div>
                       <div class="legend-item"><div class="legend-color" style="background:rgba(59, 130, 246, 0.3); border:1px solid #3b82f6"></div>Visited</div>
                       <div class="legend-item"><div class="legend-color" style="background:#ef4444"></div>Backtrack</div>
                    </div>

                    <div class="word-progress" id="progressDisplay"></div>
                    <div class="grid-container" id="gridDisplay"></div>
                </div>

                <div class="step-breakdown">
                    <div style="font-size:0.75rem; font-weight:bold; color:#64748b;">Áï∂ÂâçÊ≠•È©ü</div>
                    <div id="stepText" style="font-size:0.95rem; font-family:monospace; color:#e2e8f0;">Ready.</div>
                </div>

                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">‚Üê ‰∏ä‰∏ÄÊ≠•</button>
                    <div class="step-indicator">Ê≠•È©ü <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">‰∏ã‰∏ÄÊ≠• ‚Üí</button>
                    <button class="viz-btn" onclick="runVisualizer()">‚Üª ÈáçÁΩÆ</button>
                    <button class="viz-btn play-btn" id="playBtn" onclick="viz.toggleAutoPlay()">‚ñ∂ Ëá™ÂãïÊí≠Êîæ</button>
                    <div class="speed-control">
                        <label>ÈÄüÂ∫¶:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">0.5x</option>
                            <option value="1000" selected>1x</option>
                            <option value="500">1.5x</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="viz-card logic-card"><div class="viz-title">ÈÇèËºØËß£Èáã</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">C++ Code</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>

    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'bool exist(board, word) {', id: 0 },
            { line: '    for(r=0..m) for(c=0..n) {', id: 1 },
            { line: '        if(board[r][c] == word[0] && dfs(r, c, 0))', id: 2 },
            { line: '            return true;', id: 3 },
            { line: '    }', id: 4 },
            { line: '    return false;', id: 5 },
            { line: '}', id: 6 },
            { line: 'bool dfs(r, c, i) {', id: 7 },
            { line: '    if(i == word.size()) return true;', id: 8 },
            { line: '    // Check bounds, visited, match', id: 9 },
            { line: '    if(!valid(r, c) || visited[r][c] || board[r][c] != word[i]) return false;', id: 10 },
            { line: '    visited[r][c] = true;', id: 11 },
            { line: '    for(dir : directions) {', id: 12 },
            { line: '        if(dfs(nr, nc, i+1)) return true;', id: 13 },
            { line: '    }', id: 14 },
            { line: '    visited[r][c] = false; // Backtrack', id: 15 },
            { line: '    return false;', id: 16 },
            { line: '}', id: 17 }
        ];

        let viz;

        function simulate(grid, word) {
            const steps = [];
            const rows = grid.length;
            const cols = grid[0].length;
            
            const pushState = (msg, hl, activeCell, visitedList, matchedIdx, status='normal', info={}) => {
                steps.push({
                    grid: grid.map(r => [...r]), 
                    activeCell,
                    visitedPath: [...visitedList], // array of "r,c"
                    matchedIdx,
                    status, 
                    msg, highlightLines: hl, explanation: info
                });
            };

            // Using Set for visited tracking in simulation logic
            const visited = new Set();

            function dfs(r, c, i) {
                // If we reached here, grid[r][c] matched word[i] in caller logic check
                // unless i==length
                
                // Wait, recursion structure usually: check base case i==len first.
                // But we call dfs(0) with i=0 first char.
                
                // Let's adapt logic to strict visual match
                const cellKey = `${r},${c}`;
                
                // Visit
                visited.add(cellKey);
                
                const isComplete = (i + 1 === word.length);
                const explTitle = isComplete ? "ÊâæÂà∞ÂÆåÊï¥ÂñÆÂ≠ó" : `ÂåπÈÖçÂ≠óÁ¨¶ '${word[i]}'`;
                const explText = isComplete ? "Ë∑ØÂæëÈï∑Â∫¶Á≠âÊñºÂñÆÂ≠óÈï∑Â∫¶ÔºåÊêúÂ∞ãÊàêÂäü„ÄÇ" : `Á∂≤Ê†º‰ΩçÁΩÆ (${r},${c}) ÂåπÈÖç '${word[i]}'„ÄÇÊ®ôË®òÁÇ∫Â∑≤Ë®™Âïè„ÄÇ`;
                
                pushState(`Match '${word[i]}' at (${r},${c})`, [11], {r,c}, Array.from(visited), i+1, isComplete?'success':'normal', {
                    title: explTitle, text: explText, formula: "visited[r][c] = true"
                });

                if (isComplete) return true;

                const dirs = [[0,1], [0,-1], [1,0], [-1,0]]; // R, L, D, U
                for (const [dr, dc] of dirs) {
                    const nr = r + dr;
                    const nc = c + dc;
                    
                    const nKey = `${nr},${nc}`;
                    // Highlight intent to check
                    if (nr>=0 && nr<rows && nc>=0 && nc<cols && !visited.has(nKey)) {
                        // Check content match visually before recursing fully
                        // In real code we recurse then check base case.
                        // Here we peek to give visual feedback "Testing neighbor..."
                        const targetChar = word[i+1];
                        const match = (grid[nr][nc] === targetChar);
                        
                        pushState(`Check neighbor (${nr},${nc}) for '${targetChar}'...`, [12, 13], {r:nr, c:nc}, Array.from(visited), i+1, match ? 'visiting' : 'normal', {
                            title: `Êé¢Á¥¢ÈÑ∞Â±Ö (${nr},${nc})`, text: `Ê™¢Êü•ÈÑ∞Â±ÖÊòØÂê¶ÁÇ∫ '${targetChar}' ‰∏îÊú™Ë¢´Ë®™Âïè„ÄÇ`, formula: "dfs(nr, nc, i+1)"
                        });

                        if (match) {
                            if (dfs(nr, nc, i + 1)) return true;
                        } else {
                            // Mismatch visualization (optional, usually skipped in fast recursion, but good for learning)
                            // pushState(`Mismatch at (${nr},${nc})`, [10], {r:nr, c:nc}, Array.from(visited), i+1, 'fail');
                        }
                    }
                }

                // Backtrack
                visited.delete(cellKey);
                pushState(`Backtrack from (${r},${c}) - Undo Visit`, [15], {r,c}, Array.from(visited), i, 'fail', {
                    title: "ÂõûÊ∫Ø (Backtrack)", text: `ÊâÄÊúâÈÑ∞Â±ÖÁöÜÁÑ°Ê≥ïÂÆåÊàêÂñÆÂ≠óÔºåÊí§Èä∑Áï∂Ââç‰ΩçÁΩÆ (${r},${c}) ÁöÑË®™ÂïèÊ®ôË®ò„ÄÇ`, formula: "visited[r][c] = false"
                });
                return false;
            }

            pushState("Start Search", [1], null, [], 0, 'normal', {title:"ÈñãÂßã", text:"ÈÅçÊ≠∑Á∂≤Ê†ºÂ∞ãÊâæÈ¶ñÂ≠óÂÖÉ„ÄÇ", formula:"for r, c"});

            let found = false;
            for(let r=0; r<rows; r++){
                for(let c=0; c<cols; c++){
                    if(grid[r][c] === word[0]) {
                        pushState(`Found Start '${word[0]}' at (${r},${c})`, [2], {r,c}, [], 0, 'visiting',{
                            title: `È¶ñÂ≠óÂÖÉÂåπÈÖç`, text: `‰ΩçÁΩÆ (${r},${c}) ÂåπÈÖç '${word[0]}'ÔºåÈñãÂßã DFS„ÄÇ`, formula: "if board == word[0]"
                        });
                        
                        if(dfs(r, c, 0)) {
                            found = true;
                            // Final success state already pushed inside dfs
                            break;
                        }
                    }
                }
                if(found) break;
            }
            
            if(!found) pushState("Word Not Found", [5], null, [], 0, 'fail', {title:"Â§±Êïó", text:"Â∑≤ÈÅçÊ≠∑ÊâÄÊúâÂèØËÉΩË∑ØÂæëÔºåÊú™ÊâæÂà∞ÂñÆÂ≠ó„ÄÇ", formula:"return false"});

            return steps;
        }

        function render(step) {
            document.getElementById('stepText').textContent = step.msg;
            
            if (step.explanation) {
                document.getElementById('explanation').innerHTML = `
                    <div class="expl-title">${step.explanation.title}</div>
                    <div class="expl-text">${step.explanation.text}</div>
                    <div class="expl-formula">${step.explanation.formula}</div>
                `;
            }

            // Word Progress
            const progressDiv = document.getElementById('progressDisplay');
            const word = document.getElementById('wordInput').value;
            progressDiv.innerHTML = '';
            for(let i=0; i<word.length; i++) {
                const charBox = document.createElement('div');
                charBox.className = 'char-box';
                charBox.textContent = word[i];
                if(i < step.matchedIdx) charBox.classList.add('matched');
                if(i === step.matchedIdx) charBox.classList.add('active'); 
                progressDiv.appendChild(charBox);
            }

            // Grid
            const gridContainer = document.getElementById('gridDisplay');
            gridContainer.innerHTML = '';
            const rows = step.grid.length;
            const cols = step.grid[0].length;
            gridContainer.style.gridTemplateColumns = `repeat(${cols}, 50px)`;

            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    const div = document.createElement('div');
                    div.className = 'cell';
                    div.textContent = step.grid[r][c];
                    
                    const cellKey = `${r},${c}`;
                    if(step.visitedPath.includes(cellKey)) {
                        div.classList.add('visited');
                    }
                    
                    if(step.activeCell && step.activeCell.r === r && step.activeCell.c === c) {
                        div.classList.remove('visited'); // Highlight takes precedence
                        if(step.status === 'success') div.classList.add('success');
                        else if(step.status === 'fail') div.classList.add('backtrack');
                        else if(step.status === 'visiting') div.classList.add('visiting');
                        else div.classList.add('visiting'); // default
                    }
                    
                    gridContainer.appendChild(div);
                }
            }
        }

        function runVisualizer() {
            const boardStr = document.getElementById('boardInput').value;
            const word = document.getElementById('wordInput').value.trim();
            if(!boardStr || !word) return;
            
            const grid = boardStr.split('\n').map(line => line.split(',').map(c => c.trim()));
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: render
            });
            viz.setSteps(simulate(grid, word));
        }

        window.addEventListener('load', runVisualizer);
    </script>
</body>
</html>
