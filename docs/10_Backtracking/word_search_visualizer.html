<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Search - è¦–è¦ºåŒ–</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
        .input-row textarea { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; width: 250px; height: 60px; }
        .input-row input { padding: 8px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; height: 40px; }

        .viz-container { text-align: center; margin-top: 10px; }
        .grid-container { 
            display: inline-grid; gap: 4px; padding: 10px; 
            background: var(--viz-bg-secondary); border-radius: 8px; 
            margin-bottom: 15px;
        }
        .cell { 
            width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; 
            font-weight: bold; border-radius: 4px; background: var(--viz-primary); color: white; 
            font-size: 1.1rem; transition: background 0.2s, transform 0.2s;
        }
        .cell.visiting { background: var(--viz-warning); color: #0f172a; transform: scale(1.1); box-shadow: 0 0 8px var(--viz-warning); }
        .cell.path-node { background: var(--viz-success); color: #0f172a; border: 2px solid white; }
        .cell.backtrack { background: var(--viz-error); opacity: 0.6; }
        
        .target-word { font-size: 1.5rem; letter-spacing: 5px; font-weight: bold; margin: 10px 0; }
        .target-char.matched { color: var(--viz-success); text-shadow: 0 0 5px var(--viz-success); }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="åˆ‡æ›ä¸»é¡Œ">ğŸŒ“</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">å–®è©æœç´¢ (Word Search) - DFS</div>
                <div class="custom-input-section">
                    <div style="font-weight:bold; margin-bottom:5px;">ğŸ® è‡ªè¨‚æ¸¬è©¦</div>
                    <div class="input-row">
                        <div>
                            <label style="display:block;">ç¶²æ ¼ (æ¯è¡Œä¸€åˆ—, é€—è™Ÿåˆ†éš”):</label>
                            <textarea id="boardInput">A,B,C,E
S,F,C,S
A,D,E,E</textarea>
                        </div>
                        <div>
                            <label style="display:block;">ç›®æ¨™å–®è©:</label>
                            <input type="text" id="wordInput" value="ABCCED" style="width: 100px;">
                        </div>
                        <button onclick="runCustomInput()">åŸ·è¡Œ</button>
                    </div>
                </div>
                
                <div class="viz-container">
                    <div class="target-word" id="wordDisplay"></div>
                    <div class="grid-container" id="gridDisplay"></div>
                </div>
                
                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">â† ä¸Šä¸€æ­¥</button>
                    <div class="step-indicator">æ­¥é©Ÿ <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">ä¸‹ä¸€æ­¥ â†’</button>
                    <button class="viz-btn" onclick="resetVisualization()">â†» é‡ç½®</button>
                    <div class="speed-control">
                        <label>é€Ÿåº¦:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">1x</option>
                            <option value="500">2x</option>
                        </select>
                    </div>
                </div>
                
                <div class="complexity-badge">
                    <span class="label">Time:</span> O(N*3^L)
                    <span class="label" style="margin-left: 12px;">Space:</span> O(L)
                </div>
                <div class="state-grid">
                    <div class="state-item"><div class="state-label">Result</div><div class="state-value" id="resultDisplay">?</div></div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">æ¼”ç®—æ³•èªªæ˜</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">æ¼”ç®—æ³• (C++)</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'bool exist(board, word) {', id: 0 },
            { line: '    for (int i=0; i<rows; ++i)', id: 1 },
            { line: '        for (int j=0; j<cols; ++j)', id: 2 },
            { line: '            if (dfs(i, j, 0)) return true;', id: 3 },
            { line: '    return false;', id: 4 },
            { line: '}', id: 5 },
            { line: 'bool dfs(r, c, k) {', id: 6 },
            { line: '    if (k == word.size()) return true;', id: 7 },
            { line: '    if (OutOfBounds || board[r][c] != word[k]) return false;', id: 8 },
            { line: '    char tmp = board[r][c];', id: 9 },
            { line: '    board[r][c] = \'#\'; // Mark visited', id: 10 },
            { line: '    bool res = dfs(r+1, c, k+1) || ... ;', id: 11 },
            { line: '    board[r][c] = tmp; // Restore', id: 12 },
            { line: '    return res;', id: 13 },
            { line: '}', id: 14 },
        ];

        let currentBoard = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']];
        let currentWord = "ABCCED";

        function parseBoard(str) {
            return str.trim().split('\n').map(row => row.split(',').map(c => c.trim()).filter(c=>c));
        }

        function runCustomInput() {
            const bStr = document.getElementById('boardInput').value;
            const wStr = document.getElementById('wordInput').value.trim();
            const b = parseBoard(bStr);
            if (b.length === 0 || b[0].length === 0 || !wStr) {
                alert('è¼¸å…¥ç„¡æ•ˆ');
                return;
            }
            currentBoard = b;
            currentWord = wStr;
            init();
        }

        function generateAlgorithmSteps(board, word) {
            const steps = [];
            const m = board.length;
            const n = board[0].length;
            let path = []; // stores {r, c}
            
            steps.push({
                path: [], visiting: null, k: 0, result: null,
                explanation: { title: 'é–‹å§‹', text: `Board: ${m}x${n}, Word: "${word}"`, formula: 'init' }
            });

            function dfs(r, c, k) {
                // Visiting
                steps.push({
                    path: [...path], visiting: {r, c}, k: k, result: null,
                    highlightLines: [6, 8],
                    explanation: { title: `æª¢æŸ¥ (${r}, ${c})`, text: `å­—å…ƒ: '${board[r][c]}', ç›®æ¨™: word[${k}] ('${word[k]}')`, formula: `check board[${r}][${c}]` }
                });

                if (board[r][c] !== word[k]) {
                    // Mismatch visual handled implicitly by logical flow (backtrack or return false step)
                    return false;
                }

                path.push({r, c});
                const temp = board[r][c];
                board[r][c] = '#'; // visited
                
                // Match Found Step
                steps.push({
                    path: [...path], visiting: {r, c}, k: k+1, result: null,
                    highlightLines: [9, 10],
                    explanation: { title: `åŒ¹é… '${temp}'`, text: `åŒ¹é…æˆåŠŸï¼æ¨™è¨˜ç‚ºå·²è¨ªå• (#)<br>ç¹¼çºŒå°‹æ‰¾ word[${k+1}]`, formula: 'matched & next' }
                });

                if (k === word.length - 1) {
                    steps.push({
                        path: [...path], visiting: null, k: k+1, result: true,
                        highlightLines: [7],
                        explanation: { title: 'æ‰¾åˆ°!', text: 'å·²åŒ¹é…æ•´å€‹å–®è©ï¼Œè¿”å› true', formula: 'return true' }
                    });
                     // Restore just to be clean, though deep copy or simulation logic might vary
                    board[r][c] = temp; 
                    path.pop();
                    return true;
                }

                const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                for (let [dr, dc] of dirs) {
                    const nr = r + dr, nc = c + dc;
                    if (nr >= 0 && nr < m && nc >= 0 && nc < n && board[nr][nc] !== '#') {
                        if (dfs(nr, nc, k + 1)) {
                             // Restore
                            board[r][c] = temp;
                            return true; // Propagate success
                        }
                    }
                }

                // Backtrack
                board[r][c] = temp;
                path.pop();
                steps.push({
                    path: [...path], visiting: {r, c}, k: k, result: null,
                    highlightLines: [12],
                    explanation: { title: 'å›æº¯', text: `å¾ (${r}, ${c}) ç„¡æ³•æ‰¾åˆ°å¾ŒçºŒè·¯å¾‘<br>æ¢å¾© '${temp}'ï¼Œé€€å›ä¸Šä¸€æ­¥`, formula: 'backtrack' }
                });

                return false;
            }

            let found = false;
            // Limit visualization: simple scan until first cell match start or limit steps
            // We'll wrap the main loop but try to minimize excessive steps for non-start cells
            outer: for (let i = 0; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    if (board[i][j] === word[0]) {
                        // Start DFS
                        if (dfs(i, j, 0)) {
                            found = true;
                            break outer;
                        }
                    } else {
                         // Visualize skip briefly? Maybe too noisy. Just highlight loop.
                    }
                }
            }

            if (!found) {
                steps.push({
                    path: [], visiting: null, k: 0, result: false,
                    final: true,
                    highlightLines: [4],
                    explanation: { title: 'çµæŸ', text: 'éæ­·æ‰€æœ‰å¯èƒ½èµ·é»ï¼Œæœªæ‰¾åˆ°å–®è©', formula: 'return false' }
                });
            } else {
                 steps.push({
                    path: steps[steps.length-1].path, visiting: null, k: word.length, result: true,
                    final: true,
                    highlightLines: [3],
                    explanation: { title: 'æˆåŠŸ', text: 'å–®è©å­˜åœ¨æ–¼ç¶²æ ¼ä¸­', formula: 'Done' }
                });
            }

            return steps;
        }

        let viz;
        function init() {
            // Setup Grid
            const container = document.getElementById('gridDisplay');
            container.style.gridTemplateColumns = `repeat(${currentBoard[0].length}, 40px)`;
            
            // Re-render handled by onStepChange mostly, but initial grid needed?
            // onStepChange will do full render.
            
            // We need a deep copy for simulation because DFS mutates
            const simBoard = currentBoard.map(row => [...row]);
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: (step) => {
                    // Update Grid
                    container.innerHTML = '';
                    for(let r=0; r<currentBoard.length; r++) {
                        for(let c=0; c<currentBoard[0].length; c++) {
                            const val = currentBoard[r][c];
                            let cls = 'cell';
                            
                            // Check path inclusion
                            const inPath = step.path.some(p => p.r === r && p.c === c);
                            if (inPath) cls += ' path-node';
                            
                            // Check visiting
                            if (step.visiting && step.visiting.r === r && step.visiting.c === c) {
                                cls += ' visiting';
                            }
                            
                            const div = document.createElement('div');
                            div.className = cls;
                            div.textContent = val;
                            container.appendChild(div);
                        }
                    }

                    // Update Word Highlight
                    let wHtml = '';
                    for(let i=0; i<currentWord.length; i++) {
                        let cls = 'target-char';
                        // if we are at step k, chars 0..k-1 are matched
                        // step.k is index of char we are trying to match or successfully matched
                        // If result is true, all matched
                        // This logic depends on exactly when k increments in steps
                        if (i < step.k) cls += ' matched'; 
                        wHtml += `<span class="${cls}">${currentWord[i]}</span>`;
                    }
                    document.getElementById('wordDisplay').innerHTML = wHtml;
                    
                    document.getElementById('resultDisplay').textContent = step.result === null ? 'Searching...' : step.result;
                    if (step.result === true) document.getElementById('resultDisplay').style.color = 'var(--viz-success)';
                    else if (step.result === false) document.getElementById('resultDisplay').style.color = 'var(--viz-error)';
                    else document.getElementById('resultDisplay').style.color = 'var(--viz-text)';
                }
            });
            viz.setSteps(generateAlgorithmSteps(simBoard, currentWord));
        }

        function resetVisualization() { init(); }
        window.addEventListener('load', init);
    </script>
</body>
</html>
