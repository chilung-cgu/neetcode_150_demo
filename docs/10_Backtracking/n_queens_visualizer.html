<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N-Queens - è¦–è¦ºåŒ–</title>
    <link rel="stylesheet" href="../assets/visualizer/style.css">
    <style>
        .custom-input-section { background: var(--viz-card-bg); border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid var(--viz-border); }
        .input-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
        .input-row input { padding: 8px 12px; border-radius: 6px; border: 1px solid var(--viz-border); background: var(--viz-input-bg); color: var(--viz-text); font-family: monospace; }
        .input-row button { padding: 8px 16px; border-radius: 6px; background: var(--viz-primary); color: white; border: none; cursor: pointer; }

        .board-container { display: flex; justify-content: center; margin: 20px 0; }
        .board { 
            display: grid; gap: 2px; padding: 10px; background: #6b4c35; border-radius: 6px; 
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }
        .cell { 
            display: flex; align-items: center; justify-content: center; 
            font-size: 1.8rem; font-weight: bold; position: relative;
        }
        .cell.light { background: #f0d9b5; }
        .cell.dark { background: #b58863; }
        .cell.queen { color: #000; text-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        /* Attack zones */
        .cell.attacked::after {
            content: ''; position: absolute; width: 30%; height: 30%; 
            background: rgba(255, 0, 0, 0.4); border-radius: 50%;
        }
        .cell.current { box-shadow: inset 0 0 0 3px var(--viz-primary); }
        .cell.invalid { background: rgba(255, 0, 0, 0.3) !important; }

        .solutions-gallery { display: flex; gap: 10px; overflow-x: auto; padding-bottom: 10px; margin-top: 15px; }
        .mini-board { 
            display: grid; gap: 1px; width: 60px; height: 60px; background: #6b4c35; border: 2px solid var(--viz-success);
        }
        .mini-cell { background: #f0d9b5; }
        .mini-cell.q { background: var(--viz-success); }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="AlgorithmVisualizer.toggleTheme()" title="åˆ‡æ›ä¸»é¡Œ">ğŸŒ“</button>
    <div class="main-layout">
        <div class="canvas-area">
            <div class="viz-card">
                <div class="viz-title">N çš‡å (N-Queens)</div>
                <div class="custom-input-section">
                    <div style="font-weight:bold; margin-bottom:5px;">ğŸ® è‡ªè¨‚æ¸¬è©¦</div>
                    <div class="input-row">
                        <label>N (1-6 å»ºè­°):</label>
                        <input type="number" id="nInput" value="4" style="width: 60px;" min="1" max="8">
                        <button onclick="runCustomInput()">åŸ·è¡Œ</button>
                    </div>
                </div>
                
                <div class="board-container">
                    <div class="board" id="boardDisplay"></div>
                </div>
                
                <div style="text-align: center; color: var(--text-muted);">å·²æ‰¾åˆ°çš„è§£</div>
                <div class="solutions-gallery" id="solutionsDisplay"></div>
                
                <div class="controls" style="margin-top: 15px;">
                    <button class="viz-btn" id="prevBtn">â† ä¸Šä¸€æ­¥</button>
                    <div class="step-indicator">æ­¥é©Ÿ <span id="currentStep">0</span> / <span id="totalSteps">0</span></div>
                    <button class="viz-btn primary" id="nextBtn">ä¸‹ä¸€æ­¥ â†’</button>
                    <button class="viz-btn" onclick="resetVisualization()">â†» é‡ç½®</button>
                    <div class="speed-control">
                        <label>é€Ÿåº¦:</label>
                        <select id="speedSelect" onchange="viz.setSpeed(Number(this.value))">
                            <option value="1500">1x</option>
                            <option value="500">2x</option>
                        </select>
                    </div>
                </div>
                
                <div class="complexity-badge">
                    <span class="label">Time:</span> O(N!)
                    <span class="label" style="margin-left: 12px;">Space:</span> O(N)
                </div>
                <div class="state-grid">
                    <div class="state-item"><div class="state-label">è§£ç¸½æ•¸</div><div class="state-value" id="countDisplay">0</div></div>
                </div>
            </div>
            <div class="viz-card"><div class="viz-title">æ¼”ç®—æ³•èªªæ˜</div><div class="explanation" id="explanation"></div></div>
        </div>
        <div class="code-area">
            <div class="viz-card" style="height: 100%;">
                <div class="viz-title">æ¼”ç®—æ³• (C++)</div>
                <div class="code-panel" id="codeDisplay"></div>
            </div>
        </div>
    </div>
    <script src="../assets/visualizer/core.js"></script>
    <script>
        const codeStructure = [
            { line: 'void solve(row, n, cols, diag1, diag2) {', id: 0 },
            { line: '    if (row == n) {', id: 1 },
            { line: '        result.push_back(board); return;', id: 2 },
            { line: '    }', id: 3 },
            { line: '    for (int col = 0; col < n; col++) {', id: 4 },
            { line: '        if (cols[col] || diag1[r+c] || diag2[r-c]) continue;', id: 5 },
            { line: '        board[row][col] = \'Q\';', id: 6 },
            { line: '        cols[col] = diag1[r+c] = diag2[r-c] = true;', id: 7 },
            { line: '        solve(row + 1, n, ...);', id: 8 },
            { line: '        // Backtrack', id: 9 },
            { line: '        board[row][col] = \'.\';', id: 10 },
            { line: '        cols[col] = diag1[r+c] = diag2[r-c] = false;', id: 11 },
            { line: '    }', id: 12 },
            { line: '}', id: 13 },
        ];

        let currentN = 4;

        function runCustomInput() {
            const val = parseInt(document.getElementById('nInput').value);
            if (isNaN(val) || val < 1 || val > 8) { // 8 is slow but possible, restrict for UX
                alert('è«‹è¼¸å…¥ 1-8 ä¹‹é–“çš„ N');
                return;
            }
            // Visualization complexity: >6 gets very long
            if (val > 6 && !confirm('N > 6 æœƒç”¢ç”Ÿå¤§é‡æ­¥é©Ÿï¼Œå¯èƒ½å¾ˆæ…¢ã€‚ç¢ºå®šè¦åŸ·è¡Œå—ï¼Ÿ')) return;
            
            currentN = val;
            init();
        }

        function generateAlgorithmSteps(n) {
            const steps = [];
            const solutions = [];
            // State tracking
            const cols = new Set();
            const diag1 = new Set(); // r + c
            const diag2 = new Set(); // r - c
            const queens = []; // {r, c}
            
            steps.push({
                queens: [], cols: [], diag1: [], diag2: [], solutions: [],
                highlightLines: [0],
                explanation: { title: 'åˆå§‹åŒ–', text: `N=${n}<br>æº–å‚™é–‹å§‹`, formula: 'solve(0)' }
            });

            function solve(row) {
                if (row === n) {
                    solutions.push([...queens]);
                    steps.push({
                        queens: [...queens], solutions: [...solutions], row: row,
                        newFound: true,
                        highlightLines: [1, 2, 3],
                        explanation: { title: 'æ‰¾åˆ°è§£ï¼', text: `æˆåŠŸæ”¾ç½® ${n} å€‹çš‡å`, formula: 'Found' }
                    });
                    return;
                }

                for (let col = 0; col < n; col++) {
                    const isAttacked = cols.has(col) || diag1.has(row + col) || diag2.has(row - col);
                    
                    steps.push({
                        queens: [...queens], row: row, col: col, solutions: [...solutions],
                        trying: true, isAttacked: isAttacked,
                        highlightLines: [4, 5],
                        explanation: { 
                            title: `å˜—è©¦æ”¾ç½® (${row}, ${col})`, 
                            text: isAttacked ? 'âŒ å—åˆ°æ”»æ“Š (è·³é)' : 'âœ… å®‰å…¨ (æ”¾ç½®)', 
                            formula: `check (${row}, ${col})` 
                        }
                    });

                    if (!isAttacked) {
                        // Place
                        queens.push({r: row, c: col});
                        cols.add(col);
                        diag1.add(row + col);
                        diag2.add(row - col);
                        
                        steps.push({
                            queens: [...queens], row: row, col: col, solutions: [...solutions],
                            highlightLines: [6, 7, 8],
                            explanation: { title: 'æ”¾ç½®çš‡å', text: `æ¨™è¨˜ Col, Diagonals<br>éè¿´è§£æ±º Row ${row+1}`, formula: `solve(${row+1})` }
                        });

                        solve(row + 1);

                        // Backtrack
                        queens.pop();
                        cols.delete(col);
                        diag1.delete(row + col);
                        diag2.delete(row - col);
                        
                        steps.push({
                            queens: [...queens], row: row, col: col, solutions: [...solutions],
                            highlightLines: [9, 10, 11],
                            explanation: { title: 'å›æº¯', text: `ç§»é™¤ (${row}, ${col})<br>å˜—è©¦ä¸‹ä¸€åˆ—`, formula: 'backtrack' }
                        });
                    }
                }
            }

            solve(0);
            
            steps.push({
                queens: [], row: 0, solutions: [...solutions], final: true,
                explanation: { title: 'çµæŸ', text: `å…±æ‰¾åˆ° ${solutions.length} å€‹è§£`, formula: 'Done' }
            });

            return steps;
        }

        let viz;
        function init() {
            // Setup Board
            const board = document.getElementById('boardDisplay');
            board.style.gridTemplateColumns = `repeat(${currentN}, 40px)`;
            board.innerHTML = ''; // Steps will fill it, but maybe initial empty grid
            
            viz = new AlgorithmVisualizer({
                codeLines: codeStructure,
                onStepChange: (step) => {
                    // Render Board
                    board.innerHTML = '';
                    for (let r = 0; r < currentN; r++) {
                        for (let c = 0; c < currentN; c++) {
                            let cls = 'cell ' + ((r + c) % 2 === 0 ? 'light' : 'dark');
                            let content = '';
                            
                            // Check if queen here
                            const isQueen = step.queens?.some(q => q.r === r && q.c === c);
                            if (isQueen) {
                                cls += ' queen';
                                content = 'â™›';
                            }
                            
                            // Highlight trying
                            if (step.trying && step.row === r && step.col === c) {
                                if (step.isAttacked) cls += ' invalid';
                                else cls += ' current';
                            }

                            // Optional: Visualize attacks for current step context?
                            // Simpler: if finding valid spot, show attacks?
                            // Not implemented fully to keep UI clean, "invalid" style is enough
                            
                            const cell = document.createElement('div');
                            cell.className = cls;
                            cell.textContent = content;
                            board.appendChild(cell);
                        }
                    }

                    // Render Solutions Gallery
                    if (step.newFound) {
                        // Scroll to new
                    }
                    const gal = document.getElementById('solutionsDisplay');
                    gal.innerHTML = (step.solutions || []).map(sol => {
                        let miniGrid = '';
                        // Render mini board solution
                        // Since sol is array of {r,c}, we can just map simple dots
                        // CSS grid for mini board
                        const size = 60; 
                        const cellSize = size / currentN;
                        let solHtml = `<div class="mini-board" style="width:${size}px; height:${size}px; grid-template-columns:repeat(${currentN}, 1fr)">`;
                        
                        // We need to fill n*n cells
                        for(let r=0; r<currentN; r++) {
                            for(let c=0; c<currentN; c++) {
                                const hasQ = sol.some(q => q.r === r && q.c === c);
                                solHtml += `<div class="mini-cell ${hasQ?'q':''}"></div>`;
                            }
                        }
                        solHtml += '</div>';
                        return solHtml;
                    }).join('');
                    
                    document.getElementById('countDisplay').textContent = step.solutions ? step.solutions.length : 0;
                }
            });
            viz.setSteps(generateAlgorithmSteps(currentN));
        }

        function resetVisualization() { init(); }
        window.addEventListener('load', init);
    </script>
</body>
</html>
